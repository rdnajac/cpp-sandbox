{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Trying stuff out.</p>"},{"location":"#projects","title":"Projects","text":"<ul> <li>TCP client/server</li> <li><code>std::chrono</code></li> </ul>"},{"location":"#resources","title":"Resources","text":"<p>There are a lot of cool guides and resources out there and I've compiled the ones I've found most helpful here and included them as a submodules in this repo so that they can be easily accessed and updated. The search plugin that comes with the Material for MkDocs theme can be used to search through all the resources at once, even if they're excluded from the nav.</p> <p>I found this cool repo called and I liked it so much, it's built along with the rest of the docs.</p>"},{"location":"#columbia-os-dev-guide","title":"Columbia OS Dev Guide","text":"<p>I took an Operating Systems class at Columbia and the TA staff wrote some really helpful guides that I found myself referring to a lot, even after graduating. They're publicly available here, but I'm unsure if this is the most up-to-date version.</p>"},{"location":"#recitations","title":"Recitations","text":"<p>I've included the recitations from the class in the resources folder. If someone from the CU CS departments finds this and wants me to take it down, please let me know.</p>"},{"location":"#vim-config","title":"vim config","text":"<p>Special shoutout to this page that sent me down a years-long rabbit hole of vim plugins and configurations.</p>"},{"location":"#c-resources","title":"C++ Resources","text":"<p>Modern C++ Features</p> <p>Access it here.</p> <p>When in doubt, check out the C++ Reference.</p>"},{"location":"qsort/","title":"Quicksort","text":"<p>The <code>qsort()</code> function is a modified partition-exchange sort, or quicksort.</p> <pre><code>#include &lt;stdlib.h&gt;\n\nvoid\nqsort(void *base, size_t nel, size_t width,\n    int (*compar)(const void *, const void *));\n</code></pre>"},{"location":"qsort/#compar-function","title":"<code>compar</code> function","text":"<p>The <code>compar</code> function is a user-supplied function that returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.</p> <pre><code>int compar(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n</code></pre> <p>Here, the <code>compar</code> function compares dereferenced pointers-to-integers and returns the difference between the two values. If the difference is negative, the first argument is considered less than the second. If the difference is zero, the two arguments are considered equal.</p>"},{"location":"qsort/#time-complexity","title":"Time complexity","text":"<p>The time complexity of quicksort is O(n log n) on average, but O(n^2) in the worst case.</p> <p>The space complexity is O(log n) on average, but O(n) in the worst case.</p>"},{"location":"tcp/","title":"TCP Echo Server and Client","text":"<p>This project implements a simple TCP echo server and client in C++. The server listens for incoming connections and echoes back any data it receives. The client connects to the server, sends a message, and prints the response.</p>"},{"location":"tcp/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++17 compatible compiler (e.g., GCC 7+ or Clang 5+)</li> <li>Make build system</li> <li>POSIX-compatible operating system (Linux, macOS, etc.)</li> </ul>"},{"location":"tcp/#project-structure","title":"Project Structure","text":"<p>The project consists of the following files:</p> <ul> <li><code>server.cpp</code>: Implementation of the TCP echo server</li> <li><code>client.cpp</code>: Implementation of the TCP echo client</li> <li><code>utils.h</code>: Header file for utility functions</li> <li><code>utils.cpp</code>: Implementation of utility functions</li> <li><code>Makefile</code>: Build script for compiling the project</li> </ul>"},{"location":"tcp/#building-the-project","title":"Building the Project","text":"<p>To build the project, follow these steps:</p> <ol> <li>Open a terminal and navigate to the project directory.</li> <li>Run the following command:</li> </ol> <pre><code>make\n</code></pre> <p>This will compile both the server and client executables.</p>"},{"location":"tcp/#running-the-server","title":"Running the Server","text":"<p>To start the echo server, use the following command:</p> <pre><code>./server &lt;port&gt;\n</code></pre> <p>Replace <code>&lt;port&gt;</code> with the port number you want the server to listen on (e.g., 8080).</p> <p>Example: <pre><code>./server 8080\n</code></pre></p> <p>The server will start and listen for incoming connections on the specified port.</p>"},{"location":"tcp/#running-the-client","title":"Running the Client","text":"<p>To run the client and send a message to the server, use the following command:</p> <pre><code>./client &lt;message&gt; &lt;server-ip&gt; &lt;server-port&gt;\n</code></pre> <ul> <li>Replace <code>&lt;message&gt;</code> with the text you want to send to the server.</li> <li>Replace <code>&lt;server-ip&gt;</code> with the IP address of the server (use 127.0.0.1 for localhost).</li> <li>Replace <code>&lt;server-port&gt;</code> with the port number the server is listening on.</li> </ul> <p>Example: <pre><code>./client \"Hello, Server!\" 127.0.0.1 8080\n</code></pre></p> <p>The client will connect to the server, send the message, receive the echo response, and display it.</p>"},{"location":"tcp/#cleaning-up","title":"Cleaning Up","text":"<p>To remove all compiled files and start fresh, run:</p> <pre><code>make clean\n</code></pre> <p>This will remove the server and client executables, as well as any object files.</p>"},{"location":"tcp/#note","title":"Note","text":"<p>This project is designed for educational purposes and may not be suitable for production environments without further enhancements.</p>"},{"location":"time-complexity/","title":"Time Complexity","text":"<p>Time complexity is a measure of the amount of time an algorithm takes to complete as a function of the size of the input. It is often expressed using big-O notation, which describes the upper bound of the time taken by an algorithm as a function of the size of the input.</p>"},{"location":"time-complexity/#big-o-notation","title":"Big-O notation","text":"<p>Big-O notation describes the upper bound of the time taken by an algorithm as a function of the size of the input. It is used to describe the worst-case performance of an algorithm. For example, an algorithm with a time complexity of O(n) will take at most n steps to complete, where n is the size of the input.</p> <pre><code>int sum(int n)\n{\n    int total = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        total += i;\n    }\n    return total;\n}\n</code></pre> <p>The <code>sum</code> function has a time complexity of O(n) because it takes at most n steps to complete, where n is the input to the function.</p>"},{"location":"time-complexity/#common-time-complexities","title":"Common time complexities","text":"Notation Name Example O(1) Constant time Accessing an element in an array by index (index arithmetic) O(log n) Logarithmic time Binary search (if the input is sorted) O(n) Linear time Finding the maximum element in an array (one-pass) O(n log n) Linearithmic time Quicksort, mergesort (average case) O(n^2) Quadratic time Bubble sort, selection sort (use of nested loops) O(2^n) Exponential time Recursive Fibonacci calculation O(n!) Factorial time Generating all permutations of a set"},{"location":"time-complexity/#comparing-time-complexities","title":"Comparing time complexities","text":"<p>The following table shows how the time complexity of different algorithms compares as the size of the input grows.</p> Input size O(log n) O(n) O(n log n) O(n^2) O(2^n) O(n!) 10 3 10 30 100 1024 3628800 100 7 100 664 10000 1.27e+30 9.33e+157 1000 10 1000 9965 1000000 1.07e+301 4.02e+2567 <p>You get the idea.</p>"},{"location":"tour/","title":"A Tour of C++","text":"<p>During my time at Columbia University, I had the privilege of taking Bjarne Stroustrup's course, \"Design using C++\". Now that I have graduated, I've decided to compile all of my notes into a comprehensive guide. This document serves as an easy reference to accompany the repository of code snippets and examples I have been developing.</p>"},{"location":"tour/#attribution","title":"Attribution","text":"<p>The material in this document is based on concepts and information from: Stroustrup, B. (2022). A Tour of C++ (C++ In-Depth Series) (3rd ed.). Addison-Wesley Professional.</p>"},{"location":"tour/#table-of-contents","title":"Table of Contents","text":"<ol> <li>The Basics</li> <li>User-Defined Types</li> <li>Modularity</li> <li>Error Handling</li> <li>Classes</li> <li>Essential Operations</li> <li>Templates</li> <li>Concepts and Generic Programming</li> <li>Standard-Library</li> <li>Strings and Regular Expressions</li> <li>Input and Output</li> <li>Containers</li> <li>Algorithms</li> <li>Ranges</li> <li>Pointers and Containers</li> <li>Utilities</li> <li>Numerics</li> <li>Concurrency</li> </ol>"},{"location":"tour/#the-basics","title":"The Basics","text":"<pre><code>using namespace std;    // make names from std visible without std::\n</code></pre>"},{"location":"tour/#variables","title":"Variables","text":"<p>Use <code>auto</code> to let the compiler deduce the type of a variable unless there is a specific reason to specify the type.</p> <pre><code>auto i = 7;     // i is an int\nauto d = 1.2;   // d is a double\nauto qq {true}; // qq is a bool\n</code></pre>"},{"location":"tour/#constants","title":"Constants","text":"<p>Use <code>const</code> to define a constant. Use <code>constexpr</code> for a constant expression. For example:</p> <pre><code>constexpr double square(double x) { return x*x; }\n</code></pre>"},{"location":"tour/#loops","title":"Loops","text":"<p>A \"range-<code>for</code>-statement\" traverses a sequence in the simplest way:</p> <pre><code>int v[] = {0, 1, 2, 3, 4, 5};\n\nfor (auto x : v) cout &lt;&lt; x &lt;&lt; '\\n';\n</code></pre> <p>Another example:</p> <pre><code>for (auto&amp; x : v) x *= 2;\n</code></pre>"},{"location":"tour/#user-defined-types","title":"User-Defined Types","text":"<ul> <li>Use 'class' to hide representation and provide an interface.</li> <li>Use 'struct' to group related data without hiding.</li> <li>Prefer 'enum class' over plain enums.</li> <li>Consider std::variant as a type-safe alternative to unions.</li> <li>Use user-defined literals for expressive value specification.</li> </ul>"},{"location":"tour/#structures","title":"Structures","text":"<p>Structures group related data elements:</p> <pre><code>struct DNASequence {\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    std::string source;\n};\n</code></pre>"},{"location":"tour/#classes","title":"Classes","text":"<p>Classes extend structures by adding member functions:</p> <pre><code>class DNA {\npublic:\n    DNA(std::vector&lt;Nucleotide&gt; seq) : sequence{std::move(seq)} {}\n    void addNucleotide(Nucleotide n) { sequence.push_back(n); }\n    size_t length() const { return sequence.size(); }\nprivate:\n    std::vector&lt;Nucleotide&gt; sequence;\n};\n</code></pre> <p>Usage:</p> <pre><code>DNA dna({Nucleotide::A, Nucleotide::T, Nucleotide::G});\ndna.addNucleotide(Nucleotide::C);\nstd::cout &lt;&lt; \"DNA length: \" &lt;&lt; dna.length() &lt;&lt; '\\n';\n</code></pre> <p>Jump ahead to Classes for more information.</p>"},{"location":"tour/#enumerations","title":"Enumerations","text":"<p>Use strongly typed enumerations:</p> <pre><code>enum class Nucleotide {\n    A, // Adenine\n    T, // Thymine\n    G, // Guanine\n    C  // Cytosine\n};\n</code></pre> <p>Nucleotide base = Nucleotide::A;</p>"},{"location":"tour/#unions","title":"Unions","text":"<p>Modern C++ prefers std::variant over unions:</p> <pre><code>#include &lt;variant&gt;\n\nstd::variant&lt;DNA, std::string&gt; genetic_info;\ngenetic_info = DNA({Nucleotide::A, Nucleotide::T});\ngenetic_info = \"ATGC\";  // Now contains a string\n</code></pre>"},{"location":"tour/#user-defined-literals","title":"User-Defined Literals:/","text":"<p>Define custom literals:</p> <pre><code>DNA operator\"\"_dna(const char* seq, size_t len)\n{\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    for (size_t i = 0; i &lt; len; ++i) {\n        switch(seq[i]) {\n            case 'A': nucleotides.push_back(Nucleotide::A); break;\n            case 'T': nucleotides.push_back(Nucleotide::T); break;\n            case 'G': nucleotides.push_back(Nucleotide::G); break;\n            case 'C': nucleotides.push_back(Nucleotide::C); break;\n            default: throw std::invalid_argument(\"Invalid nucleotide\");\n        }\n    }\n    return DNA(nucleotides);\n}\n\nauto my_dna = \"ATGC\"_dna;\n</code></pre>"},{"location":"tour/#type-aliases","title":"Type Aliases","text":"<p>Use 'using' for type aliases:</p> <p>using DNAStrand = std::vector; <p>[!NOTE] I don't like using these in C because they obscure the type of the variable. However, I don't have enough experience with C++ to know if if this is best practice.</p>"},{"location":"tour/#modularity","title":"Modularity","text":"<p>Declarations (interfaces, .h, .hpp) and definitions (implementations, .c, .cpp) should be separate. Where modules are supported (C++20), use them!</p> <p>[!TIP] Header files should emphasize logical structure.</p>"},{"location":"tour/#namespaces","title":"namespaces","text":""},{"location":"tour/#modules","title":"modules","text":""},{"location":"tour/#error-handling","title":"Error Handling","text":""},{"location":"tour/#exceptions","title":"Exceptions","text":"<p>You can throw custon exceptions after defining a class derived from std::exception. For example:</p> <pre><code>class BadLengthException : public std::exception {\nprivate:\n    int length;\n    std::string message;\n\npublic:\n    BadLengthException(int len) : length(len) {\n        message = std::to_string(length);\n    }\n\n    const char* what() const noexcept override {\n        return message.c_str();\n    }\n};\n</code></pre> <ul> <li>invariants</li> <li>error-handling alternatives</li> <li>assertions</li> </ul>"},{"location":"tour/#classes_1","title":"Classes","text":"<p>Three important kinds of C++ classes are:</p> <ul> <li>concrete types</li> <li>abstract types</li> <li>virtual functions</li> </ul>"},{"location":"tour/#concrete-types","title":"Concrete Types","text":"<p>They behave \"just like built-in types.\"!</p>"},{"location":"tour/#classical-user-defined-arithmetic-type","title":"Classical user-defined arithmetic type","text":"<pre><code>class complex {\n    double re, im; // representation: two doubles\npublic:\n    complex(double r, double i) :re{r}, im{i} {}    // construct complex from two scalars\n    complex(double r) :re{r}, im{0} {}              // construct complex from one scalar\n    complex() :re{0}, im{0} {}                      // default complex: {0,0}\n    complex(complex z) :re{z.re}, im{z.im} {}       // copy constructor\n\n    double real() const { return re; }\n    void real(double d) { re=d; }\n    double imag() const { return im; }\n    void imag(double d) { im=d; }\n\n    complex&amp; operator+=(complex z)\n    {\n        re+=z.re;       // add to re and im\n        im+=z.im;\n        return *this;   // return the result\n    }\n\n    complex&amp; operator-=(complex z)\n    {\n        re-=z.re;\n        im-=z.im;\n        return *this;\n    }\n\n    complex&amp; operator*=(complex); // defined out-of-class somewhere\n    complex&amp; operator/=(complex); // defined out-of-class somewhere\n};\n</code></pre>"},{"location":"tour/#abstract-types","title":"Abstract Types","text":"<p>Insulates the user from implementation details by decoupling the interface from the representation.</p> <p>Since we don\u2019t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store and access them through references or pointers.</p> <pre><code>class Container {\npublic:\n    virtual double&amp; operator[](int) = 0;    // pure virtual function\n    virtual int size() const = 0;           // const member function\n    virtual  \u0303Container() {}                 // destructor\n\n    // const member function  // destructor (\u00a75.2.2)\n};\n</code></pre>"},{"location":"tour/#heirarchies","title":"Heirarchies","text":""},{"location":"tour/#essential-operations","title":"Essential Operations","text":"<ul> <li>copy and move</li> <li>resource management</li> <li>operator overloading</li> <li>conventional operations</li> <li>user-defined literals</li> </ul>"},{"location":"tour/#templates","title":"Templates","text":"<ul> <li>parameterized types</li> <li>parameterized operations</li> <li>template mechanisms</li> </ul>"},{"location":"tour/#concepts-and-generic-programming","title":"Concepts and Generic Programming","text":"<ul> <li>concepts</li> <li>generic programming</li> <li>variadic templates</li> <li>template compilation model</li> </ul>"},{"location":"tour/#standard-library","title":"Standard-Library","text":"<ul> <li>components</li> <li>organization</li> </ul>"},{"location":"tour/#strings-and-regular-expressions","title":"Strings and Regular Expressions","text":"<ul> <li>strings</li> <li>string views</li> <li>regular expressions</li> </ul>"},{"location":"tour/#input-and-output","title":"Input and Output","text":"<ul> <li>state</li> <li>user-defined types</li> <li>formatting</li> <li>streams</li> <li>c-style</li> <li>file system</li> </ul>"},{"location":"tour/#containers","title":"Containers","text":""},{"location":"tour/#vector","title":"vector","text":""},{"location":"tour/#insert","title":"insert","text":"<p>Insert expects an iterator and a value to insert:</p> <pre><code>v.insert(v.begin() + 2, 5); // insert 5 at position 2\n</code></pre> <p>Use <code>v.begin()</code> to get an iterator to the beginning of the vector, then add an offset to get the desired position.</p>"},{"location":"tour/#append-to-end","title":"append to end","text":"<p>Use <code>push_back</code> to append to the end of a vector:</p> <pre><code>v.push_back(7);\n</code></pre>"},{"location":"tour/#find-and-insert-after","title":"find and insert after","text":"<p>Use <code>std::find</code> to find a value in a vector:</p> <pre><code>auto it = std::find(v.begin(), v.end(), 5);\nif (it != v.end()) {\n    v.insert(it + 1, 6);\n}\n</code></pre> <ul> <li><code>list</code></li> <li><code>forward_list</code></li> <li><code>map</code></li> <li><code>unordered_map</code></li> <li>allocators</li> <li>container overview</li> </ul>"},{"location":"tour/#algorithms","title":"Algorithms","text":"<ul> <li>iterators</li> <li>use of predicates</li> <li>algorithm overview</li> <li>parallel algorithms</li> </ul>"},{"location":"tour/#ranges","title":"Ranges","text":"<ul> <li>views</li> <li>generators</li> <li>pipelines</li> <li>concepts overview</li> </ul>"},{"location":"tour/#pointers-and-containers","title":"Pointers and Containers","text":"<ul> <li>pointers</li> <li>containers</li> <li>alternatives</li> </ul>"},{"location":"tour/#utilities","title":"Utilities","text":"<ul> <li>time</li> <li>function adaption</li> <li>type functions</li> <li><code>source_location</code></li> <li><code>move()</code> and <code>forward()</code></li> <li>bit manipulation</li> </ul>"},{"location":"tour/#numerics","title":"Numerics","text":"<ul> <li>mathematical functions</li> <li>numerical algorithms</li> <li>complex numbers</li> <li>random numbers</li> <li>vector arithmetic</li> <li>numeric limits</li> <li>mathematical constants</li> </ul>"},{"location":"tour/#concurrency","title":"Concurrency","text":"<ul> <li>tasks and <code>thread</code>s</li> <li>sharing data</li> <li>waiting for events</li> <li>communicating tasks</li> <li>coroutines</li> </ul>"},{"location":"resources/modern-cpp-features/","title":"C++20/17/14/11","text":""},{"location":"resources/modern-cpp-features/#overview","title":"Overview","text":"<p>C++20 includes the following new language features: - coroutines - concepts - designated initializers - template syntax for lambdas - range-based for loop with initializer - [[likely]] and [[unlikely]] attributes - deprecate implicit capture of this - class types in non-type template parameters - constexpr virtual functions - explicit(bool) - immediate functions - using enum - lambda capture of parameter pack - char8_t - constinit</p> <p>C++20 includes the following new library features: - concepts library - synchronized buffered outputstream - std::span - bit operations - math constants - std::is_constant_evaluated - std::make_shared supports arrays - starts_with and ends_with on strings - check if associative container has element - std::bit_cast - std::midpoint - std::to_array</p> <p>C++17 includes the following new language features: - template argument deduction for class templates - declaring non-type template parameters with auto - folding expressions - new rules for auto deduction from braced-init-list - constexpr lambda - lambda capture this by value - inline variables - nested namespaces - structured bindings - selection statements with initializer - constexpr if - utf-8 character literals - direct-list-initialization of enums - [[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes - __has_include - class template argument deduction</p> <p>C++17 includes the following new library features: - std::variant - std::optional - std::any - std::string_view - std::invoke - std::apply - std::filesystem - std::byte - splicing for maps and sets - parallel algorithms - std::sample - std::clamp - std::reduce - prefix sum algorithms - gcd and lcm - std::not_fn - string conversion to/from numbers</p> <p>C++14 includes the following new language features: - binary literals - generic lambda expressions - lambda capture initializers - return type deduction - decltype(auto) - relaxing constraints on constexpr functions - variable templates - [[deprecated]] attribute</p> <p>C++14 includes the following new library features: - user-defined literals for standard library types - compile-time integer sequences - std::make_unique</p> <p>C++11 includes the following new language features: - move semantics - variadic templates - rvalue references - forwarding references - initializer lists - static assertions - auto - lambda expressions - decltype - type aliases - nullptr - strongly-typed enums - attributes - constexpr - delegating constructors - user-defined literals - explicit virtual overrides - final specifier - default functions - deleted functions - range-based for loops - special member functions for move semantics - converting constructors - explicit conversion functions - inline-namespaces - non-static data member initializers - right angle brackets - ref-qualified member functions - trailing return types - noexcept specifier - char32_t and char16_t - raw string literals</p> <p>C++11 includes the following new library features: - std::move - std::forward - std::thread - std::to_string - type traits - smart pointers - std::chrono - tuples - std::tie - std::array - unordered containers - std::make_shared - std::ref - memory model - std::async - std::begin/end</p>"},{"location":"resources/modern-cpp-features/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"resources/modern-cpp-features/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation: <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited: <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value: <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre></p> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"resources/modern-cpp-features/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form: <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety. <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> There are a variety of syntactic forms for enforcing concepts: <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression: <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <p><pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> * Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</p> <p><pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> * Compound requirements - an expression in braces followed by a trailing return type or type constraint.</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> * Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> See also: concepts library.</p>"},{"location":"resources/modern-cpp-features/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized. <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions. <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem. <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed. <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre></p> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed. <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre></p> <p>It can also be applied to the substatement (body) of an iteration statement. <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>. <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration. <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa. <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>. <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>. <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> After: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> Capture parameter packs by reference: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings. <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time. <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"resources/modern-cpp-features/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts: - <code>same_as</code> - specifies two types are the same. - <code>derived_from</code> - specifies that a type is derived from another type. - <code>convertible_to</code> - specifies that a type is implicitly convertible to another type. - <code>common_with</code> - specifies that two types share a common type. - <code>integral</code> - specifies that a type is an integral type. - <code>default_constructible</code> - specifies that an object of a type can be default-constructed.</p> <p>Comparison concepts: - <code>boolean</code> - specifies that a type can be used in Boolean contexts. - <code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</p> <p>Object concepts: - <code>movable</code> - specifies that an object of a type can be moved and swapped. - <code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped. - <code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed. - <code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</p> <p>Callable concepts: - <code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types. - <code>predicate</code> - specifies that a callable type is a Boolean predicate.</p> <p>See also: concepts.</p>"},{"location":"resources/modern-cpp-features/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output). <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers. <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre></p> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span. <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount. <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header. <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context. <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"resources/modern-cpp-features/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string. <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom. <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another. <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow). <pre><code>std::midpoint(1, 3); // == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>. <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"resources/modern-cpp-features/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors. <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments: <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> * - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"resources/modern-cpp-features/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator. * An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds. * An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both. <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>. <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>. <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference. <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre></p> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions. <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre></p> <p>The code above can be written like this: <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures. <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight. <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition. <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value. <pre><code>char x = u8'x';\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax. <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>. * <code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label. <pre><code>switch (n) {\n  case 1: \n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre></p> <ul> <li> <p><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded. <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre></p> </li> <li> <p><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended. <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre></p> </li> </ul>"},{"location":"resources/modern-cpp-features/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"resources/modern-cpp-features/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments. <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre></p> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable: <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"resources/modern-cpp-features/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless). <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type. <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function. <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments. <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space: <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations. <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"resources/modern-cpp-features/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another: <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre></p> <p>Inserting an entire set: <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre></p> <p>Inserting elements which outlive the container: <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre></p> <p>Changing the key of a map element: <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected. <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound. <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> Additionally you can specify transformations for reducers: <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM). <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function. <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>: <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer: <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"resources/modern-cpp-features/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>. <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas. <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked). <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>. <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> Using this reference-captures can have different names than the referenced variable. <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible. <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not. <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre></p> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"resources/modern-cpp-features/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc. <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"resources/modern-cpp-features/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings. <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"resources/modern-cpp-features/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals. <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top: * <code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>. * <code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</p> <p>Convert an array into a tuple: <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety: <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre></p> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"resources/modern-cpp-features/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing: * <code>T&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></p> <p><code>auto</code> type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre></p> <p>Template type parameter deduction with lvalues and rvalues: <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template. <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre></p> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments. <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function. <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time. <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer. <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre></p> <p>Extremely useful for readability, especially for complicated types: <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre></p> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so: <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"resources/modern-cpp-features/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists: * <code>[]</code> - captures nothing. * <code>[=]</code> - capture local objects (local variables, parameters) in scope by value. * <code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference. * <code>[this]</code> - capture <code>this</code> by reference. * <code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</p> <p><pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty). <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>: <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre></p> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"resources/modern-cpp-features/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates. <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>. <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution. <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc. <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression. <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time: <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre></p> <p>Constant expressions with classes: <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list. <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit: <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre></p> <p>String to integer conversion: <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error. <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from. <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre></p> <p>Class cannot be inherited from. <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor. <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre></p> <p>With inheritance: <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects. <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements. <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre></p> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>: <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves. <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments. <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre></p> <p>Note that the braced list syntax does not allow narrowing: <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre></p> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead: <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier. <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"resources/modern-cpp-features/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"resources/modern-cpp-features/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"resources/modern-cpp-features/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"resources/modern-cpp-features/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types. <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> This feature is especially useful when certain return types cannot be resolved: <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"resources/modern-cpp-features/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings. <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax: <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> where: * <code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces. * <code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</p> <p>Example: <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"resources/modern-cpp-features/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference): <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>Transferring <code>std::unique_ptr</code>s: <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>: <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor: <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre></p> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>. <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types. <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared. <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre></p> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe. <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code: <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>. <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead. <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting. <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers: * <code>unordered_set</code> * <code>unordered_multiset</code> * <code>unordered_map</code> * <code>unordered_multimap</code></p>"},{"location":"resources/modern-cpp-features/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * It provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety: <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> * Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</p> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"resources/modern-cpp-features/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"resources/modern-cpp-features/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be: 1. <code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation. 1. <code>std::launch::async</code> Run the callable object on a new thread. 1. <code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</p> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"resources/modern-cpp-features/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended series of books!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> </ul>"},{"location":"resources/modern-cpp-features/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/","title":"Contributing","text":"<p>Before I get started, thank you for contributing! :)</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#issues","title":"Issues","text":"<p>For any typos, errors, or new feature suggestions feel free to open a new issue.</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":"<p>I'm not very picky about how you should contribute, but I ask that the following are met: * Proper spelling and grammar. * If it's a language or library feature that you can write code with, please provide an example of its usage. An optimal submission would also include a short real-world use case for the feature. * Keep additions/deletions of content consistent with the cheatsheet's goals (see below).</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#instructions","title":"Instructions","text":"<ul> <li>Make sure the feature is in the correct C++ version file (i.e. CPP11.md, etc.).</li> <li>Make sure you've added the feature to the table of contents.</li> </ul>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#goals","title":"Goals","text":"<p>My goal for this cheatsheet is to prefer conciseness over absolute completeness. Examples of features should be minimal: if an example is overly complicated, large, or is more of an obscure usage of the feature then it will most likely be rejected in review. The reason for this goal is to teach users what the most popular uses of these features will be, and for a more thorough investigation, to learn about those from external C++ resources.</p>"},{"location":"resources/modern-cpp-features/CPP11/","title":"C++11","text":""},{"location":"resources/modern-cpp-features/CPP11/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++11 includes the following new language features: - move semantics - variadic templates - rvalue references - forwarding references - initializer lists - static assertions - auto - lambda expressions - decltype - type aliases - nullptr - strongly-typed enums - attributes - constexpr - delegating constructors - user-defined literals - explicit virtual overrides - final specifier - default functions - deleted functions - range-based for loops - special member functions for move semantics - converting constructors - explicit conversion functions - inline-namespaces - non-static data member initializers - right angle brackets - ref-qualified member functions - trailing return types - noexcept specifier - char32_t and char16_t - raw string literals</p> <p>C++11 includes the following new library features: - std::move - std::forward - std::thread - std::to_string - type traits - smart pointers - std::chrono - tuples - std::tie - std::array - unordered containers - std::make_shared - std::ref - memory model - std::async - std::begin/end</p>"},{"location":"resources/modern-cpp-features/CPP11/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP11/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing: * <code>T&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></p> <p><code>auto</code> type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre></p> <p>Template type parameter deduction with lvalues and rvalues: <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template. <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre></p> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments. <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function. <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time. <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer. <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre></p> <p>Extremely useful for readability, especially for complicated types: <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre></p> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so: <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"resources/modern-cpp-features/CPP11/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists: * <code>[]</code> - captures nothing. * <code>[=]</code> - capture local objects (local variables, parameters) in scope by value. * <code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference. * <code>[this]</code> - capture <code>this</code> by reference. * <code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</p> <p><pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty). <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>: <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre></p> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates. <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>. <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution. <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc. <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression. <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time: <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre></p> <p>Constant expressions with classes: <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list. <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit: <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre></p> <p>String to integer conversion: <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error. <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from. <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre></p> <p>Class cannot be inherited from. <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor. <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre></p> <p>With inheritance: <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects. <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements. <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre></p> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>: <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves. <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments. <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre></p> <p>Note that the braced list syntax does not allow narrowing: <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre></p> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead: <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier. <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types. <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> This feature is especially useful when certain return types cannot be resolved: <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"resources/modern-cpp-features/CPP11/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings. <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax: <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> where: * <code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces. * <code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</p> <p>Example: <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP11/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference): <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>Transferring <code>std::unique_ptr</code>s: <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>: <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor: <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre></p> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>. <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types. <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared. <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre></p> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe. <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code: <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>. <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead. <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting. <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers: * <code>unordered_set</code> * <code>unordered_multiset</code> * <code>unordered_map</code> * <code>unordered_multimap</code></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * It provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety: <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> * Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</p> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be: 1. <code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation. 1. <code>std::launch::async</code> Run the callable object on a new thread. 1. <code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</p> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP11/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP11/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP11/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP14/","title":"C++14","text":""},{"location":"resources/modern-cpp-features/CPP14/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++14 includes the following new language features: - binary literals - generic lambda expressions - lambda capture initializers - return type deduction - decltype(auto) - relaxing constraints on constexpr functions - variable templates - [[deprecated]] attribute</p> <p>C++14 includes the following new library features: - user-defined literals for standard library types - compile-time integer sequences - std::make_unique</p>"},{"location":"resources/modern-cpp-features/CPP14/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP14/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>. <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas. <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked). <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>. <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> Using this reference-captures can have different names than the referenced variable. <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible. <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not. <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre></p> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"resources/modern-cpp-features/CPP14/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc. <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP14/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings. <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP14/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals. <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top: * <code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>. * <code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</p> <p>Convert an array into a tuple: <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety: <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre></p> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/CPP14/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP14/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP14/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP14/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP17/","title":"C++17","text":""},{"location":"resources/modern-cpp-features/CPP17/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++17 includes the following new language features: - template argument deduction for class templates - declaring non-type template parameters with auto - folding expressions - new rules for auto deduction from braced-init-list - constexpr lambda - lambda capture this by value - inline variables - nested namespaces - structured bindings - selection statements with initializer - constexpr if - utf-8 character literals - direct-list-initialization of enums - [[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes - __has_include - class template argument deduction</p> <p>C++17 includes the following new library features: - std::variant - std::optional - std::any - std::string_view - std::invoke - std::apply - std::filesystem - std::byte - splicing for maps and sets - parallel algorithms - std::sample - std::clamp - std::reduce - prefix sum algorithms - gcd and lcm - std::not_fn - string conversion to/from numbers</p>"},{"location":"resources/modern-cpp-features/CPP17/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP17/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors. <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments: <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> * - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"resources/modern-cpp-features/CPP17/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator. * An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds. * An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both. <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>. <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>. <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference. <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre></p> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions. <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre></p> <p>The code above can be written like this: <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures. <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight. <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition. <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value. <pre><code>char x = u8'x';\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax. <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>. * <code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label. <pre><code>switch (n) {\n  case 1: \n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre></p> <ul> <li> <p><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded. <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre></p> </li> <li> <p><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended. <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre></p> </li> </ul>"},{"location":"resources/modern-cpp-features/CPP17/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP17/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments. <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre></p> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable: <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP17/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless). <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type. <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function. <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments. <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space: <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations. <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"resources/modern-cpp-features/CPP17/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another: <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre></p> <p>Inserting an entire set: <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre></p> <p>Inserting elements which outlive the container: <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre></p> <p>Changing the key of a map element: <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP17/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected. <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound. <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> Additionally you can specify transformations for reducers: <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM). <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function. <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>: <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer: <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP17/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP17/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP17/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP20/","title":"C++20","text":""},{"location":"resources/modern-cpp-features/CPP20/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++20 includes the following new language features: - coroutines - concepts - designated initializers - template syntax for lambdas - range-based for loop with initializer - [[likely]] and [[unlikely]] attributes - deprecate implicit capture of this - class types in non-type template parameters - constexpr virtual functions - explicit(bool) - immediate functions - using enum - lambda capture of parameter pack - char8_t - constinit</p> <p>C++20 includes the following new library features: - concepts library - synchronized buffered outputstream - std::span - bit operations - math constants - std::is_constant_evaluated - std::make_shared supports arrays - starts_with and ends_with on strings - check if associative container has element - std::bit_cast - std::midpoint - std::to_array</p>"},{"location":"resources/modern-cpp-features/CPP20/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP20/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation: <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited: <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value: <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre></p> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"resources/modern-cpp-features/CPP20/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form: <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety. <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> There are a variety of syntactic forms for enforcing concepts: <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression: <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <p><pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> * Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</p> <p><pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> * Compound requirements - an expression in braces followed by a trailing return type or type constraint.</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> * Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> See also: concepts library.</p>"},{"location":"resources/modern-cpp-features/CPP20/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized. <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions. <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem. <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed. <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre></p> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed. <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre></p> <p>It can also be applied to the substatement (body) of an iteration statement. <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>. <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration. <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa. <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>. <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>. <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> After: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> Capture parameter packs by reference: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings. <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time. <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP20/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts: - <code>same_as</code> - specifies two types are the same. - <code>derived_from</code> - specifies that a type is derived from another type. - <code>convertible_to</code> - specifies that a type is implicitly convertible to another type. - <code>common_with</code> - specifies that two types share a common type. - <code>integral</code> - specifies that a type is an integral type. - <code>default_constructible</code> - specifies that an object of a type can be default-constructed.</p> <p>Comparison concepts: - <code>boolean</code> - specifies that a type can be used in Boolean contexts. - <code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</p> <p>Object concepts: - <code>movable</code> - specifies that an object of a type can be moved and swapped. - <code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped. - <code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed. - <code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</p> <p>Callable concepts: - <code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types. - <code>predicate</code> - specifies that a callable type is a Boolean predicate.</p> <p>See also: concepts.</p>"},{"location":"resources/modern-cpp-features/CPP20/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output). <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers. <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre></p> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span. <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount. <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header. <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context. <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP20/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string. <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom. <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another. <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow). <pre><code>std::midpoint(1, 3); // == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>. <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP20/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP20/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP20/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/recitations/","title":"cs4118 Recitations","text":"<p>This repository contains the recitation notes for Columbia's Operating Systems I class, COMSW4118, as taught by Jae Woo Lee and Kostis Kaffes. For information about the class, visit the course homepage.</p> <p>Issues, patches, and comments, especially by current and former students, are welcome.</p>"},{"location":"resources/recitations/#contents","title":"Contents","text":"<ul> <li>Note A: VM/kernel workflow setup, Linux source code   navigators  </li> <li>Note B.1: Sockets/TCP programming, server testing   strategies</li> <li>Note B.2 Diagram: Code visualization for <code>connect2.c</code></li> <li>Note C: Kernel configuration,   compilation, and style</li> <li>Note D.1: Linux wait queue (hw5)</li> <li>Note D.2 Diagram: Diagram of a possible fridge infrastructure</li> <li>Note E.1: Linux scheduler data structures, implementing   a scheduler (hw6)</li> <li>Note E.2: What does each <code>sched_class</code> function do?</li> <li>Note E.3: How are <code>sched_class</code> functions invoked in response to an event (task is preempted, task voluntarily yields, task finishes execution)?</li> </ul>"},{"location":"resources/recitations/A-Workflow/workflow/","title":"VM/Kernel Workflow","text":"<p>Before we get into the heavier assignments in this course, you should invest sometime into setting up a workflow and develop good coding habits.</p>"},{"location":"resources/recitations/A-Workflow/workflow/#why-use-a-vm","title":"Why Use a VM?","text":"<ul> <li>Hypervisor: Software responsible for managing VMs (e.g. creation, deletion,   resource allocation). In this class, we use VMware.</li> <li>Host machine: The hardware running the hypervisor (e.g. your personal laptop)</li> <li>Virtual machine (VM): A computer system created by the hypervisor that shares   resources with the host machine. In this class, we virtualize Debian 11 (a   flavor of Linux). VMs adhere to sandbox properties:</li> <li>Isolate the work you'll be doing from the rest of the system</li> <li>Be able to take snapshots of your development environment so that if it does     get corrupted, you can revert to a clean state</li> </ul> <p>Working on a VM can be preferable to working on your host machine (i.e.   \"bare-metal\"). You can virtualize other operating systems to test your   applications. You can work on potentially buggy/dangerous code without   compromising your host machine.</p> <ul> <li>Snapshot: A feature most hypervisors support. Capture the current running   state of the VM, stores it, and then allows you to revert to that state   sometime later. You should snapshot your VM before executing something that   can compromise the system.</li> </ul> <p>In this class, we will often be \"hacking\" the Linux kernel and attempting to boot into those hacked kernels. We need to use VMs since not all of us have a Linux host machine. Even if we did, we wouldn't want to ruin our host machines with our potentially buggy kernels.</p>"},{"location":"resources/recitations/A-Workflow/workflow/#vm-setupworkflow","title":"VM Setup/Workflow","text":"<p>We've already written a series of guides for working on your VM.</p> <p>First and foremost, you should have a Debian VM installed already (see Debian VM Setup for a guide on how to do this).</p>"},{"location":"resources/recitations/A-Workflow/workflow/#working-on-your-vm","title":"Working on your VM","text":"<p>You have more options than simply working on the VM's graphical interface, which often feels clunky.</p> <p>The most common workflow involves SSHing into your VM, which we've written a guide for. This is a good option if you want to conserve processing power on your host machine and disable the VM's graphical interface. </p> <p>Alternatively, you can setup an IDE to SSH into your VM. One option is using Visual Studio Code, which we've written up some notes (below) on how to use. This is a nice alternative to command-line editors like vim/emacs if you're not familiar with them.</p>"},{"location":"resources/recitations/A-Workflow/workflow/#additional-tools","title":"Additional Tools","text":"<p>If you do decide to work in a command-line environment, here are some tools we've used to streamline our workflow:</p> <ul> <li><code>bat</code>: A better version of <code>cat</code> (installation)</li> <li><code>grep</code>: Pattern-match files (learn how to effectively use regexs to improve   search results). Even better, <code>ripgrep</code>.</li> <li>Reverse-i search: Efficiently search through bash history instead of retyping   long commands.</li> <li><code>tmux</code>: Terminal multiplexer. (e.g. open 2 panes for vim, 1 for <code>dmesg</code>, 1 for   running commands).</li> </ul>"},{"location":"resources/recitations/A-Workflow/workflow/#kernel-workflow","title":"Kernel Workflow","text":""},{"location":"resources/recitations/A-Workflow/workflow/#editor-enhancements","title":"Editor enhancements","text":"<p>Before getting into hw4/supermom, please read through one of our kernel developer workflow guides. These explain how to set up either <code>vim</code> or VSCode for kernel development.</p> <ul> <li>Vim workflow: Here,   we offer a bunch of cool <code>vim</code> additions/tricks to help you develop more   efficiently while working on the kernel assignments. Note that this guide is   only relevant if you intend to work on the command-line using <code>vim</code>. One notable   mention here is <code>cscope</code>. This is a kernel-source navigator that works directly   in your terminal/vim session. This is far more powerful than using <code>grep</code> to   look for a symbol definition/use in the source-tree.</li> <li>VSCode workflow:   In this guide, we explain how to configure autocomplete, formatting, and   various other features for working on the kernel while using VSCode. VSCode   is a very powerful editor, and being able to take advantage of its functionality   will make your life much easier.</li> </ul>"},{"location":"resources/recitations/A-Workflow/workflow/#web-tools","title":"Web Tools","text":"<p>If you don't want to use <code>cscope</code>, there's an popular online kernel-source navigator: bootlin. Note that kernel version matters when you're navigating code \u2013 be sure you select the correct version.</p> <p>Like bootlin, you can look for symbols in the kernel-source and look for instances of where they are defined and used. However, bootlin doesn't index all symbols, so you might have better luck searching with <code>cscope</code>.</p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/","title":"Sockets and Server Testing","text":""},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-and-http","title":"Sockets and HTTP","text":""},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#what-is-a-socket","title":"What is a socket?","text":"<p>A socket is a software construct used for many modes of communication between processes. The mode of communication that this recitation will focus on is network communication. In particular, stream sockets represent an endpoint for reliable, bidirectional connections such as TCP connections. This allows for two processes, on separate computers, to communicate over a TCP/IP network connection.</p> <p>Sockets have: - an IP address, to (typically) identify the computer that the socket endpoint   belongs to - a port number, to identify which process running on the computer the socket   endpoint belongs to - a protocol, such as TCP (reliable) or UDP (unreliable). Stream sockets use TCP</p> <p>An IP address and port number are both required in order for a computer to communicate with a specific process on a remote computer. </p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#the-client-server-model","title":"The client-server model","text":"<p>The two endpoints in a socket connection serve different roles. One end acts as a server:  - It tells the operating system that it should receive incoming connections on a   port number - It waits for incoming connections - When it receives a connection, it creates a new socket for each client,   which will then be used to communicate with that client</p> <p>The other end is a client: - It \"connects\" to the server using the server\u2019s IP address and the port number</p> <p>After a client connects to a server, there is bidirectional communication between the two processes, often with I/O system calls such as <code>read()</code> and <code>write()</code>, or their socket-specific variants <code>recv()</code> and <code>send()</code>. </p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-with-netcat","title":"Sockets with netcat","text":"<p>A simple way to demonstrate the bidirectional and network-based communcation of sockets is with <code>netcat</code>. <code>netcat</code> is a bare-bones program to send streams of binary data over the network.</p> <p>Imagine we have two computers that can communicate over the internet, with the IP addresses <code>clac.cs.columbia.edu</code> and <code>clorp.cs.nyu.edu</code>.</p> <p>Because of the client-server model, connecting two socket endpoints to each other is not a symmetrical process. One socket needs to act as the server, while the other needs to act as a client. You tell <code>netcat</code> to act as a server with the <code>-l</code> flag:</p> <pre><code>joy@clac.cs.columbia.edu:~$ nc -l 10000\n</code></pre> <p>The <code>netcat</code> program on <code>clac.cs.columbia.edu</code> will create a socket and wait for connections on port 10000. To tell <code>netcat</code> to act as a client, you supply the IP address of the server and the port number of the socket listening on that server:</p> <pre><code>jeremy@clorp.cs.nyu.edu:~$ nc clac.cs.columbia.edu 10000\n</code></pre> <p>Notice the differences between these two commands. The first command only requires a port number, and doesn't require the IP address of the other computer. The second command requires knowledge of both the IP address (what computer to connect to) and the port number (which process to connect to on that computer). This asymmetry is the client-server model.</p> <p>After the client connects to the server, the server <code>netcat</code> process creates a new socket for bidirectional communicaiton. After the two processes connect there is no functional difference between client and server. What you type on one end should be visible on the other -- a full duplex stream of data. </p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-api-summary","title":"Sockets API Summary","text":"<p><code>socket()</code> - Called by both the client and the server - On the server-side, a listening socket is created; a connected socket will be   created later by <code>accept()</code></p> <p><code>bind()</code> - Usually called only by the server - Binds the listening socket to a specific port that should be known to the   client</p> <p><code>listen()</code> - Called only by the server - Sets up the listening socket to accept connections</p> <p><code>accept()</code> - Called only by the server - By default blocks until a connection request arrives - Creates and returns a new socket for each client</p> <p><code>connect()</code> - Called only by the client - Requires an IP address and port number to connect to - Attempt to establish connection by reaching out to server</p> <p><code>send()</code> and <code>recv()</code> - Called by both the client and server - Reads and writes to the other side - Message boundaries may not be preserved - nearly the same as <code>write()</code> and <code>read()</code>, but with socket-specific options</p> <p>A TCP client may use these functions as such: <pre><code>int fd = socket(...);\nconnect(fd, ... /* server address */);\n\n// Communicate with the server by send()ing from and recv()ing to fd.\n\nclose(fd);\n</code></pre></p> <p>And a TCP server:</p> <pre><code>int serv_fd = socket(...);\nbind(serv_fd, ... /* server address */);\nlisten(serv_fd, ... /* max pending connections */);\n\n// use an infinite loop, to continue accepting new incoming clients\nfor (;;) {\n    int clnt_fd = accept(serv_fd, ...);\n\n    // Communicate with the client by send()ing from and recv()ing to\n    // clnt_fd, NOT serv_fd.\n\n    close(clnt_fd);\n}\n</code></pre>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#listening-socket-vs-connected-socket","title":"Listening socket vs connected socket","text":"<p>To form a bidirectional channel between client and server, three sockets are used: - The server uses two sockets   - The listening socket, to accept incoming connections from a client   - The client socket, which is created when an incoming connection has been     <code>accept()</code>ed.  - The client uses one socket   - The <code>connect()</code>ing socket, which reaches out to the server. Once the   connection has been made, communication can be done between the server's client   socket and the client's connecting socket.</p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#http-10","title":"HTTP 1.0","text":"<p>HTTP 1.0 is a protocol between a client, typically a web browser, and a server, typically a web server hosting files such as HTML. It is an outdated version of the HTTP protocol and simpler than newer versions.</p> <p>When visiting a website, a URL is specified in the following format:</p> <pre><code>http://example.com:80/index.html\n^^^^   ^^^^^^^^^^^ ^^^^^^^^^^^^^\n|      |           | |\n|      |           | URI = /index.html\n|      |           port number = 80\n|      domain name = example.com\nprotocol = HTTP\n</code></pre> <p>Based on the information provided by the user in the URL, a web client will establish a socket connection with the IP address of the domain name. After establishing the connection, the two computers exchange text in the form of HTTP requests:</p> <ul> <li>The client sends an HTTP request for a resource on the server</li> <li>The server sends an HTTP response</li> </ul> <p>HTTP request - First line: method, request URI, version     - Ex: \"GET /index.html HTTP/1.0\\r\\n\" - Followed by 0 or more headers     - Ex: \"Host: www.google.com\\r\\n\" - Followed by an empty line     - \"\\r\\n\"</p> <p>HTTP response - First line: response status     - Success: \"HTTP/1.0 200 OK\\r\\n\"     - Failure: \"HTTP/1.0 404 Not Found\\r\\n\" - Followed by 0 or more response headers - Followed by an empty line     - \"\\r\\n\" - Followed by the content of the response     - Ex: image file or HTML file</p> <p>We can see the contents of real HTTP requests using <code>netcat</code> by pretending to be either a web client or server. Our client and server won't actually work, since they simply recieve the incoming request but do nothing to process the request or reply. </p> <p>Let's first act as a web server. We tell <code>netcat</code> to open a server connection with <code>nc -l 10000</code>, and then in a web browser navigate to the URL with the domain name of this server. We can use the domain name <code>localhost</code> to specify the local computer rather than connecting to a remote computer over the internet. In Chrome, we'll navigate to the URL <code>http://localhost:10000/index.html</code>. <code>netcat</code> outputs this:</p> <pre><code>$ nc -l 10000\nGET /index.html HTTP/1.1   # GET == method; /index.html == request URI; HTTP/1.1 == version\nHost: localhost:10000      # header\nConnection: keep-alive     # more headers...\n-removed for brevity-\n                           # blank newline to indicate end of headers/request\n</code></pre> <p>To act as a client, we can type our HTTP request manually into netcat rather than doing it through the web browser. Here, we try to send an HTTP request to the domain name <code>example.com</code> on port <code>80</code> (the default for HTTP web servers) for the URI <code>/index.html</code>. Note that we specify the <code>-C</code> with <code>netcat</code> so that newlines are <code>\\r\\n</code> rather than <code>\\n</code> -- a requirement of the HTTP protocol. This flag may vary depending on <code>netcat</code> version -- check <code>man nc</code>.</p> <pre><code>$ nc -C example.com 80\nGET /index.html HTTP/1.0    # GET == method; /index.html == request URI; HTTP/1.1 == version\n                            # blank line to specify end of request\nHTTP/1.0 200 OK             # start of HTTP response. HTTP/1.0 == version; 200 OK == response status\nAccept-Ranges: bytes        # header\nContent-Type: text/html     # more headers...\n-removed for brevity-\n                            # blank newline to indicate end of headers and start of file contents\n&lt;!doctype html&gt;             # HTML contents\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Example Domain&lt;/title&gt;\n-removed for brevity-\n</code></pre>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#testing-your-multi-server","title":"Testing your multi-server","text":""},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#siege","title":"Siege","text":"<p>Siege is a command-line tool that allows you to benchmark your webserver using load testing. Given a few parameters, Siege gives you information about the number of successful transactions to your website, percent availability, the latency/throughput of your server, and more.</p> <p>To install siege, run the following command:</p> <pre><code>sudo apt install siege\n</code></pre> <p>To use siege with your webserver in HW3, run your server and test with the following command:</p> <pre><code>siege http://&lt;hostname&gt;:&lt;port&gt;/&lt;url&gt;\n</code></pre> <p>This will run for an infinite amount of time. When you Ctrl-C out of the command, a list of statistics will be outputted on your terminal.</p> <p>A better way to test with siege is using its options. The <code>-c</code> and <code>-r</code> options are particularly useful, as they allow you to specify the number of concurrent \"users\" and repetitions per user, respectively. For example, the following command will create 25 concurrent users that will each attempt to hit the server 50 times, resulting in 1250 hit attempts:</p> <pre><code>siege -c 25 -r 50 http://&lt;hostname&gt;:&lt;port&gt;/&lt;URI&gt;\n</code></pre> <p>There are many other options, specified in the siege man page. These include <code>-t</code>, which specifies how long each user should run (as opposed to how many times), and <code>-f</code>, which specifies a file path that contains a list of URLs to test. </p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#additional-guidance-on-testingbenchmarking","title":"Additional guidance on testing/benchmarking","text":"<p>When grading, we're going to test your implementation using a mix of manual connections (e.g. using tools like netcat) and stress testers like siege.</p> <p>You should use <code>netcat</code> to make sure that basic functionality works and that you can indeed have more than 1 connection to the server at any given time. <code>netcat</code> is nice because it allows you to establish a connection and then prompts you for the data to send. You should also use <code>netcat</code> to test that your cleanup logic is correct, as you can control exactly when connections start/terminate.</p> <p>Your server should be resilient to any client failure. <code>netcat</code> is a useful tool to test these kinds of failures, as you can simulate bad requests or disconnections at various points during the transaction. Your server should be able to gracefully handle these scenarios -- under no condition should your server crash because of a client failure.</p> <p>Once you've tested the basic functionality, use a stress tester to make sure that your server handles concurrent hoards of requests in a reasonable amount of time. Since we're all on VMs running on different host machines, we can't really say \"X requests must finish in Y seconds\". We're just looking to make sure that your server doesn't take years (e.g. because it is actually serializing requests).</p> <p>Our grading scripts make heavy use of siege url files. siege will basically make requests using the URLs specified in this file. Use this to make sure your server can concurrently handle all kinds of requests and correctly respond to all of them (2xx, 4xx, 5xx, multi-server never responds with 3xx).</p> <p>Regarding benchmarking, the assignment prompt occasionally instructs you to compare the performance of the implementation of one part with another. However, since you are testing multi-server in a virtual machine, the performance isn\u2019t guaranteed to be significantly better. As such, don\u2019t worry too much about the benchmarking instructions - it\u2019s not a hard and fast requirement.</p>"},{"location":"resources/recitations/B-Sockets-ServerTesting/sockets-servertesting/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Some examples were taken from John Hui's Advanced   Programming lecture notes. We recommend   reading them on top of these recitation notes.</li> <li>Lecture 13 - TCP/IP Networking</li> <li>Lecture 14 - HTTP</li> </ul>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/","title":"Linux Kernel Development","text":"<p>This document is meant to supplement our compilation guide, which goes over how to install a new kernel on your machine.</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-module-makefile","title":"Kernel Module Makefile","text":"<p>More info in our kernel module guide, but for the sake of comparison, here it is again:</p> <pre><code>obj-m += hello.o\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre> <p>This Makefile is separate from the top-level kernel source Makefile we're about to work with. Here, we're adding to the <code>obj-m</code> \"goal definition\" (build object as module) and using a specialized Makefile located at <code>/lib/modules/$(shell uname -r)/build</code> to link our module into the kernel.</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#top-level-kernel-makefile","title":"Top-level Kernel Makefile","text":"<p><code>linux/Makefile</code> is the only Makefile you'll be executing when developing with the kernel. At a high level, this Makefile is responsible for:</p> <ul> <li>recursively calling Makefiles in subdirectories</li> <li>generating kernel configurations</li> <li>building and installing kernel images</li> </ul> <p>Here's an overview of the common operations you'll be doing with this Makefile.</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#preparing-for-development","title":"Preparing for development","text":"<p>It's good practice to ensure you have a clean kernel source before beginning to development. Here's the cleaning options that this Makefile provides, as reported by <code>make help</code>:</p> <pre><code>Cleaning targets:\n  clean       - Remove most generated files but keep the config and\n                enough build support to build external modules\n  mrproper    - Remove all generated files + config + various backup files\n  distclean.  - mrproper + remove editor backup and patch files\n</code></pre> <p><code>make mrproper</code> is usually sufficient for our purposes. Be warned that you'll have to completely rebuild the kernel after running this!</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#configuration-and-compilation","title":"Configuration and compilation","text":"<p><code>linux/.config</code> is the kernel's configuration file. It lists a bunch of options that determine the properties of the kernel you're about to build. It also determines what code will be compiled and linked into the final kernel image. For example, if <code>CONFIG_SMP</code> is set, you're letting the kernel know that you have more than one processor so it can provide multi-processing functionality.</p> <p>There's a bunch of different ways to generate this configuration file. Here's the relevant options we have, as reported by <code>make help</code> in the top-level kernel directory:</p> <pre><code>Configuration targets:\n  config          - Update current config utilising a line-oriented program\n  menuconfig      - Update current config utilising a menu based program\n  oldconfig       - Update current config utilising a provided .config as base\n  localmodconfig  - Update current config disabling modules not loaded\n  defconfig       - New config with default from ARCH supplied defconfig\n  olddefconfig    - Same as oldconfig but sets new symbols to their\n                    default value without prompting\n</code></pre> <p>Summarizing from our compilation guide, we set up our kernel config in a couple of steps:</p> <pre><code>make olddefconfig # Use current kernel's .config + ARCH defaults\nmake menuconfig   # Manually edit some configs\n</code></pre> <p>If you want to significantly reduce your build time, you can also set your config to skip unloaded modules during compilation:</p> <pre><code>yes '' | make localmodconfig\n</code></pre> <p>As you're developing in the kernel, you might add additional source files that need to be compiled and linked in. Open up the directory's Makefile and add your desired object file to the <code>obj-y</code> goal definition, which is for \"built-in\" functionality (as opposed to kernel modules). For example, here's the relevant portion of <code>linux/kernel/Makefile</code>:</p> <pre><code>obj-y     = fork.o exec_domain.o panic.o \\\n        cpu.o exit.o softirq.o resource.o \\\n        sysctl.o sysctl_binary.o capability.o ptrace.o user.o \\\n        signal.o sys.o umh.o workqueue.o pid.o task_work.o \\\n        extable.o params.o \\\n        kthread.o sys_ni.o nsproxy.o \\\n        notifier.o ksysfs.o cred.o reboot.o \\\n        async.o range.o smpboot.o ucount.o\n</code></pre> <p>If you were adding a source file to <code>linux/kernel</code>, you'd add the object file target here.</p> <p>Once you're ready to compile your kernel, you run the following in the top-level source directory:</p> <pre><code>make -j $(nproc)\n</code></pre> <p>This will compile your kernel across all available CPUs, as reported by <code>nproc</code>. Note that this top-level Makefile will recursively build source code in subdirectories for you!</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-installation","title":"Kernel installation","text":"<p>Like in our compilation guide, you run the following command once the compilation finishes:</p> <pre><code>sudo make modules_install &amp;&amp; sudo make install\n</code></pre> <p>The first time you install a kernel, you must build <code>modules_install</code>. All subsequent times, <code>install</code> is sufficient.</p> <p>Finally, reboot and select the kernel version you just installed via the GRUB menu!</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-code-style","title":"Kernel Code Style","text":"<p>The kernel source comes with a linter written in Perl (located at <code>linux/scripts/checkpatch.pl</code>).</p> <p>checkpatch will let you know about any stylistic errors and warnings that it finds in the codebase. You should get into the habit of running checkpatch and fixing what it suggests before major checkpoints.</p> <p>If you want a general overview of kernel code style, here's one. You can also find this in <code>linux/Documentation/process/coding-style.rst</code>.</p>"},{"location":"resources/recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#debugging-techniques","title":"Debugging Techniques","text":"<ul> <li>Take   snapshots   of your VM before installing software that may corrupt it.</li> <li>Use <code>printk/pr_info</code> to log messages to the kernel log buffer (viewable in   userspace with by running <code>sudo dmesg</code>)</li> <li>Set up a serial port to redirect log   buffer to your host machine (in case VM crashes before you can check it with   <code>dmesg</code>).</li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer/","title":"Implementing a scheduling class","text":"<p>This guide describes the data structures used for implementing a scheduling class. To understand how these data structures are used, you can find more specific information here and here. The first guide goes through the <code>sched_class</code> functions one by one. The second guide shows how these functions are invoked from an event-driven perspective (e.g. what happens on a timer interrupt? what happens when a process is done executing?).</p>"},{"location":"resources/recitations/E-Freezer/freezer/#introduction","title":"Introduction","text":"<p>One of the reasons students struggle with this assignment boils down to a lack of understanding of how the scheduler works. In this guide, I hope to provide you with a clear understanding of how the Linux scheduler pieces fit together. I hope to paint a picture that you can use to implement the freezer scheduler.</p>"},{"location":"resources/recitations/E-Freezer/freezer/#the-task_struct","title":"The <code>task_struct</code>","text":"<p>Recall from HW1 that in Linux, every process is defined by its <code>struct task_struct</code>. When you have multiple tasks forked off a common parent, they are linked together in a doubly linked-list <code>struct list_head sibling</code> embedded within the <code>task_struct</code>. For example, if you had four processes running on your system, each forked off one parent, it would look something like this (the parent is not shown):</p> <p>However, at this stage, none of these processes are actually running on a CPU. In order to get them onto a CPU, I need to introduce you to the <code>struct rq</code>.</p>"},{"location":"resources/recitations/E-Freezer/freezer/#the-struct_rq","title":"The <code>struct_rq</code>","text":"<p>The <code>struct rq</code> is a per-cpu run queue data structure. I like to think of it as the virtual CPU. It contains a lot of information (most of which goes way over my head), but it also includes the list of tasks that will (eventually) run on that CPU.</p> <p>A naive implementation would be to embed a <code>struct list_head runqueue_head</code> (for example) into the <code>struct rq</code>, and embed a <code>struct list_head node</code> into every <code>task_struct</code>.</p>      This is a BAD implementation.  <p>The main problem with this implementation is that it does not extend well. At this point, you know Linux has more than one scheduling class. Linux comes built with a deadline class, a real-time class, and the primary CFS. Having a <code>list_head</code> embedded directly into the <code>struct rq</code> for each scheduling class is not feasible.</p> <p>The solution is to create a new structure containing the <code>list_head</code> and any bookkeeping variables. Then, we can include just the wrapper structure in the <code>struct rq</code>. Linux includes these structures in <code>linux/kernel/sched/sched.h</code>.</p> <p>By convention, Linux scheduler-specific wrapper structures are named <code>struct &lt;sched_class&gt;_rq</code>. For example, the CFS class defines a <code>struct cfs_rq</code> which is then declared inside of <code>struct rq</code> as <code>struct cfs_rq cfs</code>.</p> <p>The following snippet is taken from <code>linux/kernel/sched/sched.h</code>:</p> <pre><code>struct cfs_rq {\n    struct load_weight  load;\n    unsigned int        nr_running;\n    unsigned int        h_nr_running;\n    unsigned int        idle_h_nr_running;\n    /* code omitted */\n};\n\nstruct rq {\n    /* code omitted */\n    struct cfs_rq       cfs;\n    struct rt_rq        rt;\n    struct dl_rq        dl;\n    /* code omitted */\n};\n</code></pre>"},{"location":"resources/recitations/E-Freezer/freezer/#the-freezer_rq","title":"The <code>freezer_rq</code>","text":"<p>At this point, you've probably guessed that you will need to do the same thing for freezer. You are right. The <code>freezer_rq</code> should include the head of the freezer runqueue. Additionally, you may need to include some bookkeeping variables. Think of what you would actually need and don't add anything extra (it should be pretty simple).</p>"},{"location":"resources/recitations/E-Freezer/freezer/#the-sched_freezer_entity","title":"The <code>sched_freezer_entity</code>","text":"<p>Now that you have the <code>struct rq</code> setup, you need to have some mechanism to join your <code>task_struct</code>s into the queue. Here, too, you can't just include a <code>list_head node</code> to add a task onto the scheduler-specific runqueue because you'll need additional bookkeeping. As you have probably guessed, we are going to wrap the <code>list_head</code> and all the bookkeeping variables into their own struct.</p> <p>In Linux, we name these structs <code>sched_{class}_entity</code> (one exception is that CFS names this <code>sched_entity</code>). For example, the real-time scheduling class calls it <code>sched_rt_entity</code>. We will name ours <code>struct sched_freezer_entity</code>. Again, make sure you only include what you need in this struct.</p> <p>With all this setup, here is what the final picture looks like:</p> <p>In the picture above, the two structs on the far left represent a system with two CPUs. I colored these blue and green to distinguish them from each other, and to show that different <code>task_structs</code> linked on one <code>siblings</code> linked-list can run on separate CPUs.</p>"},{"location":"resources/recitations/E-Freezer/freezer/#the-sched_class","title":"The <code>sched_class</code>","text":"<p>At this point, we have set up the data structures, but we are still not done. We now need to implement the freezer functionality to let the kernel use freezer as a scheduler.</p> <p>Think about this situation: Say we have a CFS task about to return from main(). The OS needs to call CFS <code>dequeue_task()</code> to remove it from the CFS queue. How can we ensure that the OS will call the CFS implementation of <code>dequeue_task()</code>? The answer is <code>struct sched_class</code>, defined in <code>linux/kernel/sched/sched.h</code>. Here is what the structure looks like:</p> <pre><code>struct sched_class {\n\n#ifdef CONFIG_UCLAMP_TASK\n    int uclamp_enabled;\n#endif\n\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task)   (struct rq *rq);\n    bool (*yield_to_task)(struct rq *rq, struct task_struct *p);\n\n    void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);\n\n    struct task_struct *(*pick_next_task)(struct rq *rq);\n\n    void (*put_prev_task)(struct rq *rq, struct task_struct *p);\n    void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);\n\n#ifdef CONFIG_SMP\n    int (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n    int  (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n    void (*migrate_task_rq)(struct task_struct *p, int new_cpu);\n\n    void (*task_woken)(struct rq *this_rq, struct task_struct *task);\n\n    void (*set_cpus_allowed)(struct task_struct *p,\n                 const struct cpumask *newmask);\n\n    void (*rq_online)(struct rq *rq);\n    void (*rq_offline)(struct rq *rq);\n#endif\n\n    void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork)(struct task_struct *p);\n    void (*task_dead)(struct task_struct *p);\n\n    /*\n     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we\n     * cannot assume the switched_from/switched_to pair is serliazed by\n     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.\n     */\n    void (*switched_from)(struct rq *this_rq, struct task_struct *task);\n    void (*switched_to)  (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task,\n                  int oldprio);\n\n    unsigned int (*get_rr_interval)(struct rq *rq,\n                    struct task_struct *task);\n\n    void (*update_curr)(struct rq *rq);\n\n#define TASK_SET_GROUP      0\n#define TASK_MOVE_GROUP     1\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    void (*task_change_group)(struct task_struct *p, int type);\n#endif\n} __aligned(STRUCT_ALIGNMENT); /* STRUCT_ALIGN(), vmlinux.lds.h */\n</code></pre> <p>As you can see, <code>struct sched_class</code> contains many function pointers. When we add a new scheduling class, we create an instance of <code>struct sched_class</code> and set the function pointers to point to our implementation of these functions. If we look in the file <code>linux/kernel/sched/fair.c</code>, we see how CFS does it:</p> <pre><code>const struct sched_class fair_sched_class\n    __section(\"__fair_sched_class\") = {\n    .enqueue_task       = enqueue_task_fair,\n    .dequeue_task       = dequeue_task_fair,\n    .yield_task     = yield_task_fair,\n    .yield_to_task      = yield_to_task_fair,\n\n    .check_preempt_curr = check_preempt_wakeup,\n\n    .pick_next_task     = __pick_next_task_fair,\n    .put_prev_task      = put_prev_task_fair,\n    .set_next_task          = set_next_task_fair,\n\n#ifdef CONFIG_SMP\n    .balance        = balance_fair,\n    .select_task_rq     = select_task_rq_fair,\n    .migrate_task_rq    = migrate_task_rq_fair,\n\n    .rq_online      = rq_online_fair,\n    .rq_offline     = rq_offline_fair,\n\n    .task_dead      = task_dead_fair,\n    .set_cpus_allowed   = set_cpus_allowed_common,\n#endif\n\n    .task_tick      = task_tick_fair,\n    .task_fork      = task_fork_fair,\n\n    .prio_changed       = prio_changed_fair,\n    .switched_from      = switched_from_fair,\n    .switched_to        = switched_to_fair,\n\n    .get_rr_interval    = get_rr_interval_fair,\n\n    .update_curr        = update_curr_fair,\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    .task_change_group  = task_change_group_fair,\n#endif\n\n#ifdef CONFIG_UCLAMP_TASK\n    .uclamp_enabled     = 1,\n#endif\n};\n</code></pre> <p>Note that the dot notation is a C99 feature that allows you to set specific fields of the struct by name in an initializer. This notation is also called designated initializers. Also, not every function needs to be implemented. You will need to figure out what is and is not necessary. To see an example of a bare minimum scheduler, see the idle_sched_class, which is the scheduling policy used when no other tasks are ready to be executed.</p> <p>As you can see, CFS initializes the <code>struct sched_class</code> function pointers to the CFS implementation. Two things of note here. First, the convention is to name the struct <code>&lt;class_name&gt;_sched_class</code>, so CFS names it <code>fair_sched_class</code>. Second, we name a particular class's functions as <code>&lt;function_name&gt;_&lt;class_name&gt;</code>. For example, the CFS implementation of <code>enqueue_task</code> as <code>enqueue_task_fair</code>. Now, every time the kernel needs to call a function, it can simply call <code>p-&gt;sched_class-&gt;&lt;function()&gt;</code>. Here, <code>p</code> is of the type <code>task_struct *</code>, <code>sched_class</code> is a pointer within the <code>task_struct</code> pointing to an instance of <code>struct sched_class</code>, and the <code>&lt;function()&gt;</code> points to the specific implementaion of the the function to be called.</p> <p>One final thing: you may have noticed the <code>__section(\"__fair_sched_class\")</code> macro in the declaration of<code>struct sched_class fair_sched_class</code>. When building the kernel, this allows the linker to align the <code>sched_class</code>'s contiguously in memory through the use of a linker script. A linker script describes how various sections in the input (source) files should be mapped into the output (binary/object) file, and to control the memory layout of the output file.</p> <p>We can see this in <code>linux/include/asm-generic/vmlinux.lds.h</code>:</p> <pre><code>/*\n * The order of the sched class addresses are important, as they are\n * used to determine the order of the priority of each sched class in\n * relation to each other.\n */\n#define SCHED_DATA              \\\n    STRUCT_ALIGN();             \\\n    __begin_sched_classes = .;      \\\n    *(__idle_sched_class)           \\\n    *(__fair_sched_class)           \\\n    *(__rt_sched_class)         \\\n    *(__dl_sched_class)         \\\n    *(__stop_sched_class)           \\\n    __end_sched_classes = .;\n</code></pre> <p>This effectively allows the kernel to treat the <code>sched_class</code> structs as part of an array of <code>sched_class</code>'s. The first class in the array is of lower priority than the second. In other words, <code>sched_class_dl</code> has a higher priority than <code>sched_class_rt</code>. Now, every time a new process needs to be scheduled, the kernel can simply go through the class array and check if there is a process of that class that needs to run. Let's take a look at this as implemented in <code>linux\\kernel\\sched\\core.c</code>.</p> <pre><code>static inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n    const struct sched_class *class;\n    struct task_struct *p;\n\n    /* code omitted */\n\n    for_each_class(class) {\n        p = class-&gt;pick_next_task(rq);\n        if (p)\n            return p;\n    }\n\n    /* The idle class should always have a runnable task: */\n    BUG();\n}\n</code></pre> <p>This makes use of the <code>for_each_class()</code> macro, which takes advantage of the array structure of the <code>sched_class</code>'s. We can see this implementation in <code>linux/kernel/sched/sched.h</code>:</p> <pre><code>/* Defined in include/asm-generic/vmlinux.lds.h */\nextern struct sched_class __begin_sched_classes[];\nextern struct sched_class __end_sched_classes[];\n\n#define sched_class_highest (__end_sched_classes - 1)\n#define sched_class_lowest  (__begin_sched_classes - 1)\n\n#define for_class_range(class, _from, _to) \\\n    for (class = (_from); class != (_to); class--)\n\n#define for_each_class(class) \\\n    for_class_range(class, sched_class_highest, sched_class_lowest)\n</code></pre> <p>Essentially, when a process wants to relinquish its time on a CPU, <code>schedule()</code> gets called. Following the chain of calls in the kernel, <code>pick_next_task()</code> eventually gets called, and the OS will loop through each scheduling class by calling <code>for_each_class(class)</code>. Here, we call the <code>pick_next_task()</code> function of a particular instance of <code>struct sched_class</code>. If <code>pick_next_task()</code> returns <code>NULL</code>, the kernel will simply move on to the next class. If the kernel reaches the lowest priority class on the list (i.e. <code>idle_sched_class</code>) then there are no tasks to run and the CPU will go into idle mode.</p>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/","title":"Freezer runqueue","text":"<p>This guide was written by Ryan Wee in Spring 2024. The code snippets and links in this post correspond to Linux v5.10.205.</p>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/#introduction","title":"Introduction","text":"<p>First of all, it is entirely possible (and probable) that there are mistakes in this guide. If so, feel free to contact the TA team.</p> <p>This guide is meant to complement Mitchell's guide -- it's a good idea to read both of them. Mitchell's guide explains what each of the <code>sched_class</code> functions do. The aim of this guide is to provide an event-driven perspective of how these functions are invoked. In particular, how is the freezer runqueue modified in response to different events?</p>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/#tldr","title":"TLDR","text":"<ul> <li>Freezer's <code>pick_next_task()</code> implementation does NOT modify the freezer   runqueue. It only picks the task at the front of the freezer runqueue.</li> <li>When a task is preempted because its timeslice is up, freezer's <code>task_tick()</code>   implementation is responsible for modifying the freezer runqueue.</li> <li>When a task voluntarily yields the CPU, there are two possibilities:<ul> <li>The task's state is <code>RUNNABLE</code>, i.e. it would like to stay on the     run queue: In this case, freezer's <code>yield_task()</code> and <code>task_tick()</code>     implementations are responsible for modifying the freezer runqueue.</li> <li>The task's state is NOT <code>RUNNABLE</code>, i.e. it would like to leave the     run queue: In this case, freezer's <code>dequeue_task()</code> implementation is responsible for modifying the freezer runqueue.</li> </ul> </li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/#when-a-tasks-timeslice-is-up","title":"When a task's timeslice is up","text":"<ul> <li>The timer interrupt code calls <code>scheduler_tick()</code>.</li> <li>This function invokes <code>curr-&gt;sched_class-&gt;task_tick()</code>.</li> <li>Freezer's <code>task_tick()</code> implementation should decrement the current task's   timeslice. (Note that the timeslice should therefore use jiffies as the unit.)</li> <li>If the current task's timeslice is down to 0:<ul> <li>Freezer's <code>task_tick()</code> implementation should move the current task to the   end of the runqueue. At this point, the task is still running on the CPU!   We've just modified its position on the runqueue.</li> <li>Freezer's <code>task_tick()</code> implementation should call <code>resched_curr()</code>, which   sets the <code>TIF_NEED_RESCHED</code> flag. Again, at this point, the task is still running on the CPU!</li> </ul> </li> <li>The kernel checks <code>TIF_NEED_RESCHED</code> on interrupt and userspace return paths.   When it's safe (e.g. the process isn't holding any spinlocks), the kernel   calls <code>schedule()</code>, which in turn invokes <code>__schedule()</code>.</li> <li>This huge <code>if</code> block is NOT executed.<ul> <li>In particular, recall that the <code>task_struct</code> has a <code>state</code> field. When a task is <code>RUNNABLE</code>, the state field is zero. When a task is not <code>RUNNABLE</code>, the state field is non-zero.</li> <li>In this case, the task is still <code>RUNNABLE</code>, i.e. <code>prev_state</code> is zero. So the <code>if</code> block is not executed.</li> </ul> </li> <li><code>schedule()</code> eventually calls <code>pick_next_task()</code> here, which calls Freezer's <code>pick_next_task()</code> implementation.</li> <li>Freezer's <code>pick_next_task()</code> implementation should return a new task from the   front of the feezer runqueue.</li> <li><code>__schedule()</code> also eventually calls <code>context_switch()</code> here, which is where the actual context switch happens.</li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/#when-a-task-voluntarily-yields-but-is-runnable","title":"When a task voluntarily yields, but is RUNNABLE","text":"<p>In this case, the task wants to be remain on the runqueue. It's just telling the kernel: \"Okay, you can shift me to the back of the runqueue because I'm nice. But feel free to select me again when you want to!\"</p> <ul> <li>The task calls the <code>sched_yield</code> syscall, which in turn invokes <code>do_sched_yield()</code>.</li> <li><code>do_sched_yield</code> calls <code>current-&gt;sched_class-&gt;yield_task()</code>.</li> <li>Freezer's <code>yield_task()</code> implementation should set the timeslice of the   task to 0.</li> <li>Now the next time we have a timer interrupt, the task is 'pre-empted' as described above by freezer's <code>task_tick()</code> implementation. (I put that in quotation marks because the task voluntarily decided to let itself be pre-empted.)</li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer_runqueue/#when-a-task-voluntarily-yields-and-is-not-runnable","title":"When a task voluntarily yields, and is not RUNNABLE","text":"<p>In this case, the task wants to be taken off the runqueue. This could be because the task called <code>__wait_event_interruptible()</code>, or <code>sleep()</code>, or anything that basically indicates it wants to suspend its execution for the near future. Another common case would be when the task finishes its execution.</p> <ul> <li>The task starts by modifying its state so that it is no longer <code>RUNNABLE</code>. It then calls <code>__schedule()</code> with <code>false</code> as an argument.<ul> <li>In the case of a task finishing its execution:<ul> <li>The task calls the <code>exit()</code> syscall, which calls <code>do_exit()</code>.</li> <li>This in turn calls <code>do_task_dead()</code> here.</li> <li><code>do_task_dead()</code> modifies the task state here, and then calls <code>__schedule()</code> here.</li> </ul> </li> <li>In the case of a task calling <code>sleep()</code>:<ul> <li>The task calls the <code>nanosleep()</code> syscall, which calls <code>hrtimer_nanosleep()</code> and then <code>do_nanosleep()</code>.</li> <li><code>do_nanosleep()</code> modifies the task state here, and then calls <code>freezable_schedule()</code> here. This in turn calls <code>schedule()</code>.</li> </ul> </li> </ul> </li> <li>In all of these cases, when <code>__schedule()</code> is called, the <code>state</code> field of the <code>task_struct</code> is no longer <code>RUNNABLE</code>, i.e. it is non-zero. Since <code>state</code> is non-zero and since the <code>preempt</code> argument was <code>false</code> as mentioned above, we go into this <code>if</code> block.</li> <li>This in turn calls <code>deactivate_task()</code> here.</li> <li><code>deactivate_task()</code> calls <code>dequeue_task()</code>, which in turn calls the <code>dequeue_task()</code> implementation of the current scheduling class.</li> <li>Freezer's <code>dequeue_task()</code> implementation should remove the current task from the freezer runqueue.</li> <li>Recall that we're still within an earlier invocation of <code>__schedule()</code>. This invocation calls <code>pick_next_task()</code> and <code>context_switch()</code> as mentioned above. Since the current task has been removed from the freezer runqueue, this causes the next task in the runqueue to be run.</li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/","title":"Freezer sched_class","text":"<p>This guide is adapted from a blog series written by Mitchell Gouzenko, a former OS TA. The original posts can be found here.</p> <p>The code snippets and links in this post correspond to Linux v5.10.205 for 2024 Spring.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#introduction","title":"Introduction","text":"<p>I'm writing this series after TA-ing an operating systems class for two semesters. Each year, tears begin to flow by the time we get to the infamous Scheduler Assignment - where students are asked to implement a round-robin scheduler in the Linux kernel. The assignment is known to leave relatively competent programmers in shambles. I don't blame them; the seemingly simple task of writing a round robin scheduler is complicated by two confounding factors:</p> <ul> <li>The Linux scheduler is cryptic as hell and on top of that, very poorly   documented.</li> <li>Bugs in scheduler code will often trigger a kernel panic, freezing the system   without providing any logs or meaningful error messages.</li> </ul> <p>I hope to ease students' suffering by addressing the first bullet point. In this series, I will explain how the scheduler's infrastructure is set up, emphasizing how one may leverage its modularity to plug in their own scheduler.</p> <p>We'll begin by examining the basic role of the core scheduler and how the rest of the kernel interfaces with it. Then, we'll look at <code>sched_class</code>, the modular data structure that permits various scheduling algorithms to live and operate side-by-side in the kernel.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#a-top-down-approach","title":"A Top Down Approach","text":"<p>Initially, I'll treat the scheduler as a black box. I will make gross over-simplifications but note very clearly when I do so. Little by little, we will delve into the scheduler's internals, unfolding the truth behind these simplifications. By the end of this series, you should be able to start tackling the problem of writing your own working scheduler.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#disclaimer","title":"Disclaimer","text":"<p>I'm not an expert kernel hacker. I'm just a student who has spent a modest number of hours reading, screaming at, and sobbing over kernel code. If I make a mistake, please point it out in the comments section, and I'll do my best to correct it.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#what-is-the-linux-scheduler","title":"What is the Linux Scheduler?","text":"<p>Linux is a multi-tasking system. At any instant, there are many processes active at once, but a single CPU can only perform work on behalf of one process at a time. At a high level, Linux context switches from process to process, letting the CPU perform work on behalf of each one in turn. This switching occurs quickly enough to create the illusion that all processes are running simultaneously. The scheduler is in charge of coordinating all of this switching.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#where-does-the-scheduler-fit","title":"Where Does the Scheduler Fit?","text":"<p>You can find most scheduler-related code under <code>kernel/sched</code>. Now, the scheduler has a distinct and non-trivial job. The rest of the kernel doesn't know or care how the scheduler performs its magic, as long as it can be called upon to schedule tasks. So, to hide the complexity of the scheduler, it is invoked with a simple and well-defined API. The scheduler - from the perspective of the rest of the kernel - has two main responsibilities:</p> <ul> <li> <p>Responsibility I: Provide an interface to halt the currently running process and switch to a new one. To do so, the scheduler must pick the next process to run, which is a nontrivial problem.</p> </li> <li> <p>Responsibility II: Indicate to the rest of the OS when a new process should be run.</p> </li> </ul>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#responsibility-i-switching-to-the-next-process","title":"Responsibility I: Switching to the Next Process","text":"<p>To fulfill its first responsibility, the scheduler must somehow keep track of all the running processes.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#the-runqueue","title":"The Runqueue","text":"<p>Here's the first over-simplification: you can think of the scheduler as a system that maintains a simple queue of processes in the form of a linked list. The process at the head of the queue is allowed to run for some \"time slice\" - say, 10 milliseconds. After this time slice expires, the process is moved to the back of the queue, and the next process gets to run on the CPU for the same time slice. When a running process is forcibly stopped and taken off the CPU in this way, we say that it has been preempted. The linked list of processes waiting to have a go on the CPU is called the runqueue. Each CPU has its own runqueue, and a given process may appear on only one CPU's runqueue at a time. Processes CAN migrate between various CPUs' runqueues, but we'll save this discussion for later.</p>      Figure 1: An over-simplification of the runqueue  <p>The scheduler is not really this simple; the runqueue is defined in the kernel as <code>struct rq</code>, and you can take a peek at its definition here. Spoiler alert: it's not a linked list! To be fair, the explanation that I gave above more or less describes the very first Linux runqueue. But over the years, the scheduler evolved to incorporate multiple scheduling algorithms. These include:</p> <ul> <li>Completely Fair Scheduler (CFS)</li> <li>Real-Time Scheduler</li> <li>Deadline Scheduler</li> </ul> <p>The modern-day runqueue is no longer a linked list but actually a collection of algorithm-specific runqueues corresponding to the list above. Indeed, <code>struct rq</code> has the following members:</p> <pre><code>struct cfs_rq cfs;  // CFS scheduler runqueue\nstruct rt_rq rt;    // Real-time scheduler runqueue\nstruct dl_rq dl;    // Deadline scheduler runqueue\n</code></pre> <p>For example, CFS, which is the default scheduler in modern Linux kernels, uses a red-black tree data structure to keep track of processes, with each process assigned a \"virtual runtime\" that determines its priority in the scheduling queue. The scheduler then selects the process with the lowest virtual runtime to run next, ensuring that each process gets a fair share of CPU time over the long term.</p> <p>Keep these details in the back of your mind so that you don't get bogged down. Remember: the goal here is to understand how the scheduler interoperates with the rest of the kernel. The main takeaway is that a process is allowed to run for some time, and when that time expires, it gets preempted so that the next process can run.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#preemption-vs-yielding","title":"Preemption vs Yielding","text":"<p>Preemption is not always the reason a process is taken off the CPU. For example, a process might voluntarily go to sleep, waiting for an IO event or lock. To do this, the process puts itself on a \"wait queue\" and takes itself off the runqueue. In this case, the process has yielded the CPU. In summary:</p> <ul> <li> <p>\"preemption\" is when a process is forcibly kicked off the CPU.</p> </li> <li> <p>\"yielding\" is when a process voluntarily gives up the CPU.</p> </li> </ul> <p>In addition to an expired timeslice, there are several other reasons that preemption may occur. For example, when an interrupt occurs, the CPU may be preempted to handle the interrupt. Additionally, a real-time process may have a higher priority than some other process and may preempt lower-priority processes to ensure that it meets its deadline.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#schedule","title":"<code>schedule()</code>","text":"<p>With a conceptual understanding of the runqueue, we now have the background to understand how Responsibility I is carried out by the scheduler. The <code>schedule()</code> function is the crux of Responsibility I: it halts the currently running process and runs the next one on the CPU. This function is referred to by many texts as \"the entrypoint into the scheduler\". <code>schedule()</code> invokes <code>__schedule()</code> to do most of the real work. Here is the portion relevant to us:</p> <pre><code>static void __sched notrace __schedule(bool preempt)\n{\n    struct task_struct *prev, *next;\n    unsigned long *switch_count;\n    struct rq *rq;\n\n    /* CODE OMITTED */\n\n    next = pick_next_task(rq, prev, &amp;rf);\n    clear_tsk_need_resched(prev);\n    clear_preempt_need_resched();\n\n    if (likely(prev != next)) {\n        rq-&gt;nr_switches++;\n        RCU_INIT_POINTER(rq-&gt;curr, next);\n        ++*switch_count;\n\n        psi_sched_switch(prev, next, !task_on_rq_queued(prev));\n        trace_sched_switch(preempt, prev, next);\n        rq = context_switch(rq, prev, next, &amp;rf);\n    }\n\n    /* CODE OMITTED */\n}\n</code></pre> <p><code>pick_next_task()</code> looks at the runqueue <code>rq</code> and returns the <code>task_struct</code> associated with the process that should be run next. If we consider t=10 in Figure 1, <code>pick_next_task()</code> would return the <code>task_struct</code> for Process 2. Then, <code>context_switch()</code> switches the CPU's state to that of the returned <code>task_struct</code>. This fullfills Responsibility I.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#responsibility-ii-when-should-the-next-process-run","title":"Responsibility II: When Should the Next Process Run?","text":"<p>Great, so we've seen that <code>schedule()</code> is used to context switch to the next task. But when does this actually happen?</p> <p>As mentioned previously, a user-space program might voluntarily go to sleep waiting for an IO event or a lock. In this case, the kernel will call <code>schedule()</code> on behalf of the process that needs to sleep. But what if the user-space program never sleeps? Here's one such program:</p> <pre><code>int main()\n{\n    while(1);\n}\n</code></pre> <p>If <code>schedule()</code> were only called when a user-space program voluntarily sleeps, then programs like the one above would use up the processor indefinitely. Thus, we need a mechanism to preempt processes that have exhausted their time slice!</p> <p>This preemption is accomplished via the timer interrupt. The timer interrupt fires periodically, allowing control to jump to the timer interrupt handler in the kernel. This handler calls the function <code>update_process_times()</code>, shown below.</p> <pre><code>/*\n * Called from the timer interrupt handler to charge one tick to the current\n * process.  user_tick is 1 if the tick is user time, 0 for system.\n */\nvoid update_process_times(int user_tick)\n{\n    struct task_struct *p = current;\n\n    PRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n    /* Note: this timer irq context must be accounted for as well. */\n    account_process_tick(p, user_tick);\n    run_local_timers();\n    rcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n    if (in_irq())\n        irq_work_tick();\n#endif\n    scheduler_tick();\n    if (IS_ENABLED(CONFIG_POSIX_TIMERS))\n        run_posix_cpu_timers();\n}\n</code></pre> <p>Notice how <code>update_process_times()</code> invokes <code>scheduler_tick()</code>. In <code>scheduler_tick()</code>, the scheduler checks to see if the running process's time has expired. If so, it sets a (over-simplification alert) per-CPU flag called <code>need_resched</code>. This indicates to the rest of the kernel that <code>schedule()</code> should be called. In our simplified example, <code>scheduler_tick()</code> would set this flag when the current process has been running for 10 milliseconds or more.</p> <p>But wait, why the heck can't <code>scheduler_tick()</code> just call <code>schedule()</code> by itself, from within the timer interrupt? After all, if the scheduler knows that a process's time has expired, shouldn't it just context switch right away?</p> <p>As it turns out, it is not always safe to call <code>schedule()</code>. In particular, if the currently running process is holding a spinlock in the kernel, it cannot be put to sleep from the interrupt handler. (Let me repeat that one more time because people always forget: you cannot sleep with a spinlock. Sleeping with a spinlock may cause the kernel to deadlock, and will bring you anguish for many hours when you can't figure out why your system has hung.)</p> <p>When the scheduler sets the <code>need_resched</code> flag, it's really saying, \"please dearest kernel, invoke <code>schedule()</code> at your earliest convenience.\" The kernel keeps a count of how many spinlocks the currently running process has acquired. When that count goes down to 0, the kernel knows that it's okay to put the process to sleep. The kernel checks the <code>need_resched</code> flag in two main places:</p> <ul> <li> <p>when returning from an interrupt handler</p> </li> <li> <p>when returning to user-space from a system call</p> </li> </ul> <p>If <code>need_resched</code> is <code>True</code> and the spinlock count is 0, then the kernel calls <code>schedule()</code>. With our simple linked-list runqueue, this delayed invocation of <code>schedule()</code> implies that a process can possibly run for a bit longer than its timeslice. We're cool with that because it's always safe to call <code>schedule()</code> when the kernel is about to return to user-space. That's because user-space programs are allowed to sleep. So, by the time the kernel is about to return to user-space, it cannot be holding any spinlocks. This means that there won't be a large delay between when <code>need_resched</code> is set, and when <code>schedule()</code> gets called.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#understanding-sched_class","title":"Understanding <code>sched_class</code>","text":"<p>In this section, I will analyze <code>struct sched_class</code> and talk briefly about what most of the functions do. I've reproduced <code>struct sched_class</code> below.</p> <pre><code>struct sched_class {\n\n#ifdef CONFIG_UCLAMP_TASK\n    int uclamp_enabled;\n#endif\n\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task)   (struct rq *rq);\n    bool (*yield_to_task)(struct rq *rq, struct task_struct *p);\n\n    void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);\n\n    struct task_struct *(*pick_next_task)(struct rq *rq);\n\n    void (*put_prev_task)(struct rq *rq, struct task_struct *p);\n    void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);\n\n#ifdef CONFIG_SMP\n    int (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n    int  (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n    void (*migrate_task_rq)(struct task_struct *p, int new_cpu);\n\n    void (*task_woken)(struct rq *this_rq, struct task_struct *task);\n\n    void (*set_cpus_allowed)(struct task_struct *p,\n                 const struct cpumask *newmask);\n\n    void (*rq_online)(struct rq *rq);\n    void (*rq_offline)(struct rq *rq);\n#endif\n\n    void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork)(struct task_struct *p);\n    void (*task_dead)(struct task_struct *p);\n\n    /*\n     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we\n     * cannot assume the switched_from/switched_to pair is serliazed by\n     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.\n     */\n    void (*switched_from)(struct rq *this_rq, struct task_struct *task);\n    void (*switched_to)  (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task,\n                  int oldprio);\n\n    unsigned int (*get_rr_interval)(struct rq *rq,\n                    struct task_struct *task);\n\n    void (*update_curr)(struct rq *rq);\n\n#define TASK_SET_GROUP      0\n#define TASK_MOVE_GROUP     1\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    void (*task_change_group)(struct task_struct *p, int type);\n#endif\n} __aligned(STRUCT_ALIGNMENT); /* STRUCT_ALIGN(), vmlinux.lds.h */\n</code></pre>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#enqueue_task-and-dequeue_task","title":"<code>enqueue_task()</code> and <code>dequeue_task()</code>","text":"<pre><code>/* Called to enqueue task_struct p on runqueue rq. */\nvoid enqueue_task(struct rq *rq, struct task_struct *p, int flags);\n\n/* Called to dequeue task_struct p from runqueue rq. */\nvoid dequeue_task(struct rq *rq, struct task_struct *p, int flags);\n</code></pre> <p><code>enqueue_task()</code> and <code>dequeue_task()</code> are used to put a task on the runqueue and remove a task from the runqueue, respectively.</p> <p>These functions are called for a variety of reasons:</p> <ul> <li> <p>When a child process is first forked, <code>enqueue_task()</code> is called to put it on   a runqueue. When a process exits, <code>dequeue_task()</code> takes it off the runqueue.</p> </li> <li> <p>When a process goes to sleep, <code>dequeue_task()</code> takes it off the runqueue. For   example, this happens when the process needs to wait for a lock or IO event.   When the IO event occurs, or the lock becomes available, the process wakes up.   It must then be re-enqueued with <code>enqueue_task()</code>.</p> </li> <li> <p>Process migration - if a process must be migrated from one CPU's runqueue to   another, it's dequeued from its old runqueue and enqueued on a different one   using this function.</p> </li> <li> <p>When <code>set_cpus_allowed()</code> is called to change the task's processor affinity,   it may need to be enqueued on a different CPU's runqueue.</p> </li> <li> <p>When the priority of a process is boosted to avoid priority inversion. In this   case, the task used to have a low-priority <code>sched_class</code>, but is being   promoted to a <code>sched_class</code> with high priority. This action occurs in   <code>rt_mutex_setprio()</code>.</p> </li> <li> <p>From <code>__sched_setscheduler</code>. If a task's <code>sched_class</code> has changed, it's   dequeued using its old <code>sched_class</code> and enqueued with the new one.</p> </li> </ul> <p>Each of these functions are passed the task to be enqueued/dequeued, as well as the runqueue it should be added to/removed from. In addition, these functions are given a bit vector of flags that describe why enqueue or dequeue is being called. Here are the various flags, which are described in sched.h:</p> <pre><code>/*\n * {de,en}queue flags:\n *\n * DEQUEUE_SLEEP  - task is no longer runnable\n * ENQUEUE_WAKEUP - task just became runnable\n *\n * SAVE/RESTORE - an otherwise spurious dequeue/enqueue, done to ensure tasks\n *                are in a known state which allows modification. Such pairs\n *                should preserve as much state as possible.\n *\n * MOVE - paired with SAVE/RESTORE, explicitly does not preserve the location\n *        in the runqueue.\n *\n * ENQUEUE_HEAD      - place at front of runqueue (tail if not specified)\n * ENQUEUE_REPLENISH - CBS (replenish runtime and postpone deadline)\n * ENQUEUE_MIGRATED  - the task was migrated during wakeup\n *\n */\n</code></pre> <p>The <code>flags</code> argument can be tested using the bitwise <code>&amp;</code> operation. For example, if the task was just migrated from another CPU, <code>flags &amp; ENQUEUE_MIGRATED</code> evaluates to 1.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#pick_next_task","title":"<code>pick_next_task()</code>","text":"<pre><code>/* Pick the task that should be currently running. */\nstruct task_struct *pick_next_task(struct rq *rq);\n</code></pre> <p><code>pick_next_task()</code> is called by the core scheduler to determine which of <code>rq</code>'s tasks should be running. The name is a bit misleading: This function is not supposed to return the task that should run after the currently running task; instead, it's supposed to return the <code>task_struct</code> that should be running now, in this instant.</p> <p>The kernel will context switch from the currently running task to the task returned by <code>pick_next_task()</code>.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#put_prev_task","title":"<code>put_prev_task()</code>","text":"<pre><code>/* Called right before p is going to be taken off the CPU. */\nvoid put_prev_task(struct rq *rq, struct task_struct *p);\n</code></pre> <p><code>put_prev_task()</code> is called whenever a task is to be taken off the CPU. The behavior of this function is up to the specific <code>sched_class</code>. Some schedulers do very little in this function. For example, the realtime scheduler uses this function as an opportunity to perform simple bookkeeping. On the other hand, CFS's <code>put_prev_task_fair()</code> needs to do a bit more work. As an optimization, CFS keeps the currently running task out of its RB tree. It uses the <code>put_prev_task</code> hook as an opportunity to put the currently running task (that is, the task specified by <code>p</code>) back in the RB tree.</p> <p>The sched_class's <code>put_prev_task</code> is called by the function <code>put_prev_task()</code>, which is defined in <code>sched.h</code>. <code>put_prev_task()</code> gets called in the core scheduler's <code>pick_next_task()</code>, after the policy-specific <code>pick_next_task()</code> implementation is called, but before any context switch is performed. This gives us an opportunity to perform any operations we need to do to move on from the previously running task in our scheduler implementations.</p> <p>Note that this was not the case in older kernels: The <code>sched_class</code>'s <code>pick_next_task()</code> is expected to call <code>put_prev_task()</code> by itself! This is documented in the following comment in an earlier Linux version (4.9). Before that (3.11), <code>put_prev_task</code> actually used to be called by the core scheduler before it called <code>pick_next_task</code>.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#task_tick","title":"<code>task_tick()</code>","text":"<pre><code>/* Called from the timer interrupt handler. p is the currently running task\n * and rq is the runqueue that it's on.\n */\nvoid task_tick(struct rq *rq, struct task_struct *p, int queued);\n</code></pre> <p>This is one of the most important scheduler functions. It is called whenever a timer interrupt happens, and its job is to perform bookeeping and set the <code>need_resched</code> flag if the currently-running process needs to be preempted:</p> <p>The <code>need_resched</code> flag can be set by the function <code>resched_curr()</code>, found in core.c:</p> <pre><code>/* Mark rq's currently-running task 'to be rescheduled now'. */\nvoid resched_curr(struct rq *rq)\n</code></pre> <p>With SMP, there's a <code>need_resched</code> flag for every CPU. Thus, <code>resched_curr()</code> might involve sending an APIC inter-processor interrupt to another processor (you don't want to go here). The takeway is that you should just use <code>resched_curr()</code> to set <code>need_resched</code>, and don't try to do this yourself.</p> <p>Note: in prior kernel versions, <code>resched_curr()</code> used to be called <code>resched_task()</code>.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#select_task_rq","title":"<code>select_task_rq()</code>","text":"<pre><code>/* Returns an integer corresponding to the CPU that this task should run on */\nint select_task_rq(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n</code></pre> <p>The core scheduler invokes this function to figure out which CPU to assign a task to. This is used for distributing processes accross multiple CPUs; the core scheduler will call <code>enqueue_task()</code>, passing the runqueue corresponding to the CPU that is returned by this function. CPU assignment obviously occurs when a process is first forked, but CPU reassignment can happen for a large variety of reasons. Here are some instances where <code>select_task_rq()</code> is called:</p> <ul> <li> <p>When a process is first forked.</p> </li> <li> <p>When a task is woken up after having gone to sleep.</p> </li> <li> <p>In response to any of the syscalls in the execv family. This is an   optimization, since it doesn't hurt the cache to migrate a process that's   about to call exec.</p> </li> <li> <p>And many more places...</p> </li> </ul> <p>You can check why <code>select_task_rq</code> was called by looking at <code>sd_flag</code>.</p> <p>For instance, <code>sd_flag == SD_BALANCE_FORK</code> whenever <code>select_task_rq()</code> is called to determine the CPU of a newly forked task. You can find all possible values of <code>sd_flag</code> here.</p> <p>Note that <code>select_task_rq()</code> should return a CPU that <code>p</code> is allowed to run on. Each <code>task_struct</code> has a member called <code>cpus_mask</code>, of type <code>cpumask_t</code>. This member represents the task's CPU affinity - i.e. which CPUs it can run on. It's possible to iterate over these CPUs with the macro <code>for_each_cpu()</code>, defined here.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#set_next_task","title":"<code>set_next_task()</code>","text":"<pre><code>/* Called when a task changes its scheduling class or changes its task group. */\nvoid set_next_task(struct rq *rq, struct task_struct *p, bool first);\n</code></pre> <p>This function is called in the following instances:</p> <ul> <li> <p>When the current task's CPU affinity changes.</p> </li> <li> <p>When the current task's priority, nice value, or scheduling policy changes.</p> </li> <li> <p>When the current task's task group changes.</p> </li> </ul> <p>This function was previously called <code>set_curr_task()</code>, but was changed to better match <code>put_prev_task()</code>. Several scheduling policies also call <code>set_next_task()</code> in their implementations of <code>pick_next_task()</code>. An old kernel commit claims that <code>pick_next_task()</code> implies <code>set_next_task()</code>, but <code>pick_next_task()</code> technically shouldn't modify any state. In practice, this means that <code>set_next_task()</code> ends up just updating some of the task's metadata.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#yield_task","title":"<code>yield_task()</code>","text":"<pre><code>/* Called when the current task yields the cpu */\nvoid yield_task(struct rq *rq);\n</code></pre> <p><code>yield_task()</code> is used when the current process voluntarily yields its remaining time on the CPU. Its implementation is usually very simple, as you can see in rt, which simply requeues the current task.</p> <p>This function is called when a process calls the <code>sched_yield()</code> syscall to relinquish the control of the processor voluntarily. <code>schedule()</code> is then called.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#check_preempt_curr","title":"<code>check_preempt_curr()</code>","text":"<pre><code>/* Preempt the current task with a newly woken task if needed */\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n</code></pre> <p>When a new task enters a runnable state, this function is called to check if that task should preempt the currently running task. For instance, when a new task is created, it is initially woken up with <code>wake_up_new_task()</code>, which (among other things) places the task on the runqueue, calls the generic <code>check_preempt_curr()</code>, and calls the <code>sched_class-&gt;task_woken()</code> function if it exists.</p> <p>The generic <code>check_preempt_curr()</code> function does the following:</p> <pre><code>void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n    if (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class)\n        rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);\n    else if (p-&gt;sched_class &gt; rq-&gt;curr-&gt;sched_class)\n        resched_curr(rq);\n\n    /* CODE OMITTED */\n}   \n</code></pre> <p>This handles both the case where the new task has a higher priority within a scheduling class (using the callback pointer) or a higher priority scheduling class.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#balance","title":"<code>balance()</code>","text":"<pre><code>int balance(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n</code></pre> <p><code>balance()</code> implements various scheduler load-balancing mechanisms, which are meant to distribute the load across processors more evenly using various heuristics. It returns <code>1</code> if there is a runnable task of that <code>sched_class</code>'s priority or higher after load balancing occurs, and <code>0</code> otherwise.</p> <p><code>balance()</code> is called in <code>put_prev_task_balance()</code> (which is called in <code>pick_next_task()</code>) as follows:</p> <pre><code>static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,\n                  struct rq_flags *rf)\n{\n#ifdef CONFIG_SMP\n    const struct sched_class *class;\n    /*\n     * We must do the balancing pass before put_prev_task(), such\n     * that when we release the rq-&gt;lock the task is in the same\n     * state as before we took rq-&gt;lock.\n     *\n     * We can terminate the balance pass as soon as we know there is\n     * a runnable task of @class priority or higher.\n     */\n    for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class) {\n        if (class-&gt;balance(rq, prev, rf))\n            break;\n    }\n#endif\n\n    put_prev_task(rq, prev);\n}\n</code></pre> <p>The main idea is to prevent any runqueue from becoming empty, as this is a waste of resources. This loop starts with the currently running task's <code>sched_class</code> and uses the <code>balance()</code> callbacks to check if there are runnable tasks of that <code>sched_class</code>'s priority or higher. Notably, <code>sched_class</code>'s implementation of <code>balance()</code> checks if <code>sched_class</code>s of higher priority also have runnable tasks.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#update_curr","title":"<code>update_curr()</code>","text":"<pre><code>/* Update the current task's runtime statistics. */\nvoid update_curr(struct rq *rq);\n</code></pre> <p>This function updates the current task's stats such as the total execution time. Implementing this function allows commands like <code>ps</code> and <code>htop</code> to display accurate statistics. The implementations of this function typically share a common segment across the different scheduling classes. This function is typically called in other <code>sched_class</code> functions to facilitate accurate reporting of statistics.</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#prio_changed","title":"<code>prio_changed()</code>","text":"<pre><code>/* Called when the task's priority has changed. */\nvoid prio_changed(struct rq *rq, struct task_struct *p, int oldprio)\n</code></pre> <p>This function is called whenever a task's priority changes, but the <code>sched_class</code> remains the same (you can verify this by checking where the function pointer is called). This can occur through various syscalls which modify the <code>nice</code> value, the priority, or other scheduler attributes.</p> <p>In a scheduler class with priorities, this function will typically check if the task whose priority changed needs to preempt the currently running task (or if it is the currently running task, if it should be preempted).</p>"},{"location":"resources/recitations/E-Freezer/freezer_sched_class/#switched_to","title":"<code>switched_to()</code>","text":"<pre><code>/* Called when a task gets switched to this scheduling class. */\nvoid switched_to(struct rq *rq, struct task_struct *p);\n</code></pre> <p><code>switched_to()</code> (and its optional counterpart, <code>switched_from()</code>) are called from <code>check_class_changed()</code>:</p> <pre><code>static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n                       const struct sched_class *prev_class,\n                       int oldprio)\n{\n    if (prev_class != p-&gt;sched_class) {\n        if (prev_class-&gt;switched_from)\n            prev_class-&gt;switched_from(rq, p);\n\n        p-&gt;sched_class-&gt;switched_to(rq, p);\n    } else if (oldprio != p-&gt;prio || dl_task(p))\n        p-&gt;sched_class-&gt;prio_changed(rq, p, oldprio);\n}\n</code></pre> <p><code>check_class_changed()</code> gets called from syscalls that modify scheduler parameters.</p> <p>For scheduler classes like rt and dl, the main consideration when a task's policy changes to their policy is that it could overload their runqueue. They then try to push some tasks to other runqueues.</p> <p>However, for lower priority scheduler classes, like CFS, where overloading is not an issue, <code>switched_to()</code> just ensures that the task gets to run, and preempts the current task (which may be of a lower-priority policy) if necessary.</p>"},{"location":"resources/recitations/F-Farfetchd/","title":"Understanding Page Tables in Linux","text":"<p>The goal of this recitation is to provide a high-level overview of x86/arm64 paging as well as the data structures and functions the Linux kernel uses to manipulate page tables.</p> <p>Before we dive into the details, here's a quick refresher on what a page table does and how it does it. Page tables allow the operating system to virtualize the entire address space for each process by providing a mapping between virtual addresses and physical addresses. What is a virtual address? Every address that application code references is a virtual address. For the most part this is true of kernel code as well, except for code that executes before paging is enabled (think bootloader). Once paging is enabled in the CPU it cannot be disabled. Every address referenced by an application is translated transparently by the hardware via the page table.</p> <p>A virtual address is usually different than the physical address it maps to, but it is also possible for virtual addresses to be \"identity\" mapped to their corresponding physical address or mapped to no address at all in cases where the kernel swapped out a page or never allocated one in the first place.</p>"},{"location":"resources/recitations/F-Farfetchd/#the-shape-of-a-page-table","title":"The shape of a page table","text":"<p>Recall that the structure of the page table is rigidly specified by the CPU architecture. This is necessary since the CPU hardware directly traverses the page table to transparently map virtual addresses to physical addresses. The hardware does this by using the virtual address as a set of indices into the page table.</p> <p>Source</p> <p>This diagram shows how the bits of a 64 bit virtual address specify the indices into a 4-level x86 page table (you can expect something similar in arm64). With 4-level paging only bits 0 through 47 are used. Bits 48 through 63 are sign extension bits that must match bit 47; this prevents clever developers from stuffing extra information into addresses that might interfere with future addressing schemes, like 5-level page tables.</p> <p>As you can see, there are 9 bits specifying the index into each page table and a 12 bit offset into the physical page frame. Since 2^9 = 512, each level of the page table has 512 64 bit entries, which fits perfectly in one 4096 byte frame. The last 12 bits allow the virtual address to specify a specific byte offset within the page frame.</p> <p>For clarity, we're using the naming scheme in the diagram (P4, P3,...), which differs slightly from the names used in Linux. Linux also implements 5-level paging, which we describe in the next section. For reference, here is how the names above mapped to Linux before it added 5-level paging:</p> <pre><code>Diagram: P4  -&gt; P3  -&gt; P2  -&gt; P1  -&gt; page frame\nLinux:   PGD -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n</code></pre> <p>Each entry in the P4 table is the address of a different P3 table such that each page table can have up to 512 different P3 tables. In turn, each entry in a P3 table points to a different P2 table such that there are 512 * 512 = 262,144 P2 tables. Since most of the virtual address space is unused for a given process, the kernel does not allocate frames for most of the intermediary tables comprising the page table.</p> <p>I've been using the word frame since each page table entry (in any table, P4, P3, etc) is the address of a physical 4096 byte memory frame (except for huge pages). These addresses cannot be virtual addresses since the hardware accesses them directly to translate virtual addresses to physical addresses. Furthermore, since frames are page aligned, the last 12 bits of a frame address are all zeros. The hardware takes advantage of this by using these bits to store information about the frame in its page table entry.</p> <p>Source</p> <p>This diagram shows the bit flags for a page table entry, which in our diagram above corresponds to an entry in the P1 table. A similar but slightly different set of flags exists for the intermediary entries as well.</p>"},{"location":"resources/recitations/F-Farfetchd/#working-with-page-tables-in-linux","title":"Working with page tables in Linux","text":"<p>In this section we'll take a look at the data structures and functions the Linux kernel defines to manage page tables.</p>"},{"location":"resources/recitations/F-Farfetchd/#the-fifth-level-of-dantes-page-table","title":"The fifth level of Dante's page table","text":"<p>We just finished discussing 4-level page tables, but Linux actually implements 5-level paging and exposes a 5-level paging interface, even when the kernel is built with 5-level paging disabled. Luckily 5-level paging is similar to the 4-level scheme we discussed, is simply adds another level of indirection and uses 9 previously unused bits of the 64 bit virtual address to index it.</p> <p>Here's what the page table hierarchy looks like in Linux:</p> <pre><code>4-Level Paging (circa 2016)\nDiagram Above\n    P4  -&gt; P3  -&gt; P2  -&gt; P1  -&gt; page frame\nLinux\n    PGD -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n\n5-Level Paging (current)\nLinux\n    PGD -&gt; P4D -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n</code></pre> <p>What does this mean for us in light of the fact that our kernel config specifies 4 level paging?</p> <pre><code>CONFIG_PGTABLE_LEVELS=4\n</code></pre> <p>If we look at the output from an example program that reports the physical addresses of the process' page frame and of the intermediate page tables, it shows that the <code>p4d_paddr</code> and <code>pud_paddr</code> are identical.</p> <pre><code>[405] inspect_physical_address():\npaddr: 0x115a3c069\npf_paddr: 0x115a3c000\npte_paddr: 0x10d2c7000\npmd_paddr: 0x10d623000\npud_paddr: 0x10c215000\np4d_paddr: 0x10c215000\npgd_paddr: 0x10c90a000\ndirty: no\nrefcount: 57\n</code></pre> <p>Digging into <code>arch/x86/include/asm/pgtable_types.h</code>, we see the following:</p> <p><pre><code>#if CONFIG_PGTABLE_LEVELS &gt; 4\ntypedef struct { p4dval_t p4d; } p4d_t;\n\nstatic inline p4d_t native_make_p4d(pudval_t val)\n{\n    return (p4d_t) { val };\n}\n\nstatic inline p4dval_t native_p4d_val(p4d_t p4d)\n{\n    return p4d.p4d;\n}\n#else\n#include &lt;asm-generic/pgtable-nop4d.h&gt;\n\nstatic inline p4d_t native_make_p4d(pudval_t val)\n{\n    return (p4d_t) { .pgd = native_make_pgd((pgdval_t)val) };\n}\n\nstatic inline p4dval_t native_p4d_val(p4d_t p4d)\n{\n    return native_pgd_val(p4d.pgd);\n}\n#endif\n</code></pre> x86 Source</p> <p>Interesting. Looking at <code>pgtable-nop4d.h</code> we find that <code>p4d_t</code> is defined as <pre><code>typedef struct { pgd_t pgd; } p4d_t;\n</code></pre></p> <p>With 4-level paging the p4d folds into the pgd. p4d entries, which are represented by <code>p4d_t</code>, essentially become a type alias for <code>pgd_t</code>. The kernel does this so that it has a standard 5-level page table interface to program against regardless of how many levels of page tables actually exist.</p> <p>As of writing, arm64 (for linux 5.10.158) directly includes <code>pgtable-nop4d.h</code>.</p> <p>To summarize, with 4-level paging there are no \"real\" p4d tables. Instead, pgd entries contain the addresses of pud tables, and the kernel \"pretends\" the p4d exists by making it appear that the p4d is a mirror copy of the pgd.</p> <p>If you read on in <code>arch/x86/include/asm/pgtable_types.h</code> you'll see that the kernel uses the same scheme for 3 and 2 level page table configurations as well. arm64 follows a similar scheme in <code>arch/arm64/include/asm/pgtable-types.h</code></p> <p>NOTE that you cannot make use of this equivalence directly. Your Farfetch'd implementation must work correctly for any page table configuration and therefore must use the macros defined by the kernel.</p>"},{"location":"resources/recitations/F-Farfetchd/#data-structures-functions-and-macros","title":"Data structures, functions, and macros","text":"<p>In this section we'll take a step back and discuss the data structures and functions the kernel uses to manage page tables in more detail.</p> <p>To encapsulate memory management information for each task, <code>struct task_struct</code> contains a <code>struct mm_struct*</code>.</p> <pre><code>struct mm_struct                *mm;\nstruct mm_struct                *active_mm;\n</code></pre> <p>We won't go into the details of <code>active_mm</code>, which is used for kernel threads that do not have their own <code>struct_mm</code>. Check out <code>context_switch()</code> in core.c if you want to read more.</p> <p>Looking in <code>struct mm_struct</code>, we find the member <code>pgd_t *pgd;</code>. This is a pointer to the first entry in the pgd for this <code>mm_struct</code>. Do you think that this is a virtual address or a physical address? Remember that all memory references are translated from virtual addresses to physical addresses by the CPU, so any address the kernel code uses directly must be a virtual address.</p> <p>However, it's easy to recover the physical address since all kernel addresses are linearly mapped to physical addresses. <code>virt_to_phys</code> recovers the physical address using this linear mapping.</p> <p>Section 3.3 in Gordman's chapter on page table management provides a good overview of the functions / macros used to navigate the page table.</p> <p>A common source of confusion arises from a misunderstanding of what macros like <code>pud_offset</code> return. </p> <pre><code>/* Find an entry in the third-level page table.. */\n// From include/linux/pgtable.h. Note that this definition is shared between x86 and arm64.\nstatic inline pud_t *pud_offset(p4d_t *p4d, unsigned long address)\n{\n    return (pud_t *)p4d_page_vaddr(*p4d) + pud_index(address);\n}\n\n// x86: arch/x86/include/asm/pgtable_types.h\n// arm64: arch/arm64/include/asm/pgtable-types.h\ntypedef struct { pudval_t pud; } pud_t;\n\n// x86: arch/x86/include/asm/pgtable_64_types.h\ntypedef unsigned long   pudval_t;\n\n// arm64: arch/arm64/include/asm/pgtable-types.h\ntypedef u64 pudval_t;\n</code></pre> <p>We touched on this briefly above. A <code>pud_t</code> is just a struct containing an unsigned long, which means it compiles down to an unsigned long. Recall from our earlier discussion that each entry is the address of a physical page frame and that the last 12 bits are reserved for flags since each page frame is page aligned. The macros that Gordman discusses, like <code>pte_none()</code> and <code>pmd_present()</code>, check these flag bits to determine information about the entry.</p> <p>If you want to recover the actual value of the entry, the type casting macros Gordman discussed in section 3.2 are useful. Although the Gordman reading is x86-specific, arm64 defines similar, if not indentical, macros. Keep in mind that if you want the physical address the entry points to you'll need to bitwise-and the value with the correct mask.</p> <p>x86 and arm64 either define functions/macros for the mask so you can manually perform the bitwise-and or define function/macros that outright do the correct bitwise-and for you. Either way, recovering the physical address the entry points to is possible in both x86 and arm64, it just may look slightly different depending which architecture you're on and which function/macros you choose.</p>"},{"location":"resources/recitations/F-Farfetchd/#page-dirty-and-refcount","title":"Page dirty and refcount","text":"<p>Recall from before that a flag in the page table entry indicates whether the page frame is dirty or not. Do not read the flag directly; the kernel provides a macro for this purpose.</p> <p>You will find section 3.4 of Gordman useful for figuring out how to retrieve the refcount of a page frame. Hint: every physical frame has a <code>struct page</code> in the kernel, which is defined here. Be sure to use the correct kernel functions / macros to access any information in <code>struct page</code>.</p>"}]}