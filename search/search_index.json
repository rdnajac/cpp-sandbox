{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++ sandbox","text":"<p>A collection of C++ code snippets and examples.</p>"},{"location":"#build","title":"Build","text":"<p>CMake</p> <pre><code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j$(nproc)\n</code></pre>"},{"location":"#test","title":"Test","text":"<p>Catch2</p>"},{"location":"#docs","title":"Docs","text":"<p>MkDocs</p> <pre><code>pip install -r requirements.txt\nmkdocs serve\n# open http:localhost:8000\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>There are some cool guides included them as a submodules in this repo so they can be easily accessed and updated. The search plugin that comes with Material for MkDocs theme can be used to search through all the resources, even if they're excluded from the navbar.</p> <ul> <li>C++ Reference</li> <li>Modern C++ Features</li> <li>Jae's class</li> <li>GeeksforGeeks</li> </ul>"},{"location":"#projects","title":"Projects","text":"<ul> <li>TCP client/server</li> </ul>"},{"location":"a-tour-of-cpp/","title":"A Tour of C++","text":"<p>During my time at Columbia University, I had the privilege of taking Bjarne Stroustrup's course, \"Design using C++\". Now that I have graduated, I've decided to compile all of my notes into a comprehensive guide. This document serves as an easy reference to accompany the repository of code snippets and examples I have been developing.</p>"},{"location":"a-tour-of-cpp/#attribution","title":"Attribution","text":"<p>The material in this document is based on concepts and information from: Stroustrup, B. (2022). A Tour of C++ (C++ In-Depth Series) (3rd ed.). Addison-Wesley Professional.</p>"},{"location":"a-tour-of-cpp/#table-of-contents","title":"Table of Contents","text":"<ol> <li>The Basics</li> <li>User-Defined Types</li> <li>Modularity</li> <li>Error Handling</li> <li>Classes</li> <li>Essential Operations</li> <li>Templates</li> <li>Concepts and Generic Programming</li> <li>Standard-Library</li> <li>Strings and Regular Expressions</li> <li>Input and Output</li> <li>Containers</li> <li>Algorithms</li> <li>Ranges</li> <li>Pointers and Containers</li> <li>Utilities</li> <li>Numerics</li> <li>Concurrency</li> </ol>"},{"location":"a-tour-of-cpp/#the-basics","title":"The Basics","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std; // Make names from std visible without std::\n\nvector&lt;int&gt; v = {0, 1, 2, 3, 4, 5}; // Define a vector of integers\n\n// C++11 gives us the 'auto' keyword for type deduction and\nauto i = 7;    // 'i' is an int\nauto d = 1.2;  // 'd' is a double\nauto qq{true}; // 'qq' is a bool (note the `{}` initialization)\n\n// Use const to define constants instead of `#define`s\nconst double pi = 3.14159; // Define a constant value\n// TODO: this is incorrect...\n// constexpr double area(double radius) { return pi * radius * radius; }\n\n#if __cplusplus &gt;= 201703L /* C++17 */\n#include &lt;any&gt;\n#include &lt;optional&gt;\n#include &lt;variant&gt;\nstd::variant&lt;int, float&gt; var = 42; // can hold either int or float\nstd::optional&lt;int&gt; o = 17;         // can hold an int or nothing (`std::nullopt`)\nstd::any a = 3.14;                 // can hold any type (similar to `void*`)\n#endif\n\n#if __cplusplus &gt;= 202002L /* C++20 */\n#include &lt;span&gt;\nstd::span&lt;int&gt; sp(v); // Non-owning reference to a contiguous sequence of ints\n#endif\n\nint main() {\n    // C++11 also gives us range-based for loops\n    for (auto x : v) cout &lt;&lt; x &lt;&lt; \" \";\n\n#if __cplusplus &gt;= 201402L /* C++14 */\n    for (auto radius : v) { // C++14 generic lambda expressions\n        cout &lt;&lt; \"radius: \" &lt;&lt; radius &lt;&lt; \", area: \" \n            &lt;&lt; [radius] () { return pi * radius * radius; }() &lt;&lt; endl;\n    }\n#endif\n\n#if __cplusplus &gt;= 202002L /* C++20 */\n    cout &lt;&lt; \"Span: \";\n    for (auto x : sp) cout &lt;&lt; x &lt;&lt; \" \";\n#endif\n    return 0;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#accessing-elements-in-a-vector-within-a-loop","title":"Accessing elements in a vector within a loop","text":"Syntax Description <code>for (auto element : vector)</code> Creates a copy of each element in the vector <code>for (auto &amp;element : vector)</code> Allows you to modify the elements <code>for (const auto &amp;element : vector)</code> Efficient way to iterate over a vector <p>Note</p> <p>The <code>&amp;</code> in a variable declaration means that the variable is a reference to the object, not a copy of the object itself. The <code>const</code> qualifier ensures that the elements are not modified.</p>"},{"location":"a-tour-of-cpp/#using-iterators-to-access-elements-in-a-vector","title":"Using iterators to access elements in a vector","text":"<pre><code>for (auto it = vector.begin(); it != vector.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; endl;  // Dereference the iterator to get the value\n}\n</code></pre> <p>The <code>end()</code> function returns an iterator pointing to the element following the last element of the vector, not the last element itself. It is like the memory address one past the end of the vector and should not be dereferenced.</p> <p>Jump ahead to Iterators for more information.</p>"},{"location":"a-tour-of-cpp/#character-conversion","title":"Character conversion","text":"<pre><code>char ch = 'a';      // the ASCII value of 'a' is 97\nint i = ch;         // i becomes 97\n\nchar c = '1';       // the ASCII value of '1' is 49\nint i = c - '0';    // i becomes 1\n\nint j = 1;          // what does the char value 1 look like?\nchar c = j + '0';   // c becomes '1'\n</code></pre> <p>Tip</p> <p>You can always check <code>man ascii</code> to view the ASCII table.</p>"},{"location":"a-tour-of-cpp/#user-defined-types","title":"User-Defined Types","text":"<ul> <li>Use <code>class</code> to hide representation and provide an interface.</li> <li>Use <code>struct</code> to group related data without hiding.</li> <li>Prefer <code>enum class</code> over plain enums.</li> <li>Consider <code>std::variant</code> as a type-safe alternative to unions.</li> <li>Use user-defined literals for expressive value specification.</li> </ul>"},{"location":"a-tour-of-cpp/#struct","title":"<code>struct</code>","text":"<p>Structures group related data elements:</p> <pre><code>struct DNASequence {\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    std::string source;\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#class","title":"<code>class</code>","text":"<p>Classes extend structures by adding member functions:</p> <pre><code>class DNA {\npublic:\n    DNA(std::vector&lt;Nucleotide&gt; seq) : sequence{std::move(seq)} {}\n    void addNucleotide(Nucleotide n) { sequence.push_back(n); }\n    size_t length() const { return sequence.size(); }\nprivate:\n    std::vector&lt;Nucleotide&gt; sequence;\n};\n</code></pre> <p>Usage:</p> <pre><code>DNA dna({Nucleotide::A, Nucleotide::T, Nucleotide::G});\ndna.addNucleotide(Nucleotide::C);\nstd::cout &lt;&lt; \"DNA length: \" &lt;&lt; dna.length() &lt;&lt; '\\n';\n</code></pre> <p>Jump ahead to Classes for more information.</p>"},{"location":"a-tour-of-cpp/#enum","title":"<code>enum</code>","text":"<p>Use strongly typed enumerations:</p> <pre><code>enum class Nucleotide {\n    A, // Adenine\n    T, // Thymine\n    G, // Guanine\n    C  // Cytosine\n};\n\nNucleotide base = Nucleotide::A;\n</code></pre>"},{"location":"a-tour-of-cpp/#union","title":"<code>union</code>","text":"<p>Modern C++ prefers <code>std::variant</code> over unions.</p> <pre><code>#include &lt;variant&gt;\n\nstd::variant&lt;DNA, std::string&gt; genetic_info;\ngenetic_info = DNA({Nucleotide::A, Nucleotide::T});\ngenetic_info = \"ATGC\";  // Now contains a string\n</code></pre>"},{"location":"a-tour-of-cpp/#user-defined-literals","title":"User-Defined Literals","text":"<p>Define custom literals:</p> <pre><code>DNA operator\"\"_dna(const char* seq, size_t len)\n{\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    for (size_t i = 0; i &lt; len; ++i) {\n        switch(seq[i]) {\n            case 'A': nucleotides.push_back(Nucleotide::A); break;\n            case 'T': nucleotides.push_back(Nucleotide::T); break;\n            case 'G': nucleotides.push_back(Nucleotide::G); break;\n            case 'C': nucleotides.push_back(Nucleotide::C); break;\n            default: throw std::invalid_argument(\"Invalid nucleotide\");\n        }\n    }\n    return DNA(nucleotides);\n}\n\nauto my_dna = \"ATGC\"_dna;\n</code></pre>"},{"location":"a-tour-of-cpp/#type-aliases","title":"Type Aliases","text":"<p>Use 'using' for type aliases: <code>using DNAStrand = std::vector&lt;Nucleotide&gt;;</code></p> <p>I don't like using these in C because they obscure the type of the variable.</p>"},{"location":"a-tour-of-cpp/#modularity","title":"Modularity","text":"<p>Declarations (interfaces, .h, .hpp) and definitions (implementations, .c, .cpp) should be separate. Where modules are supported (C++20), use them!</p> <p>Tip</p> <p>Header files should emphasize logical structure.</p>"},{"location":"a-tour-of-cpp/#namespaces","title":"Namespaces","text":"<p>Namespaces help prevent name collisions and organize code:</p> <pre><code>namespace genetics {\n    class DNA { /* ... */ };\n    class RNA { /* ... */ };\n}\n\n// Use with qualification\ngenetics::DNA myDNA;\n\n// Or bring specific names into scope\nusing genetics::RNA;\nRNA myRNA;\n\n// Avoid bringing entire namespaces into global scope\n// using namespace genetics; // Not recommended\n</code></pre> <p>Use namespaces to group related functionality and avoid polluting the global namespace.</p>"},{"location":"a-tour-of-cpp/#modules","title":"Modules","text":"<p>Modules (C++20) offer better encapsulation and faster compilation than header files:</p> <ul> <li>Faster compilation (parsed once, not per translation unit)</li> <li>No need for include guards</li> <li>Better control over what's exported</li> <li>Fewer macro-related issues</li> </ul> <pre><code>// genetics.ixx\nexport module genetics;\n\nexport class DNA { /* ... */ };\nexport class RNA { /* ... */ };\n\n// Not exported, internal to module\nclass Ribosome { /* ... */ };\n</code></pre> <p>Usage:</p> <pre><code>import genetics;\ngenetics::DNA myDNA;\n</code></pre>"},{"location":"a-tour-of-cpp/#make-your-own-module-std","title":"Make Your Own <code>module std</code>","text":"<p>If an implementation does not currently support modules or lacks a standard module equivalent, we can revert to using traditional headers, which are widely available and standardized. The challenge lies in identifying the necessary headers to include.</p> <p>Caution</p> <p>Modules deliberately don\u2019t export macros. If you need macros, use <code>#include</code> instead.</p>"},{"location":"a-tour-of-cpp/#stdh-header","title":"<code>std.h</code> Header","text":"<p>We can cram all the headers we want into a single header file, <code>std.h</code>, then include it in our source files, but <code>#include</code>ing so much can give very slow compiles [Stroustrup,2021b].</p>"},{"location":"a-tour-of-cpp/#std-module","title":"<code>std</code> \"Module\"","text":"<p>It includes all necessary headers in the global module fragment (before <code>export module std;</code>), then exports specific entities from the standard library.</p> <pre><code>module;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n// ...\n\nexport module std;\nexport iostream;\nexport string;\nexport vector;\n// ...\n</code></pre>"},{"location":"a-tour-of-cpp/#import-a-header-unit","title":"Import a header unit","text":"<pre><code>export module std;\n\nexport import \"iostream\";\nexport import \"string\";\nexport import \"vector\";\n// ...\n</code></pre> <p>Warning</p> <p>This approach has several drawbacks:</p> <ul> <li>It treats each header as a separate module-like entity.</li> <li>It can inject names into the global namespace.</li> <li>It may leak macros, which regular modules don't do.</li> </ul> <p>But it's still pretty cool.</p>"},{"location":"a-tour-of-cpp/#actually-defining-the-module","title":"Actually defining the module","text":"<p>File: <code>std.cppm</code> (or <code>std.ixx</code>)</p> <p>Command:</p> <pre><code>clang++ -std=c++20 -fmodules-ts -c std.cppm\n</code></pre> <p>Error:</p> <pre><code>std.cppm:8:19: error: using declaration referring to 'cout' with module linkage cannot be exported\n</code></pre> <p>Warning</p> <p>It looks like we can't export <code>using</code> declarations on Apple clang version 15.0.0 (clang-1500.3.9.4)</p>"},{"location":"a-tour-of-cpp/#error-handling","title":"Error Handling","text":""},{"location":"a-tour-of-cpp/#exceptions","title":"Exceptions","text":"<p>You can throw custon exceptions after defining a class derived from std::exception. For example:</p> <pre><code>class BadLengthException : public std::exception {\nprivate:\n    int length;\n    std::string message;\n\npublic:\n    BadLengthException(int len) : length(len) {\n        message = std::to_string(length);\n    }\n\n    const char* what() const noexcept override {\n        return message.c_str();\n    }\n};\n</code></pre> <ul> <li>invariants</li> <li>error-handling alternatives</li> <li>assertions</li> </ul>"},{"location":"a-tour-of-cpp/#classes","title":"Classes","text":""},{"location":"a-tour-of-cpp/#concrete-types","title":"Concrete Types","text":"<p>They behave \"just like built-in types.\"!</p>"},{"location":"a-tour-of-cpp/#classical-user-defined-arithmetic-type","title":"Classical user-defined arithmetic type","text":"<pre><code>class complex {\n    double re, im; // representation: two doubles\npublic:\n    complex(double r, double i) :re{r}, im{i} {}    // construct complex from two scalars\n    complex(double r) :re{r}, im{0} {}              // construct complex from one scalar\n    complex() :re{0}, im{0} {}                      // default complex: {0,0}\n    complex(complex z) :re{z.re}, im{z.im} {}       // copy constructor\n\n    double real() const { return re; }\n    void real(double d) { re=d; }\n    double imag() const { return im; }\n    void imag(double d) { im=d; }\n\n    complex&amp; operator+=(complex z)\n    {\n        re+=z.re;       // add to re and im\n        im+=z.im;\n        return *this;   // return the result\n    }\n\n    complex&amp; operator-=(complex z)\n    {\n        re-=z.re;\n        im-=z.im;\n        return *this;\n    }\n\n    complex&amp; operator*=(complex); // defined out-of-class somewhere\n    complex&amp; operator/=(complex); // defined out-of-class somewhere\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#abstract-types","title":"Abstract Types","text":"<p>Insulates the user from implementation details by decoupling the interface from the representation.</p> <p>Since we don\u2019t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store and access them through references or pointers.</p> <pre><code>class Container {\npublic:\n    virtual double&amp; operator[](int) = 0;    // pure virtual function\n    virtual int size() const = 0;           // const member function\n    virtual  \u0303Container() {}                 // destructor\n\n    // const member function  // destructor (\u00a75.2.2)\n};\n</code></pre> <p>Note</p> <p>The curious <code>=0</code> syntax says the function is pure virtual; that is, some class derived from Container must define the function.</p>"},{"location":"a-tour-of-cpp/#heirarchies","title":"Heirarchies","text":"<p>Syntax:</p> <pre><code>class Vector_container : public Container {\n    std::vector&lt;double&gt; v;\n    public:\n    double&amp; operator[](int i) override { return v[i]; }\n    int size() const override { return v.size(); }\n};\n</code></pre> <p>Note</p> <p>We use override to indicate that we are overriding a virtual function.</p>"},{"location":"a-tour-of-cpp/#virtual-functions","title":"Virtual Functions","text":"<p>A virtual function is a member function that can be overridden in a derived class. They are used to achieve polymorphism, where a pointer or reference to a base class can refer to objects of its derived classes.</p>"},{"location":"a-tour-of-cpp/#essential-operations","title":"Essential Operations","text":""},{"location":"a-tour-of-cpp/#copy-and-move","title":"Copy and Move","text":"<pre><code>class Vector {\npublic:\n    Vector(const Vector&amp; a);              // copy constructor\n    Vector&amp; operator=(const Vector&amp; a);   // copy assignment\n\n    Vector(Vector&amp;&amp; a);                   // move constructor\n    Vector&amp; operator=(Vector&amp;&amp; a);        // move assignment\n};\n\nVector::Vector(const Vector&amp; a)           // copy constructor\n    :elem{new double[a.sz]},              // allocate space for elements\n     sz{a.sz}\n{\n    for (int i=0; i!=sz; ++i)             // copy elements\n        elem[i] = a.elem[i];\n}\n\nVector::Vector(Vector&amp;&amp; a)                // move constructor\n    :elem{a.elem},                        // \"grab the elements\" from a\n     sz{a.sz}\n{\n    a.elem = nullptr;                     // now a has no elements\n    a.sz = 0;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#resource-management","title":"Resource Management","text":"<pre><code>template&lt;typename T&gt;\nclass Vector {\nprivate:\n    T* elem;   // elem points to an array of sz elements of type T\n    int sz;\npublic:\n    Vector(int s) :elem{new T[s]}, sz{s}  // constructor: acquire resources\n    {\n        for (int i=0; i!=s; ++i)          // initialize elements\n            elem[i] = T{};\n    }\n    ~Vector() { delete[] elem; }          // destructor: release resources\n    // ... copy and move operations ...\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#operator-overloading","title":"Operator Overloading","text":"<pre><code>complex&amp; complex::operator+=(complex z)\n{\n    re+=z.re;    // add to the real part\n    im+=z.im;    // add to the imaginary part\n    return *this;\n}\n\ncomplex operator+(complex a, complex b)\n{\n    return a+=b;\n}\n// and so on...\n</code></pre>"},{"location":"a-tour-of-cpp/#conventional-operations","title":"Conventional Operations","text":"<pre><code>class Vector {\npublic:\n    T&amp; operator[](int i) { return elem[i]; }              // for non-const Vectors\n    const T&amp; operator[](int i) const { return elem[i]; }  // for const Vectors\n    int size() const { return sz; }\n};\n\nbool operator==(const Vector&amp; a, const Vector&amp; b)\n{\n    if (a.size() != b.size()) return false;\n    for (int i=0; i!=a.size(); ++i)\n        if (a[i]!=b[i]) return false;\n    return true;\n}\n\nbool operator!=(const Vector&amp; a, const Vector&amp; b)\n{\n    return !(a==b);\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#templates","title":"Templates","text":"<p><code>&lt;T&gt;</code></p>"},{"location":"a-tour-of-cpp/#parameterized-types","title":"Parameterized Types","text":"<pre><code>template&lt;typename T&gt;\nclass Vector {\nprivate:\n    T* elem;   // elem points to an array of sz elements of type T\n    int sz;\npublic:\n    explicit Vector(int s);\n    ~Vector() { delete[] elem; }\n\n    // ... copy and move operations ...\n\n    T&amp; operator[](int i);\n    const T&amp; operator[](int i) const;\n    int size() const { return sz; }\n};\n\nVector&lt;char&gt; vc(200);          // vector of 200 characters\nVector&lt;string&gt; vs(17);         // vector of 17 strings\nVector&lt;list&lt;int&gt;&gt; vli(45);     // vector of 45 lists of integers\n</code></pre>"},{"location":"a-tour-of-cpp/#parameterized-operations","title":"Parameterized Operations","text":"<pre><code>template&lt;typename Container, typename Value&gt;\nValue sum(const Container&amp; c, Value v)\n{\n    for (auto x : c)\n        v += x;\n    return v;\n}\n\nvoid user(Vector&lt;int&gt;&amp; vi, std::list&lt;double&gt;&amp; ld, std::vector&lt;complex&lt;double&gt;&gt;&amp; vc)\n{\n    int x = sum(vi,0);              // the sum of a vector of ints (add ints)\n    double d = sum(vi,0.0);         // the sum of a vector of ints (add doubles)\n    double dd = sum(ld,0.0);        // the sum of a list of doubles\n    auto z = sum(vc,complex{0.0});  // the sum of a vector of complex&lt;double&gt;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#template-mechanisms","title":"Template Mechanisms","text":"<pre><code>// Variable templates\ntemplate&lt;typename T&gt;\nconstexpr T pi = T{3.1415926535897932385};  // variable template\n\n// Template aliases\ntemplate&lt;typename Value&gt;\nusing String_map = Map&lt;string,Value&gt;;  // Map is some map template\n\nString_map&lt;int&gt; m;  // m is a Map&lt;string,int&gt;\n\n// Variadic templates\ntemplate&lt;typename T, typename... Tail&gt;\nvoid print(T head, Tail... tail)\n{\n    cout &lt;&lt; head &lt;&lt; ' ';\n    if constexpr(sizeof...(tail) &gt; 0)\n        print(tail...);\n}\n\nprint(42, \"hello\", 3.14, \"world\");\n\n// Fold expressions\ntemplate&lt;typename... T&gt;\nint sum(T... v)\n{\n    return (v + ... + 0);  // add all elements of v starting with 0\n}\n\nint x = sum(1, 2, 3, 4, 5);  // x becomes 15\n</code></pre>"},{"location":"a-tour-of-cpp/#lambda-functions","title":"Lambda Functions","text":"<p>A lambda function is an anonymous function that can capture variables from its surrounding scope. It is defined using the following syntax:</p> <pre><code>// template\n[capture](parameters) -&gt; return_type {\n    // function body\n}\n\n// example\n[](const auto&amp; a, const auto&amp; b) {\n    return a.second &lt; b.second;\n}\n</code></pre> <p>Here, the lambda function takes two arguments <code>a</code> and <code>b</code> and returns <code>true</code> if the <code>second</code> member of <code>a</code> is less than the <code>second</code> member of <code>b</code>.</p> Capture Mode Description <code>[]</code> No capture <code>[x]</code> Capture <code>x</code> by value <code>[&amp;x]</code> Capture <code>x</code> by reference <code>[=]</code> Capture all variables by value <code>[&amp;]</code> Capture all variables by reference <code>[=, &amp;x]</code> Capture all variables by value, except <code>x</code> by reference <code>[&amp;, x]</code> Capture all variables by reference, except <code>x</code> by value"},{"location":"a-tour-of-cpp/#concepts-and-generic-programming","title":"Concepts and Generic Programming","text":""},{"location":"a-tour-of-cpp/#concepts","title":"Concepts","text":"<p>Concepts define requirements on template arguments, enabling better error messages and overload resolution.</p> <pre><code>template&lt;typename T&gt;\nconcept Arithmetic = requires(T x, T y) {\n    { x + y } -&gt; std::convertible_to&lt;T&gt;;\n    { x - y } -&gt; std::convertible_to&lt;T&gt;;\n    { x * y } -&gt; std::convertible_to&lt;T&gt;;\n    { x / y } -&gt; std::convertible_to&lt;T&gt;;\n};\n\ntemplate&lt;Arithmetic T&gt;\nT sum(std::vector&lt;T&gt; const&amp; v) {\n    T result = 0;\n    for (auto const&amp; z : v) result += z;\n    return result;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#generic-programming","title":"Generic Programming","text":"<p>Generic programming allows writing algorithms that work with any type satisfying certain requirements.</p> <pre><code>template&lt;typename Iter, typename T&gt;\nIter find(Iter first, Iter last, const T&amp; value) {\n    while (first != last &amp;&amp; *first != value) ++first;\n    return first;\n}\n\nstd::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\nauto it = find(v.begin(), v.end(), 3);\n</code></pre>"},{"location":"a-tour-of-cpp/#variadic-templates","title":"Variadic Templates","text":"<p>Variadic templates allow functions and classes to accept any number of arguments of any type.</p> <pre><code>template&lt;typename T&gt;\nvoid print(T arg) {\n    std::cout &lt;&lt; arg &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename T, typename... Args&gt;\nvoid print(T first, Args... rest) {\n    std::cout &lt;&lt; first &lt;&lt; ' ';\n    print(rest...);\n}\n\nprint(1, \"hello\", 3.14);\n</code></pre>"},{"location":"a-tour-of-cpp/#template-compilation-model","title":"Template Compilation Model","text":"<p>Templates are compiled when instantiated, which happens in the translation unit where they are used, requiring template definitions to be available in headers.</p> <pre><code>// mylibrary.h\ntemplate&lt;typename T&gt;\nT square(T x) { return x * x; }\n\n// main.cpp\n#include \"mylibrary.h\"\nint main() {\n    auto result = square(5);\n}\n</code></pre> <p>Warning</p> <p>You cannot define a template in a .cpp file and then use it in another .cpp file. The definition must be available at the point of instantiation. A workaround is to explicitly instantiate the template for the types you need.</p>"},{"location":"a-tour-of-cpp/#standard-library","title":"Standard Library","text":"<p>Provides the most common fundamental data structures together with the fundamental algorithms used on them.</p>"},{"location":"a-tour-of-cpp/#strings-and-regular-expressions","title":"Strings and Regular Expressions","text":"<p>C++ has its own string type, <code>std::string</code>, which is a part of the standard library and is not the same as a <code>char*</code> we see in C.</p>"},{"location":"a-tour-of-cpp/#strings","title":"Strings","text":""},{"location":"a-tour-of-cpp/#initialization-and-basic-operations","title":"Initialization and Basic Operations","text":"<pre><code>string s = \"hello\";\nsize_t len = s.length();\nchar first = s[0];\ns += \" world\";  // concatenation, s = \"hello world\"\n\n// get a substring\nstring sub = s.substr(1, 5);  // sub = \"ello\"\n</code></pre>"},{"location":"a-tour-of-cpp/#conversions","title":"Conversions","text":"<pre><code>// use functions from &lt;string&gt;\nint num = stoi(\"123\");\nstring str = to_string(123);\n</code></pre> <p>Tip</p> <p>These functions throw exceptions if the conversion fails.</p>"},{"location":"a-tour-of-cpp/#splitting-strings","title":"Splitting strings","text":"<p>Use <code>std: istringstream</code> to split a whitespace-separated string into tokens:</p> <pre><code>string s = \"Hello, world!\";\nistringstream iss(s);\nstring token;\nwhile (iss &gt;&gt; token) {\n    cout &lt;&lt; token &lt;&lt; endl;\n}\n</code></pre> <p>Use <code>std::getline()</code> to split a string by another delimiter:</p> <pre><code>string time = \"12:34:56\";\nint seconds = 10;\nstringstream ss(time);\nstring item;\nvector&lt;int&gt; time_parts;\n\nwhile (getline(ss, item, ':')) {\n    time_parts.push_back(stoi(item));\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#more-string-manipulations","title":"More string manipulations","text":""},{"location":"a-tour-of-cpp/#formatting-output","title":"Formatting output","text":"<p>Use an output string stream to concatenate strings.</p> <pre><code>ostringstream oss;\nos &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; hours &lt;&lt; \":\" &lt;&lt; setw(2) &lt;&lt;\nminutes &lt;&lt; \":\" &lt;&lt; setw(2) &lt;&lt; seconds;\nstring result = os.str();\n</code></pre> <p>Note</p> <p>The <code>setfill()</code> and <code>setw()</code> manipulators from the <code>&lt;iomanip&gt;</code> header are used to set the fill character and the width of the output field.</p>"},{"location":"a-tour-of-cpp/#trimming-whitespace","title":"Trimming whitespace","text":"<p>Use the <code>std::string::find_first_not_of()</code> and <code>std::string::find_last_not_of()</code> functions to trim leading/trailing whitespace.</p> <pre><code>// Trim any leading or trailing spaces\nt1.erase(0, t1.find_first_not_of(' '));\nt1.erase(t1.find_last_not_of(' ') + 1);\n</code></pre>"},{"location":"a-tour-of-cpp/#find-and-replace","title":"Find and Replace","text":"<pre><code>std::string replace_substring(const std::string&amp; text, const std::string&amp; old, const std::string&amp; newSubstr) {\n    string result = text;\n    size_t pos = 0;\n\n    while ((pos = result.find(old, pos)) != std::string::npos) {\n        result.replace(pos, old.length(), newSubstr);\n        pos += newSubstr.length(); // Move past the new substring\n    }\n    return result;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#reverse-a-string","title":"Reverse a string","text":"<pre><code>// reverse a string in place using two pointers\nfor (auto i = 0; i &lt; s.size() / 2; i++) {\n    swap(s[i], s[n - i - 1]);\n}\n\n// or use the reverse function\nreverse(s.begin(), s.end());\n\n// or use the reverse iterator with the constructor\nstring reversed(s.rbegin(), s.rend());\n</code></pre>"},{"location":"a-tour-of-cpp/#stdstring_view","title":"<code>std::string_view</code>","text":""},{"location":"a-tour-of-cpp/#regular-expressions-in-c","title":"Regular Expressions in C++","text":""},{"location":"a-tour-of-cpp/#input-and-output","title":"Input and Output","text":"<ul> <li>state</li> <li>user-defined types</li> <li>formatting</li> <li>streams</li> <li>c-style</li> <li>file system</li> </ul>"},{"location":"a-tour-of-cpp/#containers","title":"Containers","text":""},{"location":"a-tour-of-cpp/#vectors","title":"Vectors","text":"<pre><code>// reverse a vector\nreverse(vec.begin(), vec.end());\n\n// copy with simple assignment\nvector&lt;int&gt; vec_copy = vec;\n\n// append a vector to another vector\nvec1.insert(vec1.end(), vec2.begin(), vec2.end());\n\n// sort a vector\nsort(vec.begin(), vec.end());\n\n// sort a vector of pairs by the first element\nsort(vec.begin(), vec.end(), [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) {\n    return a.first &lt; b.first;\n});\n\n// Custom comparator\nsort(vec.begin(), vec.end(), [](int a, int b) { return a &gt; b; });\n\n// binary search\nbool found = binary_search(vec.begin(), vec.end(), target);\nauto it = lower_bound(vec.begin(), vec.end(), target);\n</code></pre>"},{"location":"a-tour-of-cpp/#find","title":"find","text":"<pre><code>void find_example() {\n  std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n  // parameters:\n  // 1. begin iterator\n  // 2. end iterator\n  // 3. value to find\n  auto it = std::find(v.begin(), v.end(), 3);\n  if (it != v.end()) {\n    std::cout &lt;&lt; \"Found: \" &lt;&lt; *it &lt;&lt; std::endl;\n  } else {\n    std::cout &lt;&lt; \"Not found\" &lt;&lt; std::endl;\n  }\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#find-and-insert-after","title":"find and insert after","text":"<p>Use <code>std::find</code> to find a value in a vector:</p> <pre><code>auto it = std::find(v.begin(), v.end(), 5);\nif (it != v.end()) {\n    v.insert(it + 1, 6);\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#maps-and-sets","title":"Maps and Sets","text":"<pre><code>unordered_map&lt;int, int&gt; map;\nmap[key] = value;\nif (map.count(key)) { /* key exists */ }\n\nunordered_set&lt;int&gt; set;\nset.insert(value);\nif (set.count(value)) { /* value exists */ }\n</code></pre>"},{"location":"a-tour-of-cpp/#queue","title":"Queue","text":"<pre><code>queue&lt;int&gt; q;\nq.push(1);\nint front = q.front();\nq.pop();\n</code></pre>"},{"location":"a-tour-of-cpp/#stack","title":"Stack","text":"<pre><code>stack&lt;int&gt; s;\ns.push(1);\nint top = s.top();\ns.pop();\n</code></pre>"},{"location":"a-tour-of-cpp/#priority-queue-heap","title":"Priority Queue (Heap)","text":"<pre><code>// Max heap\npriority_queue&lt;int&gt; maxHeap;\n\n// Min heap\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n\nmaxHeap.push(1);\nint top = maxHeap.top();\nmaxHeap.pop();\n</code></pre> <ul> <li><code>list</code></li> <li><code>forward_list</code></li> <li><code>map</code></li> <li><code>unordered_map</code></li> <li>allocators</li> </ul>"},{"location":"a-tour-of-cpp/#algorithms","title":"Algorithms","text":"<p>In addition to the containers themselves, the standard library provides a set of algorithms that operate on them (like printing, searching, sorting, extracting, subsets, etc.). These algorithms are designed to be efficient and correct for all standard containers.</p>"},{"location":"a-tour-of-cpp/#iterators","title":"Iterators","text":"<p>Iterators are objects that provide sequential access to container elements without exposing the underlying structure. Essential for efficient manipulation of data in C++ Standard Library containers.</p> <ol> <li>Input Iterators: Read-only access.</li> <li>Output Iterators: Write-only access.</li> <li>Forward Iterators: Read and write, single-pass.</li> <li>Bidirectional Iterators: Move both forward and backward.</li> <li>Random-Access Iterators: Move to any element in constant time.</li> </ol>"},{"location":"a-tour-of-cpp/#using-iterators-with-stdvector","title":"Using Iterators with std::vector","text":"<ul> <li>Traversal: Use <code>begin()</code> to get an iterator to the first element and <code>end()</code> for the past-the-last element.</li> <li>Incrementing and Dereferencing:</li> <li><code>++it</code>: Move to the next element.</li> <li><code>*it</code>: Access the value at the current iterator position.</li> </ul> <pre><code>std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\nfor (auto it = numbers.begin(); it != numbers.end(); ++it) {\n    std::cout &lt;&lt; *it &lt;&lt; \" \"; // Output: 1 2 3 4 5\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#modifying-elements-with-iterators","title":"Modifying Elements with Iterators","text":"<p>Modify vector elements directly via iterators:</p> <pre><code>for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n    *it *= 2; // Doubles each element\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#reverse-iterators","title":"Reverse Iterators","text":"<p>Use <code>rbegin()</code> and <code>rend()</code> to traverse in reverse:</p> <pre><code>for (auto rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {\n    std::cout &lt;&lt; *rit &lt;&lt; \" \"; // Output: 5 4 3 2 1\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#stl-algorithms","title":"STL Algorithms","text":"<p>STL algorithms are a collection of functions provided by the Standard Template Library (STL) in C++. They perform common operations on sequences of data, saving time and effort by leveraging well-tested and optimized operations for tasks like searching, sorting, and transforming data.</p> <p>Commonly used STL algorithms include:</p> <ul> <li><code>std::for_each</code>: Applies a function to a range of elements.</li> <li><code>std::sort</code>: Sorts a range of elements.</li> <li><code>std::find</code>: Searches for a value in a range of elements.</li> <li><code>std::transform</code>: Applies a function to each element in a range and stores the   result in another range.</li> <li><code>std::accumulate</code>: Computes the sum of a range of elements.</li> </ul>"},{"location":"a-tour-of-cpp/#stdfor_each","title":"<code>std::for_each</code>","text":"<pre><code>std::for_each(InputIterator first, InputIterator last, Function fn);\n</code></pre> <ul> <li><code>InputIterator first</code>: An iterator pointing to the start of the range.</li> <li><code>InputIterator last</code>: An iterator pointing to one past the end of the range.</li> <li><code>Function fn</code>: A function or function object (often a lambda) to apply to the elements in the range.</li> </ul> <p>Important</p> <p>Lambda functions are a concise way to define small functions inline. The syntax is <code>[] (parameters) { body }</code>. where the <code>[]</code> captures variables from the enclosing scope and parameters are passed to the lambda.</p>"},{"location":"a-tour-of-cpp/#stdsort","title":"<code>std::sort</code>","text":"<pre><code>std::sort(RandomAccessIterator first, RandomAccessIterator last);\n</code></pre> <ul> <li><code>RandomAccessIterator first</code>: An iterator pointing to the start of the range.</li> <li><code>RandomAccessIterator last</code>: An iterator pointing to one past the end of the   range.</li> </ul>"},{"location":"a-tour-of-cpp/#stdfind","title":"<code>std::find</code>","text":"<pre><code>std::find(InputIterator first, InputIterator last, const T&amp; value);\n</code></pre> <ul> <li><code>InputIterator first</code>: An iterator pointing to the start of the range.</li> <li><code>InputIterator last</code>: An iterator pointing to one past the end of the range.</li> <li><code>const T&amp; value</code>: The value to search for in the range.</li> </ul> <p>In practice:</p> <pre><code>if (library_catalog.find(book_id) != library_catalog.end()) {\n    std::cout &lt;&lt; \"Book found!\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Book not found!\" &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#stdtransform","title":"<code>std::transform</code>","text":"<pre><code>std::transform(InputIterator1 first1, InputIterator1 last1, InputIterator2\nfirst2, OutputIterator result, BinaryOperation op);\n</code></pre>"},{"location":"a-tour-of-cpp/#stdaccumulate","title":"<code>std::accumulate</code>","text":"<p>The STL also provides <code>std::multplies</code> for multiplication and <code>std::divides</code> for division.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;  // For std::accumulate\n\nint main() {\n    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};\n\n    int sum = std::accumulate(data.begin(), data.end(), 0);\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; '\\n';  // Sum: 15\n\n    int product = std::accumulate(data.begin(), data.end(), 1,\n            std::multiplies&lt;int&gt;());\n    std::cout &lt;&lt; \"Product: \" &lt;&lt; product &lt;&lt; '\\n';  // Product: 120\n\n    // Using std::accumulate with a lambda expression\n    int sum_of_squares = std::accumulate(data.begin(), data.end(), 0, [](int sum, int val) {\n            return sum + val * val;\n            });\n    std::cout &lt;&lt; \"Sum of Squares: \" &lt;&lt; sum_of_squares &lt;&lt; '\\n';  // Sum of Squares: 55\n\n    std::vector&lt;int&gt; data2 = {6, 7, 8, 9, 10};\n\n    // Combining two vectors element-wise and accumulating the result\n    int combined_sum = std::accumulate(data.begin(), data.end(), 0, [&amp;data2, i = 0](int sum, int val) mutable {\n            return sum + val + data2[i++];\n            });\n    std::cout &lt;&lt; \"Combined Sum: \" &lt;&lt; combined_sum &lt;&lt; '\\n';  // Combined Sum: 55\n\n    // append data2 to data\n    data.insert(data.end(), data2.begin(), data2.end());\n\n    // Use std::accumulate with a lambda expression to sum even numbers\n    int sum_of_evens = std::accumulate(data.begin(), data.end(), 0, [](int sum, int val) {\n        return sum + ((val % 2 == 0) ? val : 0);\n    });\n\n    int weighted_sum = std::accumulate(data.begin(), data.end(), 0, [&amp;weights, i = 0](int sum, int val) mutable {\n            return sum + val * weights[i++];\n            });\n\n    return 0;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#ranges","title":"Ranges","text":"<ul> <li>views</li> <li>generators</li> <li>pipelines</li> <li>concepts overview</li> </ul>"},{"location":"a-tour-of-cpp/#pointers-and-containers","title":"Pointers and Containers","text":"<ul> <li>pointers</li> <li>containers</li> <li>alternatives</li> </ul>"},{"location":"a-tour-of-cpp/#utilities","title":"Utilities","text":"<ul> <li>time</li> <li>function adaption</li> <li>type functions</li> <li><code>source_location</code></li> <li><code>move()</code> and <code>forward()</code></li> <li>bit manipulation</li> </ul>"},{"location":"a-tour-of-cpp/#numerics","title":"Numerics","text":"<ul> <li>mathematical functions</li> <li>numerical algorithms</li> <li>complex numbers</li> <li>random numbers</li> <li>vector arithmetic</li> <li>numeric limits</li> <li>mathematical constants</li> </ul>"},{"location":"a-tour-of-cpp/#concurrency","title":"Concurrency","text":"<ul> <li>tasks and <code>thread</code>s</li> <li>sharing data</li> <li>waiting for events</li> <li>communicating tasks</li> <li>coroutines</li> </ul>"},{"location":"algorithms/","title":"Algorithms","text":""},{"location":"algorithms/#sorting","title":"Sorting","text":""},{"location":"algorithms/#the-c-standard-librarys-qsort-function","title":"The C standard library's <code>qsort</code> function","text":"<p>The <code>qsort()</code> function is a modified partition-exchange sort, or quicksort.</p> <pre><code>#include &lt;stdlib.h&gt;\n\nvoid\nqsort(void *base, size_t nel, size_t width,\n    int (*compar)(const void *, const void *));\n</code></pre>"},{"location":"algorithms/#compar-function","title":"<code>compar</code> function","text":"<p>The <code>compar</code> function is a user-supplied function that returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.</p> <pre><code>int compar(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n</code></pre> <p>Here, the <code>compar</code> function compares dereferenced pointers-to-integers and returns the difference between the two values. If the difference is negative, the first argument is considered less than the second. If the difference is zero, the two arguments are considered equal.</p> <p>Note</p> <p>The time complexity of quicksort is O(n log n) on average, but O(n^2) in the worst case. The space complexity is O(log n) on average, but O(n) in the worst case.</p>"},{"location":"algorithms/#sorting-in-c","title":"Sorting in C++","text":"<p>The C++ standard library provides a <code>sort()</code> function that is implemented using a hybrid sorting algorithm, which often includes quicksort as one of its components.</p>"},{"location":"algorithms/#manhatan-distance","title":"Manhatan Distance","text":"<p>The Manhattan distance between two arrays, <code>a</code> and <code>b</code>, of size <code>n</code>, is defined by:</p> \\[ D(a, b) = \\sum_{i=0}^{n-1} |a_i - b_i| \\] <p>Note</p> <p>This is equivalent to: $ \\sum_{i=1}^{n} |a_i - b_i| $. The only difference is that the first one is zero-indexed and the second one is one-indexed.</p>"},{"location":"algorithms/#function-signature","title":"Function Signature","text":"<pre><code>// function to return the manhattan distance\nint manhattanDistance(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n    int n = a.size();\n    int distance = 0;\n    for (int i = 0; i &lt; n; i++) {\n        distance += abs(a[i] - b[i]);\n    }\n    return distance;\n}\n</code></pre>"},{"location":"algorithms/#problem","title":"Problem","text":"<p>Given two arrays, each consisting of n non-negative integers, discover a rotation of array1 that minimizes the Manhattan distance with array2.</p> <pre><code>std::pair&lt;std::vector&lt;int&gt;, int&gt; solution(const std::vector&lt;int&gt;&amp; array1, const std::vector&lt;int&gt;&amp; array2) {\n    int n = array1.size();\n    int min_distance = manhattanDistance(array1, array2);\n    std::vector&lt;int&gt; min_array = array1;\n    for (int i = 0; i &lt; n; i++) {\n        std::rotate(array1.begin(), array1.begin() + 1, array1.end());\n        int distance = manhattanDistance(array1, array2);\n        if (distance &lt; min_distance) {\n            min_distance = distance;\n            min_array = array1;\n        }\n    }\n    return std::make_pair(min_array, min_distance);\n}\n</code></pre> <p>Good try, Ryan, but there are some issues with your solution. The use of const for array1 is causing compilation errors because std::rotate modifies the array in place.</p> <p>This solution has a time complexity of \\(O(n^2)\\). It uses <code>std::rotate</code> to rotate the array and <code>manhattanDistance</code> to calculate the distance.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits&gt;\n#include &lt;numeric&gt;\n\nint manhattanDistance(const std::vector&lt;int&gt;&amp; a, const std::vector&lt;int&gt;&amp; b) {\n    return std::inner_product(a.begin(), a.end(), b.begin(), 0,\n                              std::plus&lt;&gt;(), [](int x, int y) { return std::abs(x - y); });\n}\n\nstd::pair&lt;std::vector&lt;int&gt;, int&gt; solution(const std::vector&lt;int&gt;&amp; array1, const std::vector&lt;int&gt;&amp; array2) {\n    int n = array1.size();\n    std::vector&lt;int&gt; rotated = array1;\n    int min_distance = std::numeric_limits&lt;int&gt;::max();\n    int min_rotation = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int distance = manhattanDistance(rotated, array2);\n        if (distance &lt; min_distance) {\n            min_distance = distance;\n            min_rotation = i;\n        }\n        std::rotate(rotated.begin(), rotated.begin() + 1, rotated.end());\n    }\n\n    // Apply the best rotation\n    std::rotate(rotated.begin(), rotated.begin() + min_rotation, rotated.end());\n    return std::make_pair(rotated, min_distance);\n}\n</code></pre>"},{"location":"algorithms/#more-useful-algorithms","title":"More Useful Algorithms","text":""},{"location":"algorithms/#two-pointers","title":"Two Pointers","text":"<pre><code>int left = 0, right = n - 1;\nwhile (left &lt; right) {\n    // Process elements\n    left++;\n    right--;\n}\n</code></pre>"},{"location":"algorithms/#sliding-window","title":"Sliding Window","text":"<pre><code>int left = 0, right = 0;\nwhile (right &lt; n) {\n    // Expand window\n    // Process window\n    while (condition) {\n        // Shrink window\n        left++;\n    }\n    right++;\n}\n</code></pre>"},{"location":"algorithms/#tree-traversal","title":"Tree Traversal","text":"<pre><code>struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\n// DFS Traversal\nvoid dfs(TreeNode* root) {\n    if (root == nullptr) return;\n    // Process root-&gt;val\n    dfs(root-&gt;left);\n    dfs(root-&gt;right);\n}\n</code></pre>"},{"location":"algorithms/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<pre><code>void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int node, vector&lt;bool&gt;&amp; visited) {\n    if (visited[node]) return;\n    visited[node] = true;\n    // Process node\n    for (int neighbor : graph[node]) {\n        dfs(graph, neighbor, visited);\n    }\n}\n</code></pre>"},{"location":"algorithms/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<pre><code>void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) {\n    queue&lt;int&gt; q;\n    vector&lt;bool&gt; visited(graph.size(), false);\n    q.push(start);\n    visited[start] = true;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        // Process node\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                q.push(neighbor);\n                visited[neighbor] = true;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"containers/","title":"STL Containers","text":"<ul> <li>Vector</li> <li>List</li> <li>Deque</li> <li>Stack</li> <li>Queue</li> <li>Priority Queue</li> <li>Set</li> <li>Map</li> <li>Unordered Map</li> </ul>"},{"location":"containers/#check-if-a-key-is-in-an-unordered_map","title":"Check if a key is in an <code>unordered_map</code>","text":"<pre><code>// Using find() to access a book's title\nauto it = library_catalog.find(\"book1\");\nif (it != library_catalog.end())\n    std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl; // Output: \"A Tale of Two Cities\"\nelse\n    std::cout &lt;&lt; \"Key not found\" &lt;&lt; std::endl;\n\n// Using find() to access a nonexistent key\nauto it_nonexistent = library_catalog.find(\"book100\");\nif (it_nonexistent != library_catalog.end())\n    std::cout &lt;&lt; it_nonexistent-&gt;second &lt;&lt; std::endl;\nelse\n    std::cout &lt;&lt; \"Key not found\" &lt;&lt; std::endl; // Output: \"Key not found\"\n</code></pre>"},{"location":"math/","title":"Math in C++","text":""},{"location":"math/#theyre-just-for-loops","title":"They're just for loops","text":""},{"location":"math/#summation","title":"Summation","text":"\\[ \\sum\\_{i=0}^{N} 2x_i \\] <pre><code>for (int i = 0; i &lt; N; i++) {\n    sum += 2 * x[i];\n}\n</code></pre>"},{"location":"math/#product","title":"Product","text":"\\[ \\prod\\_{i=1}^{N} x_i \\] <pre><code>for (int i = 1; i &lt;= N; i++) {\n    product *= x[i];\n}\n</code></pre>"},{"location":"math/#standard-deviation","title":"Standard Deviation","text":"<p>The formula for standard deviation (\u03c3) is given by:</p> \\[ \\sigma = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\mu)^2} \\] <p>where mu is the mean of the elements, \\(x_i\\) represents each element, and \\(N\\) is the total number of elements.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;double&gt; data = {1.0, 2.0, 3.0, 4.0, 5.0};\n\n    double sum = std::accumulate(data.begin(), data.end(), 0.0);  // make sure we use 0.0 for double\n    double average = sum / data.size();\n    double sq_sum = std::accumulate(data.begin(), data.end(), 0.0, [average](double acc, double x) {\n        double diff = x - average;\n        return acc + diff * diff;\n    });\n    double stdev = std::sqrt(sq_sum / data.size());\n\n    // Standard scaling using for_each\n    std::for_each(data.begin(), data.end(), [average, stdev](double &amp;val) {\n        val = (val - average) / stdev;\n    });\n\n    // Output the scaled vector\n    for (const auto &amp;val : data) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; '\\n'; // Expected output: {-1.41421, -0.707107, 0, 0.707107, 1.41421}\n\n    return 0;\n}\n</code></pre>"},{"location":"math/#weighted-mean","title":"Weighted Mean","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;  // For std::accumulate\n\nint main() {\n    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};\n    std::vector&lt;int&gt; weights = {1, 3, 2, 1, 1};\n\n    int weighted_sum = std::accumulate(data.begin(), data.end(), 0, [&amp;weights, i = 0](int sum, int val) mutable {\n        return sum + val * weights[i++];\n    });\n\n    // Calculate the sum of weights using std::accumulate\n    double sum_of_weights = std::accumulate(weights.begin(), weights.end(), 0.0);\n\n    // Calculate the weighted average be dividing the weighted sum by the total weight\n    double weighted_avg = weighted_sum / sum_of_weights;\n\n    std::cout &lt;&lt; \"Weighted Average: \" &lt;&lt; weighted_avg &lt;&lt; '\\n'; // Expected output: 2.75\n    return 0;\n}\n</code></pre>"},{"location":"pImpl/","title":"Pointer to Implementation (PImpl)","text":"<p>Based on example from Code Signal practice question</p>"},{"location":"pImpl/#problem","title":"Problem","text":"<p>Given this header file:</p> <pre><code>#ifndef INTEGER_CONTAINER_HPP_\n#define INTEGER_CONTAINER_HPP_\n\n\n/**\n * `IntegerContainer` interface.\n */\nstruct IntegerContainer {\n\n  /**\n   * Should add the specified integer `value` to the container\n   * and return the number of integers in the container after the\n   * addition.\n   */\n  virtual int Add(int value) {\n    // Default implementation\n    return 0;\n  }\n\n  /**\n   * Should attempt to remove the specified integer `value` from\n   * the container.\n   * If the `value` is present in the container, remove it and\n   * return `true`, otherwise, return `false`.\n   */\n  virtual bool Delete(int value) {\n    // Default implementation\n    return false;\n  }\n\n  virtual inline ~IntegerContainer() = 0;\n};\nIntegerContainer::~IntegerContainer() = default;\n\n#endif  // INTEGER_CONTAINER_HPP_\n</code></pre>"},{"location":"pImpl/#implementation","title":"Implementation","text":"<pre><code>/* -------------------------- */\n/* integer_container_impl.hpp */\n#ifndef INTEGER_CONTAINER_IMPL_HPP_\n#define INTEGER_CONTAINER_IMPL_HPP_\n\n#include \"integer_container.hpp\"\n#include &lt;memory&gt;\n\nclass IntegerContainerImpl : public IntegerContainer {\npublic:\n    IntegerContainerImpl();\n    ~IntegerContainerImpl() override;\n    IntegerContainerImpl(const IntegerContainerImpl&amp;) = delete;\n    IntegerContainerImpl&amp; operator=(const IntegerContainerImpl&amp;) = delete;\n    IntegerContainerImpl(IntegerContainerImpl&amp;&amp;);\n    IntegerContainerImpl&amp; operator=(IntegerContainerImpl&amp;&amp;);\n\n    int Add(int value) override;\n    bool Delete(int value) override;\n\nprivate:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; pImpl;\n};\n\n#endif // INTEGER_CONTAINER_IMPL_HPP_\n\n/* -------------------------- */\n/* integer_container_impl.cpp */\n#include \"integer_container_impl.hpp\"\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass IntegerContainerImpl::Impl {\npublic:\n    int Add(int value) {\n        container_.push_back(value);\n        return container_.size();\n    }\n\n    bool Delete(int value) {\n        auto it = std::find(container_.begin(), container_.end(), value);\n        if (it != container_.end()) {\n            container_.erase(it);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::vector&lt;int&gt; container_;\n};\n\nIntegerContainerImpl::IntegerContainerImpl() : pImpl(std::make_unique&lt;Impl&gt;()) {}\nIntegerContainerImpl::~IntegerContainerImpl() = default;\nIntegerContainerImpl::IntegerContainerImpl(IntegerContainerImpl&amp;&amp;) = default;\nIntegerContainerImpl&amp; IntegerContainerImpl::operator=(IntegerContainerImpl&amp;&amp;) = default;\n\nint IntegerContainerImpl::Add(int value) {\n    return pImpl-&gt;Add(value);\n}\n\nbool IntegerContainerImpl::Delete(int value) {\n    return pImpl-&gt;Delete(value);\n}\n</code></pre>"},{"location":"pImpl/#alternative-implementation","title":"Alternative Implementation","text":"<p>Just define the functions like this:</p> <pre><code>/* -------------------------- */\n/* integer_container_impl.cpp */\n#include \"integer_container_impl.hpp\"\n\nint IntegerContainerImpl::Add(int value) {\n    container_.push_back(value);\n    return container_.size();\n}\n\nbool IntegerContainerImpl::Delete(int value) {\n    auto it = std::find(container_.begin(), container_.end(), value);\n    if (it != container_.end()) {\n        container_.erase(it);\n        return true;\n    }\n    return false;\n}\n</code></pre>"},{"location":"pImpl/#level-2","title":"Level 2","text":"<p>Add support for calculating the median of the numbers stored in the container.</p> <p><code>std::optional&lt;int&gt; GetMedian()</code> \u2014 should return the median integer - the integer in the middle of the sequence after all integers stored in the container are sorted in ascending order. If the length of the sequence is even, the leftmost integer from the two middle integers should be returned. If the container is empty, this method should return std::nullopt.</p> <pre><code>std::optional&lt;int&gt; IntegerContainerImpl::GetMedian() {\n    if (pImpl-&gt;container_.empty()) {\n        return std::nullopt;\n    }\n\n    std::vector&lt;int&gt; sorted = pImpl-&gt;container_;\n    std::sort(sorted.begin(), sorted.end());\n\n    if (sorted.size() % 2 == 0) {\n        return sorted[sorted.size() / 2 - 1];\n    }\n\n    return sorted[sorted.size() / 2];\n}\n</code></pre>"},{"location":"time-complexity/","title":"Time Complexity","text":"<p>Time complexity is a measure of the amount of time an algorithm takes to complete as a function of the size of the input. It is often expressed using big-O notation, which describes the upper bound of the time taken by an algorithm as a function of the size of the input.</p>"},{"location":"time-complexity/#big-o-notation","title":"Big-O notation","text":"<p>Big-O notation describes the upper bound of the time taken by an algorithm as a function of the size of the input. It is used to describe the worst-case performance of an algorithm. For example, an algorithm with a time complexity of O(n) will take at most n steps to complete, where n is the size of the input.</p> <pre><code>int sum(int n)\n{\n    int total = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        total += i;\n    }\n    return total;\n}\n</code></pre> <p>The <code>sum</code> function has a time complexity of O(n) because it takes at most n steps to complete, where n is the input to the function.</p>"},{"location":"time-complexity/#common-time-complexities","title":"Common time complexities","text":"Notation Name Example O(1) Constant time Accessing an element in an array by index (index arithmetic) O(log n) Logarithmic time Binary search (if the input is sorted) O(n) Linear time Finding the maximum element in an array (one-pass) O(n log n) Linearithmic time Quicksort, mergesort (average case) O(n^2) Quadratic time Bubble sort, selection sort (use of nested loops) O(2^n) Exponential time Recursive Fibonacci calculation O(n!) Factorial time Generating all permutations of a set"},{"location":"time-complexity/#comparing-time-complexities","title":"Comparing time complexities","text":"<p>The following table shows how the time complexity of different algorithms compares as the size of the input grows.</p> Input size O(log n) O(n) O(n log n) O(n^2) O(2^n) O(n!) 10 3 10 30 100 1024 3628800 100 7 100 664 10000 1.27e+30 9.33e+157 1000 10 1000 9965 1000000 1.07e+301 4.02e+2567 <p>You get the idea.</p>"},{"location":"codesignal/2-5_consecutive_character_groups/","title":"Consecutive Character Groups","text":"<pre><code>#include &lt;cctype&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Function to find consecutive character groups in a string\nstd::vector&lt;std::pair&lt;char, int&gt;&gt; solution(std::string s) {\n    std::vector&lt;std::pair&lt;char, int&gt;&gt; groups; // Vector to store the groups of characters\n    char current_group_char = '\\0';           // Variable to hold the current character group\n    int current_group_length = 0; // Variable to hold the length of the current character group\n\n    for (char &amp;c : s) {\n        if (isalnum(c)) {                         // Check if the character is alphanumeric\n            if (c == current_group_char) {        // If the character is part of the current group\n                current_group_length += 1;        // Increment the length of the current group\n            } else {                              // If the character starts a new group\n                if (current_group_char != '\\0') { // Push the previous group to groups if it exists\n                    groups.push_back(std::make_pair(current_group_char, current_group_length));\n                }\n                current_group_char = c;   // Update the current character to the new group\n                current_group_length = 1; // Reset the length for the new group\n            }\n        }\n    }\n    if (current_group_char != '\\0') { // Add the last group if it exists\n        groups.push_back(std::make_pair(current_group_char, current_group_length));\n    }\n\n    return groups; // Return the vector of groups\n}\n</code></pre>"},{"location":"codesignal/3-1_reverse_words/","title":"Reverse Words","text":"<pre><code>#include &lt;algorithm&gt; //for std::reverse\n#include &lt;iostream&gt;  //for std::cout and std::endl\n#include &lt;sstream&gt;   //for std::istringstream and std::ostringstream\n#include &lt;vector&gt;    //for std::vector\n\nstd::string reverseWords(std::string input_str) {\n    std::vector&lt;std::string&gt; words;\n    std::istringstream iss(input_str);\n\n    for (std::string s; iss &gt;&gt; s;)\n        words.push_back(s);\n\n    std::vector&lt;std::string&gt; reversed_words;\n\n    for (auto &amp;word : words) {\n        std::reverse(word.begin(), word.end());\n        reversed_words.push_back(word);\n    }\n\n    std::ostringstream oss;\n    oss &lt;&lt; reversed_words[0]; // add first word\n\n    for (int i = 1; i &lt; reversed_words.size(); i++)\n        oss &lt;&lt; \" \" &lt;&lt; reversed_words[i]; // add the remaining words with space\n\n    return oss.str();\n}\n\nint main() {\n    // Call the function\n    std::cout &lt;&lt; reverseWords(\"Hello neat cpp_lovers_123\")\n              &lt;&lt; std::endl; // prints: 'olleH taen 321_srevol_ppc'\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/3-2_string_parsing/","title":"String Parsing","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint ParseAndMultiplyNumbers(std::string inputString) {\n    std::string num;\n    std::vector&lt;int&gt; numbers;\n    for (char ch : inputString) {\n        if (isdigit(ch)) {\n            num += ch;\n        } else if (!num.empty()) {\n            numbers.push_back(stoi(num));\n            num = \"\";\n        }\n    }\n    if (!num.empty()) {\n        numbers.push_back(stoi(num));\n    }\n\n    int result = 1;\n    for (int number : numbers) {\n        result *= number;\n    }\n    return result;\n}\n\nint main() {\n    // Call the function\n    std::cout &lt;&lt; ParseAndMultiplyNumbers(\"I have 2 apples and 5 oranges\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/3-3_time_calculation/","title":"Time Calculation","text":"<pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nstd::string time_adder(std::string time, int seconds) {\n    std::vector&lt;int&gt; time_parts;\n    std::string item;\n    std::stringstream ss(time);\n    while (std::getline(ss, item, ':')) {\n        time_parts.push_back(std::stoi(item));\n    }\n\n    int seconds_since_start = time_parts[0] * 3600 + time_parts[1] * 60 + time_parts[2];\n    int total_seconds = (seconds_since_start + seconds) % (24 * 3600);\n    int hours = total_seconds / 3600;\n    total_seconds %= 3600;\n    int minutes = total_seconds / 60;\n    seconds = total_seconds % 60;\n\n    std::ostringstream os;\n    os &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; hours &lt;&lt; \":\" &lt;&lt; std::setw(2) &lt;&lt; minutes &lt;&lt; \":\"\n       &lt;&lt; std::setw(2) &lt;&lt; seconds;\n    return os.str();\n}\n\nint main() {\n    // Call the function\n    std::cout &lt;&lt; time_adder(\"05:10:30\", 123) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/3-4_substring_search/","title":"Substring Search","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;std::string&gt; solution(std::vector&lt;std::string&gt; orig_strs,\n                                  std::vector&lt;std::string&gt; substrs) {\n    std::vector&lt;std::string&gt; result;\n\n    for (size_t i = 0; i &lt; orig_strs.size(); ++i) {\n        size_t start_pos = orig_strs[i].find(substrs[i]);\n        std::vector&lt;size_t&gt; match_indices;\n\n        while (start_pos != std::string::npos) {\n            match_indices.push_back(start_pos);\n            start_pos = orig_strs[i].find(substrs[i], start_pos + substrs[i].size());\n        }\n\n        std::ostringstream os;\n        os &lt;&lt; \"The substring '\" &lt;&lt; substrs[i] &lt;&lt; \"' was found in the original string '\"\n           &lt;&lt; orig_strs[i] &lt;&lt; \"' at position(s) \";\n        for (size_t idx : match_indices)\n            os &lt;&lt; idx &lt;&lt; \", \";\n        os.seekp(-2, os.cur); // remove trailing comma and space\n        os &lt;&lt; \".\";\n        result.push_back(os.str());\n    }\n\n    return result;\n}\n\nint main() {\n    // Call the function\n    std::vector&lt;std::string&gt; result = solution(\n        {\"HelloWorld\", \"LearningC++\", \"GoForBroke\", \"BackToBasics\"}, {\"loW\", \"ear\", \"o\", \"Ba\"});\n    for (int i = 0; i &lt; result.size(); ++i) {\n        std::cout &lt;&lt; result[i] &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/4-1_nested_loops/","title":"Nested Loops","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; solution(std::vector&lt;int&gt; vec1, std::vector&lt;int&gt; vec2) {\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; result;\n    for (auto i : vec1) {\n        for (auto j : vec2) {\n            if (i &lt; j) {\n                result.push_back({i, j});\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector&lt;int&gt; vec1 = {1, 3, 7}, vec2 = {2, 8, 9};\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; res = solution(vec1, vec2);\n    for (auto i : res) {\n        std::cout &lt;&lt; i.first &lt;&lt; ' ' &lt;&lt; i.second &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/4-2_uraveling_strings/","title":"Uraveling Strings","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::string solution(std::string sentence) {\n    std::vector&lt;std::string&gt; words;\n    std::string word = \"\";\n    for (char c : sentence) {\n        if (c == ' ') {\n            words.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    words.push_back(word); // add the last word\n\n    std::string result;\n    for (std::string word : words) {\n        if (word.size() % 2 == 0) {                    // confirms if the length of the word is even\n            for (int i = 1; i &lt; word.size(); i += 2) { // loop over odd-indexed characters\n                result += word[i];\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout &lt;&lt; solution(\"Cplusplus is a high-level programming language.\");\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/4-3_obstacle_game/","title":"Obstacle Game","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint solution(std::vector&lt;int&gt; numbers, int obstacle) {\n    int position = 0;\n    int moves = 0;\n    while (position &lt; numbers.size()) {\n        if (numbers[position] == obstacle) {\n            return position;\n        }\n        moves++;\n        position += numbers[position];\n    }\n    return moves;\n}\n\nint main() {\n    std::cout &lt;&lt; solution({2, 3, 3, 4, 2, 4}, 4);\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/4-4_handling_large_numbers/","title":"Handling Large Numbers","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::string addLargeNumbers(std::string num1, std::string num2) {\n    int i = num1.size() - 1;\n    int j = num2.size() - 1;\n    int carry = 0;\n    std::vector&lt;char&gt; result;\n\n    while (i &gt;= 0 || j &gt;= 0 || carry) {\n        int n1 = (i &gt;= 0) ? num1[i] - '0' : 0;\n        int n2 = (j &gt;= 0) ? num2[j] - '0' : 0;\n        int current = n1 + n2 + carry;\n        carry = current / 10;\n        current = current % 10;\n        result.push_back('0' + current);\n        i--;\n        j--;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n\nint main() {\n    std::cout &lt;&lt; addLargeNumbers(\"1454178195297\", \"8458263917502\");\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/5-1_array_traversal/","title":"Array Traversal","text":"<pre><code>#include &lt;climits&gt; // For INT_MIN\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint solution(std::vector&lt;int&gt; arrayA, std::vector&lt;int&gt; arrayB, int sizeA, int sizeB) {\n    int indexA = 0;\n    int indexB = -1;\n    bool in_arrayA = true;\n    int max_value = INT_MIN;\n\n    while (true) {\n        if (in_arrayA) {\n            indexB = arrayA[indexA];\n            if (arrayB[indexB] &gt; max_value) {\n                max_value = arrayB[indexB];\n            }\n        } else {\n            indexA = arrayB[indexB];\n            if (indexA == 0) {\n                return max_value;\n            }\n        }\n        in_arrayA = !in_arrayA;\n    }\n}\n\nint main() {\n    std::vector&lt;int&gt; arrayA = {2, 4, 3, 1, 6};\n    std::vector&lt;int&gt; arrayB = {4, 0, 3, 2, 0};\n    int sizeA = arrayA.size();\n    int sizeB = arrayB.size();\n\n    std::cout &lt;&lt; \"Maximum value encountered in arrayB: \" &lt;&lt; solution(arrayA, arrayB, sizeA, sizeB)\n              &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/5-2_string_manipulation/","title":"String Manipulation","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;int&gt; character_frequency_encoding(std::string word) {\n    // Step 1: Mapping each character to the next alphabetical character\n    std::string next_string = \"\";\n    for (char &amp;letter : word) {\n        next_string += (letter == 'z' ? 'a' : letter + 1);\n    }\n\n    // Step 2: Counting the frequency of characters in next_string\n    std::map&lt;char, int&gt; frequency_map;\n    for (const char &amp;letter : next_string) {\n        if (frequency_map.find(letter) != frequency_map.end()) {\n            frequency_map[letter]++;\n        } else {\n            frequency_map[letter] = 1;\n        }\n    }\n\n    // Step 3: Building the product list\n    std::vector&lt;int&gt; combined_values;\n    for (const auto &amp;item : frequency_map) {\n        combined_values.push_back(static_cast&lt;int&gt;(item.first) * item.second);\n    }\n\n    // Step 4: Sorting the final values in descending order\n    std::sort(combined_values.begin(), combined_values.end(), std::greater&lt;int&gt;());\n\n    // Return the sorted list\n    return combined_values;\n}\n\n// Example\nint main() {\n    std::string word = \"banana\";\n    std::vector&lt;int&gt; result = character_frequency_encoding(word);\n    for (int value : result) {\n        std::cout &lt;&lt; value &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/5-3_string_and_array_operations/","title":"String And Array Operations","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nstd::pair&lt;std::string, std::vector&lt;int&gt;&gt; solution(std::string inputString,\n                                                  std::vector&lt;int&gt; numbers) {\n    std::string result = \"\";\n    int sum_so_far = 0;\n    size_t i = 0;\n    while (i &lt; inputString.size() &amp;&amp; sum_so_far &lt;= 20) {\n        result += (inputString[i] == 'z' ? 'a' : inputString[i] + 1);\n        int half_number = static_cast&lt;int&gt;(std::round(numbers[i] / 2.0));\n        sum_so_far += half_number;\n        i++;\n    }\n    std::reverse(result.begin(), result.end());\n    return {result, std::vector&lt;int&gt;(numbers.begin() + i, numbers.end())};\n}\n\nint main() {\n    std::pair&lt;std::string, std::vector&lt;int&gt;&gt; result = solution(\"books\", {10, 20, 30, 50, 100});\n    std::cout &lt;&lt; result.first &lt;&lt; std::endl;\n    std::vector&lt;int&gt; numbers = result.second;\n    for (int value : numbers) {\n        std::cout &lt;&lt; value &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/5-4_forest_traversal/","title":"Forest Traversal","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint calculate_jump(const vector&lt;int&gt; &amp;forest, int start, int direction) {\n    int jump = 1;\n\n    while ((direction * jump) + start &gt;= 0 &amp;&amp; (direction * jump) + start &lt; forest.size()) {\n        int pos = start;\n        while (0 &lt;= pos &amp;&amp; pos &lt; forest.size()) {\n            if (forest[pos] == 1) {\n                break;\n            }\n            pos += jump * direction;\n        }\n        if (pos &lt; 0 || pos &gt;= forest.size()) {\n            return jump;\n        }\n\n        jump += 1;\n    }\n    return -1;\n}\n\nint main() {\n    std::vector&lt;int&gt; forest = {0, 1, 0, 0, 0, 0, 1, 1};\n    std::cout &lt;&lt; calculate_jump(forest, 0, 1) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"codesignal/5-5_array_manipulation/","title":"Array Manipulation","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint solution(vector&lt;int&gt; balloons) {\n    int n = balloons.size();\n    int steps = 0;\n    while (true) {\n        steps += 1;\n        vector&lt;int&gt; new_balloons = balloons;\n        for (int i = 0; i &lt; n; ++i) {\n            int share = balloons[i] / 2;        // Balloons to share\n            new_balloons[i] -= share;           // Decrease balloons of current house\n            new_balloons[(i + 1) % n] += share; // Increase balloons of next house\n        }\n        if (new_balloons == balloons) {\n            break;\n        }\n        balloons = new_balloons;\n    }\n    return steps;\n}\n\nint main() {\n    std::vector&lt;int&gt; balloons = {4, 1, 2};\n    std::cout &lt;&lt; solution(balloons) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"containers/array/","title":"Array","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n\n/**\n * @brief Traverses two arrays based on their values and returns the path taken.\n *\n * This function performs a traversal through arrayA and arrayB, where each value\n * in the arrays represents an index to jump to in the other array. The traversal\n * continues until a cycle is detected (i.e., we revisit an index in arrayA).\n *\n * @param arrayA The first array of integers (1-based indexing)\n * @param arrayB The second array of integers (1-based indexing)\n * @return std::vector&lt;int&gt; The sequence of indices visited in arrayB (1-based indexing)\n */\nstd::vector&lt;int&gt; solution1(const std::vector&lt;int&gt; &amp;arrayA, const std::vector&lt;int&gt; &amp;arrayB) {\n    std::vector&lt;int&gt; result;          // Stores the sequence of visited indices in arrayB\n    std::unordered_set&lt;int&gt; visitedA; // Keeps track of visited indices in arrayA\n    int index = 0;                    // Starting index for arrayA (0-based)\n\n    // Continue traversal until we revisit an index in arrayA\n    while (visitedA.find(index) == visitedA.end()) {\n        // Mark current index in arrayA as visited\n        visitedA.insert(index);\n\n        // Get the value from arrayA and convert to 0-based index for arrayB\n        int indexB = arrayA[index] - 1;\n\n        // Store the 1-based index of arrayB in the result\n        result.push_back(indexB + 1);\n\n        // Get the next index for arrayA from arrayB (convert to 0-based)\n        index = arrayB[indexB] - 1;\n    }\n\n    return result;\n}\n\n/**\n * @brief Traverses three arrays alternately and returns the sum of maximum values from arrayB and\n * arrayC.\n *\n * This function alternates between arrayB and arrayC based on indices from arrayA.\n * It keeps track of the maximum values encountered in arrayB and arrayC during the traversal.\n * The traversal stops when a cycle is detected or an out-of-bounds index is encountered.\n *\n * @param arrayA The first array of integers (1-based indexing)\n * @param arrayB The second array of integers\n * @param arrayC The third array of integers\n * @return int The sum of maximum values encountered in arrayB and arrayC\n */\nint solution2(const std::vector&lt;int&gt; &amp;arrayA, const std::vector&lt;int&gt; &amp;arrayB,\n              const std::vector&lt;int&gt; &amp;arrayC) {\n    int maxB = 0;                           // Maximum value encountered in arrayB\n    int maxC = 0;                           // Maximum value encountered in arrayC\n    int index = 0;                          // Current index in arrayA\n    std::unordered_set&lt;int&gt; visitedIndices; // Set to track visited indices in arrayA\n    bool isB = true;                        // Flag to alternate between arrayB and arrayC\n\n    while (true) {\n        // Check if we've visited this index in arrayA before or if it's out of bounds\n        if (index &lt; 0 || index &gt;= arrayA.size() ||\n            visitedIndices.find(index) != visitedIndices.end()) {\n            break; // Exit the loop if we're in a cycle or out of bounds\n        }\n\n        visitedIndices.insert(index); // Mark this index as visited\n\n        int nextIndex = arrayA[index] - 1; // Get the next index from arrayA (convert to 0-based)\n\n        // Update maxB or maxC based on which array we're visiting\n        if (isB) {\n            if (nextIndex &gt;= 0 &amp;&amp; nextIndex &lt; arrayB.size()) {\n                maxB = std::max(maxB, arrayB[nextIndex]);\n            } else {\n                break; // Exit if we're out of bounds in arrayB\n            }\n        } else {\n            if (nextIndex &gt;= 0 &amp;&amp; nextIndex &lt; arrayC.size()) {\n                maxC = std::max(maxC, arrayC[nextIndex]);\n            } else {\n                break; // Exit if we're out of bounds in arrayC\n            }\n        }\n\n        index = nextIndex; // Move to the next index in arrayA\n        isB = !isB;        // Toggle between arrayB and arrayC\n    }\n\n    return maxB + maxC; // Return the sum of maximum values from arrayB and arrayC\n}\n\n/**\n * @brief Traverses three arrays in a specific pattern and returns the sum of maximum values from\n * arrayB and arrayC.\n *\n * This function follows a pattern of arrayA -&gt; arrayB -&gt; arrayA -&gt; arrayC, repeating until a cycle\n * is detected or an out-of-bounds index is encountered. It keeps track of the maximum values in\n * arrayB and arrayC.\n *\n * @param arrayA The first array of integers (0-based indexing)\n * @param arrayB The second array of integers\n * @param arrayC The third array of integers\n * @return int The sum of maximum values encountered in arrayB and arrayC\n */\nint solution3(const std::vector&lt;int&gt; &amp;arrayA, const std::vector&lt;int&gt; &amp;arrayB,\n              const std::vector&lt;int&gt; &amp;arrayC) {\n    int maxB = 0;   // Maximum value encountered in arrayB\n    int maxC = 0;   // Maximum value encountered in arrayC\n    int indexA = 0; // Start with index 0 in arrayA\n\n    // Separate sets to track visited indices in each array\n    std::unordered_set&lt;int&gt; visitedA, visitedB, visitedC;\n\n    while (true) {\n        // Check arrayA\n        if (indexA &lt; 0 || indexA &gt;= arrayA.size() || visitedA.find(indexA) != visitedA.end()) {\n            break;\n        }\n        visitedA.insert(indexA);\n        int valueA = arrayA[indexA];\n\n        // Move to arrayB\n        if (valueA &lt; 0 || valueA &gt;= arrayB.size() || visitedB.find(valueA) != visitedB.end()) {\n            break;\n        }\n        visitedB.insert(valueA);\n        maxB = std::max(maxB, arrayB[valueA]);\n        indexA = arrayB[valueA];\n\n        // Check arrayA again\n        if (indexA &lt; 0 || indexA &gt;= arrayA.size() || visitedA.find(indexA) != visitedA.end()) {\n            break;\n        }\n        visitedA.insert(indexA);\n        valueA = arrayA[indexA];\n\n        // Move to arrayC\n        if (valueA &lt; 0 || valueA &gt;= arrayC.size() || visitedC.find(valueA) != visitedC.end()) {\n            break;\n        }\n        visitedC.insert(valueA);\n        maxC = std::max(maxC, arrayC[valueA]);\n        indexA = arrayC[valueA];\n    }\n\n    return maxB + maxC; // Return the sum of maximum values from arrayB and arrayC\n}\n\n// Helper function to print a vector\nvoid printVector(const std::vector&lt;int&gt; &amp;vec, const std::string &amp;name) {\n    std::cout &lt;&lt; name &lt;&lt; \" = [\";\n    for (size_t i = 0; i &lt; vec.size(); ++i) {\n        std::cout &lt;&lt; vec[i];\n        if (i &lt; vec.size() - 1)\n            std::cout &lt;&lt; \", \";\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\n\nint main() {\n    // Test cases\n    std::vector&lt;int&gt; arrayA1 = {2, 1};\n    std::vector&lt;int&gt; arrayB1 = {1, 2};\n\n    std::vector&lt;int&gt; arrayA2 = {1, 3, 4, 2, 5};\n    std::vector&lt;int&gt; arrayB2 = {5, 3, 2, 4, 1};\n    std::vector&lt;int&gt; arrayC2 = {1, 5, 3, 2, 4};\n\n    // Test solution1\n    std::cout &lt;&lt; \"Testing solution1:\\n\";\n    printVector(arrayA1, \"Array A\");\n    printVector(arrayB1, \"Array B\");\n    std::vector&lt;int&gt; result1 = solution1(arrayA1, arrayB1);\n    printVector(result1, \"Result\");\n    std::cout &lt;&lt; \"\\n\";\n\n    // Test solution2\n    std::cout &lt;&lt; \"Testing solution2:\\n\";\n    printVector(arrayA2, \"Array A\");\n    printVector(arrayB2, \"Array B\");\n    printVector(arrayC2, \"Array C\");\n    int result2 = solution2(arrayA2, arrayB2, arrayC2);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result2 &lt;&lt; \"\\n\\n\";\n\n    // Test solution3\n    std::cout &lt;&lt; \"Testing solution3:\\n\";\n    printVector(arrayA2, \"Array A\");\n    printVector(arrayB2, \"Array B\");\n    printVector(arrayC2, \"Array C\");\n    int result3 = solution3(arrayA2, arrayB2, arrayC2);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result3 &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"containers/bst/","title":"Bst","text":"<pre><code>#include \"rng.hpp\"   // Include RNG library\n#include \"timer.hpp\" // Include Timer library\n#include &lt;compare&gt;   // For three-way comparison (C++20)\n#include &lt;iostream&gt;\n#include &lt;queue&gt; // For breadth-first traversal\n\nusing namespace std;\n\n// Node structure representing each node in the BST\nclass Node {\npublic:\n    int data;    // Value stored in the node\n    Node *left;  // Pointer to the left child\n    Node *right; // Pointer to the right child\n\n    // Constructor to initialize a new node\n    Node(int value) : data(value), left(nullptr), right(nullptr) {}\n};\n\n// Class representing the Binary Search Tree\nclass BinarySearchTree {\nprivate:\n    Node *root; // Root node of the BST\n\n    // Helper function to insert a value recursively\n    Node *insertHelper(Node *node, int value) {\n        // If the current node is null, create a new node\n        if (node == nullptr) {\n            return new Node(value);\n        }\n\n        // Compare value with the current node's data\n        auto cmp = value &lt;=&gt; node-&gt;data;\n        if (cmp &lt; 0) {\n            node-&gt;left = insertHelper(node-&gt;left, value); // Insert in the left subtree\n        } else if (cmp &gt; 0) {\n            node-&gt;right = insertHelper(node-&gt;right, value); // Insert in the right subtree\n        }\n        // Duplicates are implicitly skipped (cmp == 0)\n\n        return node;\n    }\n\n    // Helper function for in-order traversal\n    void inOrderTraversal(Node *node) {\n        if (node != nullptr) {\n            inOrderTraversal(node-&gt;left);  // Visit left subtree\n            cout &lt;&lt; node-&gt;data &lt;&lt; \" \";     // Visit node\n            inOrderTraversal(node-&gt;right); // Visit right subtree\n        }\n    }\n\n    // Helper function for pre-order traversal\n    void preOrderTraversal(Node *node) {\n        if (node != nullptr) {\n            cout &lt;&lt; node-&gt;data &lt;&lt; \" \";      // Visit node\n            preOrderTraversal(node-&gt;left);  // Visit left subtree\n            preOrderTraversal(node-&gt;right); // Visit right subtree\n        }\n    }\n\n    // Helper function for post-order traversal\n    void postOrderTraversal(Node *node) {\n        if (node != nullptr) {\n            postOrderTraversal(node-&gt;left);  // Visit left subtree\n            postOrderTraversal(node-&gt;right); // Visit right subtree\n            cout &lt;&lt; node-&gt;data &lt;&lt; \" \";       // Visit node\n        }\n    }\n\n    // Helper function for breadth-first traversal\n    void breadthFirstTraversal(Node *node) {\n        if (!node)\n            return;\n\n        queue&lt;Node *&gt; q;\n        q.push(node);\n\n        while (!q.empty()) {\n            Node *current = q.front();\n            q.pop();\n            cout &lt;&lt; current-&gt;data &lt;&lt; \" \"; // Visit node\n\n            if (current-&gt;left)\n                q.push(current-&gt;left);\n            if (current-&gt;right)\n                q.push(current-&gt;right);\n        }\n    }\n\n    // Helper function to invert the BST\n    void invert(Node *node) {\n        if (node == nullptr)\n            return;\n\n        // Swap the left and right children\n        std::swap(node-&gt;left, node-&gt;right);\n\n        // Recursively invert the children\n        invert(node-&gt;left);\n        invert(node-&gt;right);\n    }\n\npublic:\n    // Constructor to initialize an empty BST\n    BinarySearchTree() : root(nullptr) {}\n\n    /**\n     * @brief Inserts a value into the BST.\n     *\n     * @param value The value to insert.\n     */\n    void insert(int value) { root = insertHelper(root, value); }\n\n    /**\n     * @brief Performs in-order traversal of the BST.\n     *\n     * Outputs the values in ascending order.\n     */\n    void inOrderTraversal() {\n        inOrderTraversal(root);\n        cout &lt;&lt; endl; // Print a newline after traversal\n    }\n\n    /**\n     * @brief Performs pre-order traversal of the BST.\n     *\n     * Outputs the values in pre-order.\n     */\n    void preOrderTraversal() {\n        preOrderTraversal(root);\n        cout &lt;&lt; endl; // Print a newline after traversal\n    }\n\n    /**\n     * @brief Performs post-order traversal of the BST.\n     *\n     * Outputs the values in post-order.\n     */\n    void postOrderTraversal() {\n        postOrderTraversal(root);\n        cout &lt;&lt; endl; // Print a newline after traversal\n    }\n\n    /**\n     * @brief Performs breadth-first traversal of the BST.\n     *\n     * Outputs the values level by level.\n     */\n    void breadthFirstTraversal() {\n        cout &lt;&lt; \"Breadth-First Traversal: \";\n        breadthFirstTraversal(root); // Call the helper function with root\n        cout &lt;&lt; endl;                // Print a newline after traversal\n    }\n\n    /**\n     * @brief Inverts the BST.\n     *\n     * This swaps the left and right children of all nodes.\n     */\n    void invert() { invert(root); }\n\n    /**\n     * @brief Generates a random BST with N nodes.\n     *\n     * @param n The number of nodes to generate.\n     */\n    void generateRandomBST(int n) {\n        RandomNumberGenerator rng; // Create RNG instance\n        Timer timer;               // Create Timer instance\n        timer.start();             // Start timing\n\n        for (int i = 0; i &lt; n; ++i) {\n            insert(rng.getRandomNumber() % 100); // Insert random numbers, limited to 0-99\n        }\n\n        timer.logTime(\"Generate Random BST Time\"); // Log the processing time\n    }\n};\n\n// Main function\nint main() {\n    BinarySearchTree bst;\n\n    // Generate and display a random BST with 10 nodes\n    bst.generateRandomBST(10);\n\n    cout &lt;&lt; \"In-order traversal of the Random BST: \";\n    bst.inOrderTraversal();\n\n    cout &lt;&lt; \"Pre-order traversal of the Random BST: \";\n    bst.preOrderTraversal();\n\n    cout &lt;&lt; \"Post-order traversal of the Random BST: \";\n    bst.postOrderTraversal();\n\n    cout &lt;&lt; \"Inverting the BST...\" &lt;&lt; endl;\n    bst.invert();\n\n    cout &lt;&lt; \"In-order traversal after inversion: \";\n    bst.inOrderTraversal();\n\n    cout &lt;&lt; \"Breadth-first traversal after inversion: \";\n    bst.breadthFirstTraversal();\n\n    return 0;\n}\n</code></pre>"},{"location":"containers/hashmap/","title":"Hashmap","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nint main() {\n    // Creating an unordered_map to store HTTP status codes and their meanings\n    std::unordered_map&lt;int, std::string&gt; http_status_codes = {{200, \"OK\"},\n                                                              {404, \"Not Found\"},\n                                                              {500, \"Internal Server Error\"},\n                                                              {301, \"Moved Permanently\"},\n                                                              {403, \"Forbidden\"}};\n\n    // Using find() to access a specific HTTP status message\n    int code_to_find = 200;\n    auto it = http_status_codes.find(code_to_find);\n    if (it != http_status_codes.end()) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; code_to_find &lt;&lt; \": \" &lt;&lt; it-&gt;second\n                  &lt;&lt; std::endl; // Output: \"OK\"\n    } else {\n        std::cout &lt;&lt; \"HTTP Status code not found\" &lt;&lt; std::endl;\n    }\n\n    // Using find() to access a nonexistent HTTP status code\n    int nonexistent_code = 999;\n    auto it_nonexistent = http_status_codes.find(nonexistent_code);\n    if (it_nonexistent != http_status_codes.end()) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; nonexistent_code &lt;&lt; \": \" &lt;&lt; it_nonexistent-&gt;second\n                  &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"HTTP Status code not found\"\n                  &lt;&lt; std::endl; // Output: \"HTTP Status code not found\"\n    }\n\n    // Looping over the unordered_map to display all HTTP status codes and their meanings\n    std::cout &lt;&lt; \"\\nAll HTTP Status Codes:\\n\";\n    for (const auto &amp;pair : http_status_codes) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; std::endl;\n    }\n\n    // Additional member functions and operations\n    // Checking the size of the unordered_map\n    std::cout &lt;&lt; \"\\nTotal number of HTTP status codes: \" &lt;&lt; http_status_codes.size() &lt;&lt; std::endl;\n\n    // Checking if a particular key exists\n    int check_code = 403;\n    if (http_status_codes.count(check_code)) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; check_code &lt;&lt; \" exists.\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; check_code &lt;&lt; \" does not exist.\" &lt;&lt; std::endl;\n    }\n\n    // Inserting a new HTTP status code\n    http_status_codes[418] = \"I'm a teapot\"; // Adding an HTTP status code for fun\n    std::cout &lt;&lt; \"Added HTTP Status 418: \" &lt;&lt; http_status_codes[418] &lt;&lt; std::endl;\n\n    // Erasing an HTTP status code\n    http_status_codes.erase(404);\n    std::cout &lt;&lt; \"Erased HTTP Status 404.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"containers/http_hashmap/","title":"Http Hashmap","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Creating an unordered_map to store HTTP status codes and their meanings\n    std::unordered_map&lt;int, std::string&gt; http_status_codes = {{200, \"OK\"},\n                                                              {404, \"Not Found\"},\n                                                              {500, \"Internal Server Error\"},\n                                                              {301, \"Moved Permanently\"},\n                                                              {403, \"Forbidden\"}};\n\n    // Using find() to access a specific HTTP status message\n    int code_to_find = 200;\n    auto it = http_status_codes.find(code_to_find);\n    if (it != http_status_codes.end()) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; code_to_find &lt;&lt; \": \" &lt;&lt; it-&gt;second\n                  &lt;&lt; std::endl; // Output: \"OK\"\n    } else {\n        std::cout &lt;&lt; \"HTTP Status code not found\" &lt;&lt; std::endl;\n    }\n\n    // Using find() to access a nonexistent HTTP status code\n    int nonexistent_code = 999;\n    auto it_nonexistent = http_status_codes.find(nonexistent_code);\n    if (it_nonexistent != http_status_codes.end()) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; nonexistent_code &lt;&lt; \": \" &lt;&lt; it_nonexistent-&gt;second\n                  &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"HTTP Status code not found\"\n                  &lt;&lt; std::endl; // Output: \"HTTP Status code not found\"\n    }\n\n    // Looping over the unordered_map to display all HTTP status codes and their meanings\n    std::cout &lt;&lt; \"\\nAll HTTP Status Codes:\\n\";\n    for (const auto &amp;pair : http_status_codes) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; std::endl;\n    }\n\n    // Counting occurrences of colors using unordered_map\n    std::vector&lt;std::string&gt; colors = {\"red\", \"blue\", \"red\", \"green\", \"blue\", \"blue\"};\n    std::unordered_map&lt;std::string, int&gt; color_map;\n\n    // Iterate over each color and increase its count\n    for (const auto &amp;color : colors) {\n        color_map[color] += 1;\n    }\n\n    // Print the unordered_map with color counts\n    std::cout &lt;&lt; \"\\nColor Counts:\\n\";\n    for (const auto &amp;pair : color_map) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; std::endl;\n    }\n\n    // Additional member functions and operations on the HTTP status codes map\n    std::cout &lt;&lt; \"\\nTotal number of HTTP status codes: \" &lt;&lt; http_status_codes.size() &lt;&lt; std::endl;\n\n    // Checking if a particular key exists\n    int check_code = 403;\n    if (http_status_codes.count(check_code)) {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; check_code &lt;&lt; \" exists.\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"HTTP Status \" &lt;&lt; check_code &lt;&lt; \" does not exist.\" &lt;&lt; std::endl;\n    }\n\n    // Inserting a new HTTP status code\n    http_status_codes[418] = \"I'm a teapot\"; // Adding an HTTP status code for fun\n    std::cout &lt;&lt; \"Added HTTP Status 418: \" &lt;&lt; http_status_codes[418] &lt;&lt; std::endl;\n\n    // Erasing an HTTP status code\n    http_status_codes.erase(404);\n    std::cout &lt;&lt; \"Erased HTTP Status 404.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"containers/map/","title":"Map","text":"<pre><code>#include \"rng.hpp\"   // Include RNG library\n#include \"timer.hpp\" // Include Timer library\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n/**\n * @brief Processes a string and creates a map of characters to integers.\n *\n * This function uses the following STL containers:\n * - std::map&lt;char, int&gt;: Associative container to store character frequencies and results\n * - std::string: Sequence container to store and process characters\n *\n * @param s Input string.\n * @return Map of characters to integers.\n */\nstd::map&lt;char, int&gt; solution2(const std::string &amp;s) {\n    std::map&lt;char, int&gt; result;\n    std::map&lt;char, int&gt; frequency;\n\n    Timer timer;   // Create Timer instance\n    timer.start(); // Start timing\n\n    // Step 1: Count frequency of each character\n    for (char c : s) {\n        frequency[c]++;\n    }\n\n    // Step 2 &amp; 3: Calculate numerical representation and store results\n    for (const auto &amp;pair : frequency) {\n        char original = pair.first;\n        int freq = pair.second;\n\n        // Shift the character 3 positions back\n        char shifted = original - 3;\n        if (shifted &lt; 'a') {\n            shifted = 'z' - ('a' - shifted) + 1;\n        }\n\n        // Calculate the numerical representation\n        int value = static_cast&lt;int&gt;(shifted) * freq;\n\n        // Store the result for the original character\n        result[original] = value;\n    }\n\n    timer.logTime(\"Solution2 Processing Time\"); // Log the processing time\n    return result;\n}\n\n/**\n * @brief A class representing a simple map usage for frequency counting.\n */\nclass CharacterFrequencyMap {\npublic:\n    /**\n     * @brief Inserts characters from a string into a frequency map.\n     *\n     * @param str The input string.\n     * @return A map of character frequencies.\n     */\n    std::map&lt;char, int&gt; createFrequencyMap(const std::string &amp;str) {\n        std::map&lt;char, int&gt; freqMap;\n\n        Timer timer;   // Create Timer instance\n        timer.start(); // Start timing\n\n        for (char c : str) {\n            freqMap[c]++;\n        }\n\n        timer.logTime(\"Create Frequency Map Time\"); // Log the processing time\n        return freqMap;\n    }\n};\n\n/**\n * @brief Tests the CharacterFrequencyMap class.\n */\nvoid testCharacterFrequencyMap() {\n    CharacterFrequencyMap freqMap;\n    std::string input = \"hello world\";\n\n    auto result = freqMap.createFrequencyMap(input);\n    std::cout &lt;&lt; \"Character Frequency Map Test:\\nInput: \" &lt;&lt; input &lt;&lt; \"\\nOutput:\\n\";\n    for (const auto &amp;pair : result) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n\n/**\n * @brief Main function for testing.\n */\nint main() {\n    testCharacterFrequencyMap();\n\n    // Example usage of solution2\n    std::string exampleInput = \"aabbccddeeffgghh\";\n    auto exampleOutput = solution2(exampleInput);\n    std::cout &lt;&lt; \"Example Solution 2 Test:\\nInput: \" &lt;&lt; exampleInput &lt;&lt; \"\\nOutput:\\n\";\n    for (const auto &amp;pair : exampleOutput) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; \"\\n\";\n    }\n\n    return 0;\n}\n\n#if 0\nint main() {\n    std::unordered_map&lt;std::string, int&gt; fruit_basket = {{\"apples\", 5}, {\"bananas\", 4}, {\"oranges\", 8}};\n    // An unordered_map representing our fruit basket\n\n    // Summing the values\n    int total_fruits = 0;\n    for (const auto&amp; pair : fruit_basket) {\n        total_fruits += pair.second;\n    }\n\n    // Finding the maximum value\n    auto max_fruit = std::max_element(fruit_basket.begin(), fruit_basket.end(),\n        [](const auto&amp; a, const auto&amp; b) {\n            return a.second &lt; b.second;\n        })-&gt;first;\n\n    std::cout &lt;&lt; \"The fruit with the most quantity is: \" &lt;&lt; max_fruit &lt;&lt; std::endl;\n    // It outputs: \"The fruit with the most quantity is: oranges\"\n\n    // Finding the minimum value\n    auto min_fruit = std::min_element(fruit_basket.begin(), fruit_basket.end(),\n        [](const auto&amp; a, const auto&amp; b) {\n            return a.second &lt; b.second;\n        })-&gt;first;\n\n    std::cout &lt;&lt; \"The fruit with the least quantity is: \" &lt;&lt; min_fruit &lt;&lt; std::endl;\n    // It outputs: \"The fruit with the least quantity is: bananas\"\n    // Calculating the average\n    double average_fruits = static_cast&lt;double&gt;(total_fruits) / fruit_basket.size();\n    std::cout &lt;&lt; \"The average number of each type of fruit in the basket is: \" &lt;&lt; average_fruits &lt;&lt; std::endl;\n    // It outputs: \"The average number of each type of fruit in the basket is: 5.67\"\n\n    return 0;\n}\n#endif\n</code></pre>"},{"location":"containers/strings/","title":"Strings","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;cctype&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// Define a struct to represent a sea creature\nstruct SeaCreature {\n    std::string name;\n    int appendages;\n};\n\n/**\n * @brief Splits a string into a vector of substrings using a specified delimiter\n *\n * This function uses std::istringstream to efficiently split the string.\n *\n * @param s The input string to split\n * @param delimiter The character to use as a delimiter\n * @return std::vector&lt;std::string&gt; A vector containing the split substrings\n */\nstd::vector&lt;std::string&gt; split(const std::string &amp;s, char delimiter) {\n    std::vector&lt;std::string&gt; tokens;\n    std::istringstream tokenStream(s);\n    std::string token;\n    while (std::getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/**\n * @brief Processes sea creature data and outputs their names and appendages\n *\n * This function demonstrates the use of std::vector, std::string, and string-to-integer conversion.\n *\n * @param data A string containing sea creature data in the format\n * \"name,appendages;name,appendages;...\"\n */\nvoid processSeaCreatures(const std::string &amp;data) {\n    std::vector&lt;SeaCreature&gt; creatures;\n    auto entries = split(data, ';'); // Split by semicolon to get each creature's data\n    for (const auto &amp;entry : entries) {\n        auto details = split(entry, ','); // Split by comma to get name and appendages\n        if (details.size() == 2) {\n            SeaCreature creature;\n            creature.name = details[0];\n            creature.appendages = std::stoi(details[1]); // Convert string to int\n            creatures.push_back(creature);               // Add to vector\n        }\n    }\n    // Output the sea creatures and their appendages\n    for (const auto &amp;creature : creatures) {\n        std::cout &lt;&lt; \"Creature: \" &lt;&lt; creature.name &lt;&lt; \", Appendages: \" &lt;&lt; creature.appendages\n                  &lt;&lt; std::endl;\n    }\n}\n\n/**\n * @brief Transforms a character to its \"opposite\" in the alphabet\n *\n * For lowercase letters, it transforms 'a' to 'z', 'b' to 'y', etc.\n * For uppercase letters, it transforms 'A' to 'Z', 'B' to 'Y', etc.\n *\n * @param c The character to transform (passed by reference)\n */\nvoid transform_to_opposite(char &amp;c) {\n    if (std::islower(c))\n        c = 'z' - c + 'a'; // 122 - (int)c + 97\n    else if (std::isupper(c))\n        c = 'Z' - c + 'A'; // 90 - (int)c + 65\n}\n\n/**\n * @brief Transforms each word in the input string by applying transform_to_opposite to each\n * character\n *\n * This function demonstrates the use of std::istringstream for string splitting,\n * std::for_each for applying a function to each element of a container,\n * and string manipulation.\n *\n * @param str The input string to transform\n * @return std::string The transformed string\n */\nstd::string test1(const std::string &amp;str) {\n    std::string result;\n    std::istringstream iss(str);\n    std::string word;\n    while (iss &gt;&gt; word) {\n        std::for_each(word.begin(), word.end(), transform_to_opposite);\n        result += word + \" \";\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;\n}\n\nint main() {\n    // Test processSeaCreatures function\n    std::string seaCreatureData = \"Octopus,8;Starfish,5;Crab,10;Squid,10\";\n    std::cout &lt;&lt; \"Processing sea creature data:\\n\";\n    processSeaCreatures(seaCreatureData);\n\n    std::cout &lt;&lt; \"\\nTesting string transformation:\\n\";\n    std::cout &lt;&lt; \"Input: \\\"abc 123 def 456\\\"\\n\";\n    std::cout &lt;&lt; \"Output: \\\"\" &lt;&lt; test1(\"abc 123 def 456\") &lt;&lt; \"\\\"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"containers/vector/","title":"Vector","text":"<pre><code>#include \"rng.hpp\"   // Include RNG library\n#include \"timer.hpp\" // Include Timer library\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n/**\n * @brief Checks if a character is alphanumeric.\n *\n * @param c The character to check.\n * @return true if the character is alphanumeric, false otherwise.\n */\nbool isAlphaNumeric(char c) {\n    return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9');\n}\n\n/**\n * @brief Encodes a character by shifting it back by one, with wraparound.\n *\n * @param c The character to encode.\n * @return The encoded character.\n */\nchar encode(char c) {\n    if (!isAlphaNumeric(c))\n        return c;\n    if (c == 'a')\n        return 'z';\n    if (c == 'A')\n        return 'Z';\n    if (c == '0')\n        return '9';\n    return c - 1;\n}\n\n/**\n * @brief Processes a vector of integers according to specific rules.\n *\n * This function uses the following STL containers and algorithms:\n * - std::vector&lt;int&gt;: Dynamic array to store integers\n * - std::map&lt;int, int&gt;: Associative container to store frequency of numbers\n *\n * @param numbers Input vector of integers.\n * @return Processed vector of integers.\n */\nstd::vector&lt;int&gt; solution1(const std::vector&lt;int&gt; &amp;numbers) {\n    std::vector&lt;int&gt; result;\n    std::vector&lt;int&gt; firstpass;\n\n    Timer timer;   // Create Timer instance\n    timer.start(); // Start timing\n\n    // Step 1: Modify input numbers\n    for (auto i : numbers) {\n        if (i % 10 == 0)\n            firstpass.push_back(1);\n        else\n            firstpass.push_back(i + 1);\n    }\n\n    // Step 2: Count frequency of each number\n    std::map&lt;int, int&gt; freq;\n    for (auto i : firstpass)\n        freq[i]++;\n\n    // Step 3: Create result vector\n    for (const auto &amp;pair : freq)\n        result.push_back(pair.first * pair.second);\n\n    timer.logTime(\"Solution1 Processing Time\"); // Log the processing time\n    return result;\n}\n\n/**\n * @brief Processes a string and creates a map of characters to integers.\n *\n * This function uses the following STL containers:\n * - std::map&lt;char, int&gt;: Associative container to store character frequencies and results\n * - std::string: Sequence container to store and process characters\n *\n * @param s Input string.\n * @return Map of characters to integers.\n */\nstd::map&lt;char, int&gt; solution2(const std::string &amp;s) {\n    std::map&lt;char, int&gt; result;\n    std::map&lt;char, int&gt; frequency;\n\n    Timer timer;   // Create Timer instance\n    timer.start(); // Start timing\n\n    // Step 1: Count frequency of each character\n    for (char c : s) {\n        frequency[c]++;\n    }\n\n    // Step 2 &amp; 3: Calculate numerical representation and store results\n    for (const auto &amp;pair : frequency) {\n        char original = pair.first;\n        int freq = pair.second;\n\n        // Shift the character 3 positions back\n        char shifted = original - 3;\n        if (shifted &lt; 'a') {\n            shifted = 'z' - ('a' - shifted) + 1;\n        }\n\n        // Calculate the numerical representation\n        int value = static_cast&lt;int&gt;(shifted) * freq;\n\n        // Store the result for the original character\n        result[original] = value;\n    }\n\n    timer.logTime(\"Solution2 Processing Time\"); // Log the processing time\n    return result;\n}\n\n/**\n * @brief Processes a sentence and returns a vector of integers.\n *\n * This function uses the following STL containers and algorithms:\n * - std::string: Sequence container to store and process characters\n * - std::map&lt;char, int&gt;: Associative container to store character frequencies\n * - std::vector&lt;int&gt;: Dynamic array to store result integers\n * - std::sort: Algorithm to sort the result vector\n *\n * @param sentence Input string (sentence).\n * @return Vector of integers representing processed data.\n */\nstd::vector&lt;int&gt; solution3(const std::string &amp;sentence) {\n    std::string encoded_str = \"\";\n    std::map&lt;char, int&gt; freq;\n\n    Timer timer;   // Create Timer instance\n    timer.start(); // Start timing\n\n    // Step 1: Encode the string\n    for (char c : sentence) {\n        char encoded_char = encode(c);\n        encoded_str += encoded_char;\n    }\n\n    // Step 2: Count frequencies of alphanumeric characters\n    for (char c : encoded_str) {\n        if (isAlphaNumeric(c)) {\n            freq[c]++;\n        }\n    }\n\n    // Step 3: Compute absolute differences\n    std::vector&lt;int&gt; result;\n    for (const auto &amp;pair : freq) {\n        char c = pair.first;\n        int frequency = pair.second;\n        int ascii_value = static_cast&lt;int&gt;(c);\n        result.push_back(std::abs(ascii_value - frequency));\n    }\n\n    // Step 4: Sort the differences in ascending order\n    std::sort(result.begin(), result.end());\n\n    timer.logTime(\"Solution3 Processing Time\"); // Log the processing time\n    return result;\n}\n\n/**\n * @brief Tests solution1 function.\n */\nvoid test_solution1() {\n    RandomNumberGenerator rng; // Create RNG instance\n    std::vector&lt;int&gt; input;\n\n    // Generate random input values\n    for (int i = 0; i &lt; 10; ++i) {\n        input.push_back(rng.getRandomNumber() % 100); // Limit values for simplicity\n    }\n\n    std::vector&lt;int&gt; output = solution1(input);\n    std::cout &lt;&lt; \"Solution 1 Test:\\nInput: \";\n    for (int i : input)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; \"\\nOutput: \";\n    for (int i : output)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; \"\\n\\n\";\n}\n\n/**\n * @brief Tests solution2 function.\n */\nvoid test_solution2() {\n    std::string input = \"hello world\";\n    std::map&lt;char, int&gt; output = solution2(input);\n    std::cout &lt;&lt; \"Solution 2 Test:\\nInput: \" &lt;&lt; input &lt;&lt; \"\\nOutput:\\n\";\n    for (const auto &amp;pair : output) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n\n/**\n * @brief Tests solution3 function.\n */\nvoid test_solution3() {\n    std::string input = \"Hello, World! 123\";\n    std::vector&lt;int&gt; output = solution3(input);\n    std::cout &lt;&lt; \"Solution 3 Test:\\nInput: \" &lt;&lt; input &lt;&lt; \"\\nOutput: \";\n    for (int i : output)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; \"\\n\\n\";\n}\n\n// Main function for testing\nint main() {\n    test_solution1();\n    test_solution2();\n    test_solution3();\n    return 0;\n}\n</code></pre>"},{"location":"containers/vector_traversal/","title":"Vector Traversal","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;int&gt; iterateMiddleToEnd(std::vector&lt;int&gt; &amp;numbers) {\n    int mid = numbers.size() / 2; // index of the left middle element\n    int left, right;\n    std::vector&lt;int&gt; newOrder; // vector to store new order\n\n    if (numbers.size() % 2 == 1) {\n        left = mid - 1;                   // Pointing to the left to the middle element\n        right = mid + 1;                  // Pointing to the right of the middle element\n        newOrder.push_back(numbers[mid]); // Adding the middle element to the resulting vector\n    } else {\n        left = mid - 1; // Pointing to the left middle element\n        right = mid;    // Pointing to the right middle element\n    }\n\n    while (left &gt;= 0 &amp;&amp; right &lt; numbers.size()) {\n        newOrder.push_back(numbers[left--]);\n        newOrder.push_back(numbers[right++]);\n    }\n\n    return newOrder;\n}\n\nstd::vector&lt;int&gt; reverse_traverse(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    std::vector&lt;int&gt; output;\n\n    for (int row = rows - 1; row &gt;= 0; --row) {\n        for (int col = cols - 1; col &gt;= 0; --col) {\n            output.push_back(matrix[row][col]);\n        }\n    }\n\n    return output;\n}\n\nstd::vector&lt;int&gt; counterclockwiseTraversal(std::vector&lt;int&gt; &amp;numbers) {}\n</code></pre>"},{"location":"examples/big_numbers/","title":"Big Numbers","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// Function to add two large numbers represented as strings\nstd::string addLargeNumbers(const std::string &amp;num1, const std::string &amp;num2) {\n    int i = num1.size() - 1;\n    int j = num2.size() - 1;\n    int carry = 0;\n    std::vector&lt;char&gt; result;\n\n    while (i &gt;= 0 || j &gt;= 0 || carry) {\n        int n1 = (i &gt;= 0) ? num1[i] - '0' : 0;\n        int n2 = (j &gt;= 0) ? num2[j] - '0' : 0;\n        int current = n1 + n2 + carry;\n        carry = current / 10;\n        current = current % 10;\n        result.push_back('0' + current);\n        i--;\n        j--;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n\n// Function to subtract two large numbers represented as strings\nstd::string subtractLargeNumbers(const std::string &amp;num1, const std::string &amp;num2) {\n    // Assume num1 &gt;= num2 for simplicity\n    int i = num1.size() - 1;\n    int j = num2.size() - 1;\n    int borrow = 0;\n    std::vector&lt;char&gt; result;\n\n    while (i &gt;= 0 || j &gt;= 0) {\n        int n1 = (i &gt;= 0) ? num1[i] - '0' : 0;\n        int n2 = (j &gt;= 0) ? num2[j] - '0' : 0;\n\n        if (n1 &lt; n2 + borrow) {\n            n1 += 10;\n            borrow = 1;\n        } else {\n            borrow = 0;\n        }\n        int current = n1 - n2 - borrow;\n        result.push_back('0' + current);\n        i--;\n        j--;\n    }\n\n    // Remove leading zeros and reverse result\n    while (result.size() &gt; 1 &amp;&amp; result.back() == '0') {\n        result.pop_back();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n\n// Function to multiply two large numbers represented as strings\nstd::string multiplyLargeNumbers(const std::string &amp;num1, const std::string &amp;num2) {\n    std::vector&lt;int&gt; product(num1.size() + num2.size(), 0);\n\n    for (int i = num1.size() - 1; i &gt;= 0; --i) {\n        for (int j = num2.size() - 1; j &gt;= 0; --j) {\n            int n1 = num1[i] - '0';\n            int n2 = num2[j] - '0';\n            int sum = n1 * n2 + product[i + j + 1];\n\n            product[i + j + 1] = sum % 10;\n            product[i + j] += sum / 10;\n        }\n    }\n\n    std::string result;\n    bool leadingZero = true;\n    for (int num : product) {\n        if (num != 0 || !leadingZero) {\n            result.push_back(num + '0');\n            leadingZero = false;\n        }\n    }\n\n    // If the result is still empty, it means the product is zero\n    if (result.empty()) {\n        return \"0\";\n    }\n\n    return result;\n}\n\nint main() {\n    std::string num1 = \"1454178195297\";\n    std::string num2 = \"8458263917502\";\n\n    // Adding large numbers\n    std::string sum = addLargeNumbers(num1, num2);\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    // Subtracting large numbers\n    std::string difference = subtractLargeNumbers(num2, num1); // num2 - num1\n    std::cout &lt;&lt; \"Difference: \" &lt;&lt; difference &lt;&lt; std::endl;\n\n    // Multiplying large numbers\n    std::string product = multiplyLargeNumbers(num1, num2);\n    std::cout &lt;&lt; \"Product: \" &lt;&lt; product &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/bounds/","title":"Bounds","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; v = {10, 20, 30, 30, 20, 10, 10, 20};\n\n    std::sort(v.begin(), v.end());\n\n    // Use lower_bound to find the first position of 20\n    auto low = std::lower_bound(v.begin(), v.end(), 20);\n    // Use upper_bound to find the position just after the last occurrence of 20\n    auto up = std::upper_bound(v.begin(), v.end(), 20);\n\n    // Output the results\n    std::cout &lt;&lt; \"Sorted vector: \";\n    for (const auto&amp; num : v) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"lower_bound of 20 at position: \" &lt;&lt; (low - v.begin()) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"upper_bound of 20 at position: \" &lt;&lt; (up - v.begin()) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/distances/","title":"Distances","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\n// Function to compute the Manhattan distance\nint manhattanDistance(const std::vector&lt;int&gt; &amp;a, const std::vector&lt;int&gt; &amp;b) {\n    return std::inner_product(a.begin(), a.end(), b.begin(), 0, std::plus&lt;&gt;(),\n                              [](int x, int y) { return std::abs(x - y); });\n}\n\n// Function to compute the Hamming distance\nint hammingDistance(const std::vector&lt;int&gt; &amp;a, const std::vector&lt;int&gt; &amp;b) {\n    if (a.size() != b.size()) {\n        throw std::invalid_argument(\"Vectors must be of the same length\");\n    }\n    return std::inner_product(a.begin(), a.end(), b.begin(), 0, std::plus&lt;&gt;(),\n                              [](int x, int y) { return x != y ? 1 : 0; });\n}\n\n// Function to compute the Euclidean distance\ndouble euclideanDistance(const std::vector&lt;int&gt; &amp;a, const std::vector&lt;int&gt; &amp;b) {\n    double sum = std::inner_product(a.begin(), a.end(), b.begin(), 0.0, std::plus&lt;&gt;(),\n                                    [](int x, int y) { return std::pow(x - y, 2); });\n    return std::sqrt(sum);\n}\n\n// Function to find the optimal rotation of array1 to minimize Manhattan distance to array2\nstd::pair&lt;std::vector&lt;int&gt;, int&gt; solution(const std::vector&lt;int&gt; &amp;array1,\n                                          const std::vector&lt;int&gt; &amp;array2) {\n    int n = array1.size();\n    std::vector&lt;int&gt; rotated = array1;\n    int min_distance = std::numeric_limits&lt;int&gt;::max();\n    int min_rotation = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int distance = manhattanDistance(rotated, array2);\n        if (distance &lt; min_distance) {\n            min_distance = distance;\n            min_rotation = i;\n        }\n        std::rotate(rotated.begin(), rotated.begin() + 1, rotated.end());\n    }\n\n    // Apply the best rotation\n    std::rotate(rotated.begin(), rotated.begin() + min_rotation, rotated.end());\n    return std::make_pair(rotated, min_distance);\n}\n\nint main() {\n    std::vector&lt;int&gt; array1 = {1, 2, 3, 4, 5};\n    std::vector&lt;int&gt; array2 = {3, 4, 5, 1, 2};\n\n    // Test Manhattan distance\n    auto [rotated, manhattan_dist] = solution(array1, array2);\n    std::cout &lt;&lt; \"Optimal Rotation: \";\n    for (int x : rotated) {\n        std::cout &lt;&lt; x &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\nManhattan distance: \" &lt;&lt; manhattan_dist &lt;&lt; '\\n';\n\n    // Test Hamming distance\n    int hamming_dist = hammingDistance(array1, array2);\n    std::cout &lt;&lt; \"Hamming distance: \" &lt;&lt; hamming_dist &lt;&lt; '\\n';\n\n    // Test Euclidean distance\n    double euclidean_dist = euclideanDistance(array1, array2);\n    std::cout &lt;&lt; \"Euclidean distance: \" &lt;&lt; euclidean_dist &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/notation/","title":"Notation","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\nint main() {\n    // Example values\n    double A = 100.345;\n    double B = 2006.008;\n    double C = 2331.41592653498;\n\n    // Output for A: hexadecimal representation (truncated to int)\n    cout &lt;&lt; \"0x\" &lt;&lt; hex &lt;&lt; static_cast&lt;int&gt;(A) &lt;&lt; endl;\n\n    // Output for B: formatted to 2 decimal places, right justified\n    cout &lt;&lt; setw(15) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (B &gt;= 0 ? \"+\" : \"\") &lt;&lt; B &lt;&lt; endl;\n\n    // Output for C: scientific notation with 9 decimal places\n    cout &lt;&lt; scientific &lt;&lt; uppercase &lt;&lt; setprecision(9) &lt;&lt; C &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/qsort/","title":"Qsort","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;vector&gt;\n\n// Partition function\ntemplate &lt;typename T&gt; size_t partition(std::vector&lt;T&gt; &amp;arr, size_t low, size_t high) {\n    T pivot = arr[high];\n    size_t i = low;\n\n    for (size_t j = low; j &lt; high; ++j) {\n        if (arr[j] &lt;= pivot) {\n            std::swap(arr[i], arr[j]);\n            ++i;\n        }\n    }\n    std::swap(arr[i], arr[high]);\n    return i;\n}\n\n// Quicksort function\ntemplate &lt;typename T&gt; void quickSort(std::vector&lt;T&gt; &amp;arr, size_t low, size_t high) {\n    if (low &lt; high) {\n        size_t pi = partition(arr, low, high);\n\n        if (pi &gt; 0)\n            quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Function to print a vector\ntemplate &lt;typename T&gt; void printVector(const std::vector&lt;T&gt; &amp;vec) {\n    for (const auto &amp;elem : vec) {\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n\nint main() {\n    // Using a random number generator for creating the input vector\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution&lt;&gt; dis(1, 100);\n\n    std::vector&lt;int&gt; arr(10);\n    std::generate(arr.begin(), arr.end(), [&amp;]() { return dis(gen); });\n\n    std::cout &lt;&lt; \"Unsorted array: \";\n    printVector(arr);\n\n    quickSort(arr, 0, arr.size() - 1);\n\n    std::cout &lt;&lt; \"Sorted array: \";\n    printVector(arr);\n\n    // Demonstrating with a vector of doubles\n    std::vector&lt;double&gt; doubleArr{3.14, 1.41, 2.71, 0.58, 1.73};\n\n    std::cout &lt;&lt; \"\\nUnsorted double array: \";\n    printVector(doubleArr);\n\n    quickSort(doubleArr, 0, doubleArr.size() - 1);\n\n    std::cout &lt;&lt; \"Sorted double array: \";\n    printVector(doubleArr);\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/stream_iterators/","title":"Stream Iterators","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;            // For std::istream_iterator and std::ostream_iterator\n#include &lt;algorithm&gt;           // For std::copy\n\nint main() {\n    std::vector&lt;int&gt; v;\n\n    // Read integers from standard input until EOF\n    std::copy(\n        std::istream_iterator&lt;int&gt;(std::cin),  // Input iterator reading from std::cin\n        std::istream_iterator&lt;int&gt;(),           // End of input iterator (default constructed)\n        std::back_inserter(v)                   // Output iterator to insert into vector v\n    );\n\n    // Output the contents of the vector to standard output\n    std::copy(\n        v.begin(),                             // Beginning of the vector\n        v.end(),                               // End of the vector\n        std::ostream_iterator&lt;int&gt;(std::cout) // Output iterator writing to std::cout\n    );\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/strings/","title":"Strings","text":"<pre><code>#include &lt;algorithm&gt; // for std::reverse\n#include &lt;cctype&gt;    // for std::isupper and std::tolower\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// Function to reverse specified words in the sentences\nstd::vector&lt;std::string&gt; reverseWords(const std::vector&lt;std::string&gt; &amp;sentences,\n                                      const std::vector&lt;std::string&gt; &amp;words) {\n    vector&lt;string&gt; result = sentences;\n\n    for (size_t i = 0; i &lt; sentences.size(); ++i) {\n        string &amp;sentence = result[i];\n        const string &amp;word = words[i];\n\n        // Reverse the word\n        string reversed_word = word;\n        reverse(reversed_word.begin(), reversed_word.end());\n\n        size_t pos = 0;\n        while ((pos = sentence.find(word, pos)) != std::string::npos) {\n            // Replace the word with its reversed version\n            sentence.replace(pos, word.length(), reversed_word);\n            pos += reversed_word.length(); // Move past the new substring\n        }\n    }\n\n    return result;\n}\n\n// Function to reverse words and handle capitalization\nstd::vector&lt;std::string&gt; reverseWordsWithCapitalization(const std::vector&lt;std::string&gt; &amp;sentences,\n                                                        const std::vector&lt;std::string&gt; &amp;words) {\n    vector&lt;string&gt; result = sentences;\n\n    for (size_t i = 0; i &lt; sentences.size(); ++i) {\n        string &amp;sentence = result[i];\n        const string &amp;word = words[i];\n\n        // Reverse the word\n        string reversed_word = word;\n        reverse(reversed_word.begin(), reversed_word.end());\n\n        // Create a capitalized version of the word\n        string capitalized_word = word;\n        capitalized_word[0] = toupper(capitalized_word[0]);\n\n        size_t pos = 0;\n        while ((pos = sentence.find(word, pos)) != std::string::npos) {\n            // Reset the first letter of the reversed word for each occurrence\n            reversed_word[0] = std::isupper(sentence[pos]) ? std::toupper(reversed_word[0])\n                                                           : std::tolower(reversed_word[0]);\n\n            // Replace the word with its reversed version\n            sentence.replace(pos, word.length(), reversed_word);\n            pos += reversed_word.length(); // Move past the new substring\n        }\n\n        pos = 0;\n        while ((pos = sentence.find(capitalized_word, pos)) != std::string::npos) {\n            // Reset the first letter of the reversed word for each occurrence\n            reversed_word[0] = std::isupper(sentence[pos]) ? std::toupper(reversed_word[0])\n                                                           : std::tolower(reversed_word[0]);\n\n            // Replace the word with its reversed version\n            sentence.replace(pos, capitalized_word.length(), reversed_word);\n            pos += reversed_word.length(); // Move past the new substring\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Example sentences and words\n    vector&lt;string&gt; sentences = {\"Hello world\", \"C++ is fun\"};\n    vector&lt;string&gt; words = {\"world\", \"fun\"};\n\n    // Call the first function\n    vector&lt;string&gt; reversed_sentences = reverseWords(sentences, words);\n    cout &lt;&lt; \"Reversed words output:\\n\";\n    for (const auto &amp;sentence : reversed_sentences) {\n        cout &lt;&lt; sentence &lt;&lt; endl;\n    }\n\n    // Call the second function\n    vector&lt;string&gt; capitalized_reversed_sentences =\n        reverseWordsWithCapitalization(sentences, words);\n    cout &lt;&lt; \"\\nCapitalized reversed words output:\\n\";\n    for (const auto &amp;sentence : capitalized_reversed_sentences) {\n        cout &lt;&lt; sentence &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"examples/time/","title":"Time","text":"<pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstd::string time_adder(std::string time, int seconds) {\n    std::string item;\n    std::stringstream ss(time);\n    /*\n     * params\n     */\n    while (std::getline(ss, item, ':')) {\n        std::vector&lt;int&gt; time_parts;\n        time_parts.push_back(std::stoi(item));\n    }\n\n    int seconds_since_start = time_parts[0] * 3600 + time_parts[1] * 60 + time_parts[2];\n    int total_seconds = (seconds_since_start + seconds) % (24 * 3600);\n    int hours = total_seconds / 3600;\n    total_seconds %= 3600;\n    int minutes = total_seconds / 60;\n    seconds = total_seconds % 60;\n\n    std::ostringstream os;\n    os &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; hours &lt;&lt; \":\" &lt;&lt; std::setw(2) &lt;&lt; minutes &lt;&lt; \":\"\n       &lt;&lt; std::setw(2) &lt;&lt; seconds;\n    return os.str();\n}\n\n/*\n * @brief Add seconds to a vector of time points\n * @param timePoints A vector of strings representing time points in the format \"HH:MM:SS\"\n * @param seconds The number of seconds to add to each time point\n * @return A vector of strings representing the new time points in the same format\n */\nstd::vector&lt;std::string&gt; add_seconds_to_times(const std::vector&lt;std::string&gt; &amp;timePoints,\n                                              int seconds) {\n    std::vector&lt;std::string&gt; result;\n    std::vector&lt;int&gt; time_parts;\n    std::string item;\n\n    for (auto time : timePoints) {\n        std::istringstream iss(time);\n\n        while (std::getline(iss, item, ':')) {\n            time_parts.push_back(std::stoi(item));\n        }\n        // now we have h/m/s in time_parts[0/1/2]\n        // now we do time math.\n        // convert to seconds\n        const int SECONDS_IN_DAY = 24 * 60 * 60;\n        int seconds_since_start = time_parts[0] * 3600 + time_parts[1] * 60 + time_parts[2];\n        int total_seconds = (seconds_since_start + seconds) % SECONDS_IN_DAY;\n        // convert back to h/m/s and add to resu\n        std::ostringstream os;\n        os &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; total_seconds / 3600 &lt;&lt; \":\" &lt;&lt; std::setw(2)\n           &lt;&lt; (total_seconds % 3600) / 60 &lt;&lt; \":\" &lt;&lt; std::setw(2) &lt;&lt; total_seconds % 60;\n        result.push_back(os.str());\n    }\n    return result;\n}\n\n/* @brief given three ints, HH, MM, SS, return the number of seconds since midnight\n * @param hours The number of hours since midnight\n * @param minutes The number of minutes since midnight\n * @param seconds The number of seconds since midnight\n * @return The number of seconds since midnight\n */\nint seconds_since_midnight(int hours, int minutes, int seconds) {\n    return hours * 3600 + minutes * 60 + seconds;\n}\n\n/* @brief given a number of seconds, return a string in the format \"HH:MM:SS\"\n * @param seconds The number of seconds\n * @return A string in the format \"HH:MM:SS\"\n */\nstring sec2time(int seconds) {\n    int hours = seconds / 3600;\n    seconds %= 3600;\n    int minutes = seconds / 60;\n    seconds %= 60;\n    std::ostringstream os;\n    os &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; hours &lt;&lt; \":\" &lt;&lt; std::setw(2) &lt;&lt; minutes &lt;&lt; \":\"\n       &lt;&lt; std::setw(2) &lt;&lt; seconds;\n    return os.str();\n}\n\nvector&lt;int&gt; time2sec(const string &amp;time) {\n    vector&lt;int&gt; time_parts;\n    string item;\n    std::istringstream iss(time);\n    while (std::getline(iss, item, ':')) {\n        time_parts.push_back(std::stoi(item));\n    }\n    return time_parts;\n}\n\nint timePeriodLength(const std::string &amp;timePeriod) {\n    string t1, t2;\n    // split the string into two times HH:MM:SS - HH:MM:SS\n    istringstream iss(timePeriod);\n    // Use getline to extract the start and end times\n\n    std::getline(iss, t1, '-');\n    std::getline(iss, t2); // now we hve two swtings t1 and t2\n    // convert the two times to seconds\n\n    // Trim any leading or trailing spaces\n    t1.erase(0, t1.find_first_not_of(' '));\n    t1.erase(t1.find_last_not_of(' ') + 1);\n    t2.erase(0, t2.find_first_not_of(' '));\n    t2.erase(t2.find_last_not_of(' ') + 1);\n\n    // split the two times into hours, minutes, and seconds\n    vector&lt;int&gt; time_parts1 = time2sec(t1);\n    vector&lt;int&gt; time_parts2 = time2sec(t2);\n    // calculate the difference\n    return abs(seconds_since_midnight(time_parts1[0], time_parts1[1], time_parts1[2]) -\n               seconds_since_midnight(time_parts2[0], time_parts2[1], time_parts2[2])) /\n           60;\n}\n\nd #include&lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\n    int timePeriodLength(const std::string &amp;timePeriod) {\n    int startHour, startMinute, startSecond, endHour, endMinute, endSecond;\n    char dummy;\n    std::istringstream iss(timePeriod);\n    std::string start, end;\n    std::getline(iss, start, '-');\n    std::getline(iss, end);\n\n    // Trim spaces\n    start.erase(0, start.find_first_not_of(' '));\n    start.erase(start.find_last_not_of(' ') + 1);\n    end.erase(0, end.find_first_not_of(' '));\n    end.erase(end.find_last_not_of(' ') + 1);\n\n    // Parse start time\n    std::istringstream(start) &gt;&gt; startHour &gt;&gt; dummy &gt;&gt; startMinute &gt;&gt; dummy &gt;&gt; startSecond;\n    // Parse end time\n    std::istringstream(end) &gt;&gt; endHour &gt;&gt; dummy &gt;&gt; endMinute &gt;&gt; dummy &gt;&gt; endSecond;\n\n    // Calculate total seconds since midnight for both times\n    int startSeconds = startHour * 3600 + startMinute * 60 + startSecond;\n    int endSeconds = endHour * 3600 + endMinute * 60 + endSecond;\n\n    // Calculate the difference in minutes\n    int diffMinutes = (endSeconds - startSeconds) / 60;\n\n    return diffMinutes;\n}\n</code></pre>"},{"location":"examples/transposition/","title":"Transposition","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;std::vector&lt;int&gt;&gt; transformMatrix(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;matrix) {\n    int rows = matrix.size();\n    int cols = rows &gt; 0 ? matrix[0].size() : 0;\n    std::vector&lt;std::vector&lt;int&gt;&gt; result(cols, std::vector&lt;int&gt;(rows, 0));\n\n    for (int i = 0; i &lt; rows; ++i) {\n        for (int j = 0; j &lt; cols; ++j) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Initial matrix (2D vector)\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {{1, 2, 3}, {4, 5, 6}};\n\n    // Call our function on the matrix and output the result\n    std::vector&lt;std::vector&lt;int&gt;&gt; transposed = transformMatrix(matrix);\n    for (const auto &amp;row : transposed) {\n        for (int elem : row) {\n            std::cout &lt;&lt; elem &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"modern-cpp-features/","title":"C++20/17/14/11","text":""},{"location":"modern-cpp-features/#overview","title":"Overview","text":"<p>C++20 includes the following new language features:</p> <ul> <li>coroutines</li> <li>concepts</li> <li>designated initializers</li> <li>template syntax for lambdas</li> <li>range-based for loop with initializer</li> <li>[[likely]] and [[unlikely]] attributes</li> <li>deprecate implicit capture of this</li> <li>class types in non-type template parameters</li> <li>constexpr virtual functions</li> <li>explicit(bool)</li> <li>immediate functions</li> <li>using enum</li> <li>lambda capture of parameter pack</li> <li>char8_t</li> <li>constinit</li> </ul> <p>C++20 includes the following new library features:</p> <ul> <li>concepts library</li> <li>synchronized buffered outputstream</li> <li>std::span</li> <li>bit operations</li> <li>math constants</li> <li>std::is_constant_evaluated</li> <li>std::make_shared supports arrays</li> <li>starts_with and ends_with on strings</li> <li>check if associative container has element</li> <li>std::bit_cast</li> <li>std::midpoint</li> <li>std::to_array</li> </ul> <p>C++17 includes the following new language features:</p> <ul> <li>template argument deduction for class templates</li> <li>declaring non-type template parameters with auto</li> <li>folding expressions</li> <li>new rules for auto deduction from braced-init-list</li> <li>constexpr lambda</li> <li>lambda capture this by value</li> <li>inline variables</li> <li>nested namespaces</li> <li>structured bindings</li> <li>selection statements with initializer</li> <li>constexpr if</li> <li>utf-8 character literals</li> <li>direct-list-initialization of enums</li> <li>[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes</li> <li>__has_include</li> <li>class template argument deduction</li> </ul> <p>C++17 includes the following new library features:</p> <ul> <li>std::variant</li> <li>std::optional</li> <li>std::any</li> <li>std::string_view</li> <li>std::invoke</li> <li>std::apply</li> <li>std::filesystem</li> <li>std::byte</li> <li>splicing for maps and sets</li> <li>parallel algorithms</li> <li>std::sample</li> <li>std::clamp</li> <li>std::reduce</li> <li>prefix sum algorithms</li> <li>gcd and lcm</li> <li>std::not_fn</li> <li>string conversion to/from numbers</li> </ul> <p>C++14 includes the following new language features:</p> <ul> <li>binary literals</li> <li>generic lambda expressions</li> <li>lambda capture initializers</li> <li>return type deduction</li> <li>decltype(auto)</li> <li>relaxing constraints on constexpr functions</li> <li>variable templates</li> <li>[[deprecated]] attribute</li> </ul> <p>C++14 includes the following new library features:</p> <ul> <li>user-defined literals for standard library types</li> <li>compile-time integer sequences</li> <li>std::make_unique</li> </ul> <p>C++11 includes the following new language features:</p> <ul> <li>move semantics</li> <li>variadic templates</li> <li>rvalue references</li> <li>forwarding references</li> <li>initializer lists</li> <li>static assertions</li> <li>auto</li> <li>lambda expressions</li> <li>decltype</li> <li>type aliases</li> <li>nullptr</li> <li>strongly-typed enums</li> <li>attributes</li> <li>constexpr</li> <li>delegating constructors</li> <li>user-defined literals</li> <li>explicit virtual overrides</li> <li>final specifier</li> <li>default functions</li> <li>deleted functions</li> <li>range-based for loops</li> <li>special member functions for move semantics</li> <li>converting constructors</li> <li>explicit conversion functions</li> <li>inline-namespaces</li> <li>non-static data member initializers</li> <li>right angle brackets</li> <li>ref-qualified member functions</li> <li>trailing return types</li> <li>noexcept specifier</li> <li>char32_t and char16_t</li> <li>raw string literals</li> </ul> <p>C++11 includes the following new library features:</p> <ul> <li>std::move</li> <li>std::forward</li> <li>std::thread</li> <li>std::to_string</li> <li>type traits</li> <li>smart pointers</li> <li>std::chrono</li> <li>tuples</li> <li>std::tie</li> <li>std::array</li> <li>unordered containers</li> <li>std::make_shared</li> <li>std::ref</li> <li>memory model</li> <li>std::async</li> <li>std::begin/end</li> </ul>"},{"location":"modern-cpp-features/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"modern-cpp-features/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation:</p> <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> <p>The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited:</p> <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> <p>In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value:</p> <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"modern-cpp-features/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form:</p> <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> <p>where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety.</p> <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> <p>There are a variety of syntactic forms for enforcing concepts:</p> <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> <p>The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression:</p> <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> <p>Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> <ul> <li>Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</li> </ul> <pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> <ul> <li>Compound requirements - an expression in braces followed by a trailing return type or type constraint.</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> <ul> <li>Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> <p>See also: concepts library.</p>"},{"location":"modern-cpp-features/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized.</p> <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre>"},{"location":"modern-cpp-features/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions.</p> <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre>"},{"location":"modern-cpp-features/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem.</p> <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre>"},{"location":"modern-cpp-features/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed.</p> <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed.</p> <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre> <p>It can also be applied to the substatement (body) of an iteration statement.</p> <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre>"},{"location":"modern-cpp-features/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>.</p> <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre>"},{"location":"modern-cpp-features/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration.</p> <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre>"},{"location":"modern-cpp-features/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa.</p> <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre>"},{"location":"modern-cpp-features/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>.</p> <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre>"},{"location":"modern-cpp-features/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>.</p> <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre>"},{"location":"modern-cpp-features/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before:</p> <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> <p>After:</p> <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre>"},{"location":"modern-cpp-features/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value:</p> <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> <p>Capture parameter packs by reference:</p> <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre>"},{"location":"modern-cpp-features/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings.</p> <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre>"},{"location":"modern-cpp-features/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time.</p> <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre>"},{"location":"modern-cpp-features/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"modern-cpp-features/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts:</p> <ul> <li><code>same_as</code> - specifies two types are the same.</li> <li><code>derived_from</code> - specifies that a type is derived from another type.</li> <li><code>convertible_to</code> - specifies that a type is implicitly convertible to another type.</li> <li><code>common_with</code> - specifies that two types share a common type.</li> <li><code>integral</code> - specifies that a type is an integral type.</li> <li><code>default_constructible</code> - specifies that an object of a type can be default-constructed.</li> </ul> <p>Comparison concepts:</p> <ul> <li><code>boolean</code> - specifies that a type can be used in Boolean contexts.</li> <li><code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</li> </ul> <p>Object concepts:</p> <ul> <li><code>movable</code> - specifies that an object of a type can be moved and swapped.</li> <li><code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped.</li> <li><code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed.</li> <li><code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</li> </ul> <p>Callable concepts:</p> <ul> <li><code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types.</li> <li><code>predicate</code> - specifies that a callable type is a Boolean predicate.</li> </ul> <p>See also: concepts.</p>"},{"location":"modern-cpp-features/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output).</p> <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre>"},{"location":"modern-cpp-features/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers.</p> <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span.</p> <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre>"},{"location":"modern-cpp-features/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount.</p> <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre>"},{"location":"modern-cpp-features/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header.</p> <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre>"},{"location":"modern-cpp-features/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context.</p> <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre>"},{"location":"modern-cpp-features/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"modern-cpp-features/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string.</p> <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre>"},{"location":"modern-cpp-features/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom.</p> <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre>"},{"location":"modern-cpp-features/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another.</p> <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre>"},{"location":"modern-cpp-features/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow).</p> <pre><code>std::midpoint(1, 3); // == 2\n</code></pre>"},{"location":"modern-cpp-features/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>.</p> <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre>"},{"location":"modern-cpp-features/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"modern-cpp-features/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors.</p> <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre>"},{"location":"modern-cpp-features/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:</p> <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> <p>* - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"modern-cpp-features/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator.</p> <ul> <li>An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds.</li> <li>An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both.</li> </ul> <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre>"},{"location":"modern-cpp-features/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>.</p> <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre>"},{"location":"modern-cpp-features/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>.</p> <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre>"},{"location":"modern-cpp-features/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference.</p> <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre>"},{"location":"modern-cpp-features/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.</p> <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file.</p> <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre>"},{"location":"modern-cpp-features/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions.</p> <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre> <p>The code above can be written like this:</p> <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre>"},{"location":"modern-cpp-features/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures.</p> <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre>"},{"location":"modern-cpp-features/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight.</p> <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre>"},{"location":"modern-cpp-features/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition.</p> <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre>"},{"location":"modern-cpp-features/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value.</p> <pre><code>char x = u8'x';\n</code></pre>"},{"location":"modern-cpp-features/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax.</p> <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre>"},{"location":"modern-cpp-features/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>.</p> <ul> <li><code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label.</li> </ul> <pre><code>switch (n) {\n  case 1:\n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre> <ul> <li><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded.</li> </ul> <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre> <ul> <li><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended.</li> </ul> <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre>"},{"location":"modern-cpp-features/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"modern-cpp-features/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments.</p> <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable:</p> <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre>"},{"location":"modern-cpp-features/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"modern-cpp-features/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless).</p> <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre>"},{"location":"modern-cpp-features/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.</p> <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre>"},{"location":"modern-cpp-features/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type.</p> <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre>"},{"location":"modern-cpp-features/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).</p> <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre>"},{"location":"modern-cpp-features/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function.</p> <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre>"},{"location":"modern-cpp-features/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments.</p> <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre>"},{"location":"modern-cpp-features/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space:</p> <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre>"},{"location":"modern-cpp-features/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations.</p> <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> <p>Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"modern-cpp-features/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another:</p> <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre> <p>Inserting an entire set:</p> <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre> <p>Inserting elements which outlive the container:</p> <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre> <p>Changing the key of a map element:</p> <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre>"},{"location":"modern-cpp-features/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"modern-cpp-features/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected.</p> <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre>"},{"location":"modern-cpp-features/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound.</p> <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre>"},{"location":"modern-cpp-features/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0.</p> <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> <p>Additionally you can specify transformations for reducers:</p> <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre>"},{"location":"modern-cpp-features/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations.</p> <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre>"},{"location":"modern-cpp-features/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM).</p> <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre>"},{"location":"modern-cpp-features/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function.</p> <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre>"},{"location":"modern-cpp-features/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>:</p> <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer:</p> <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre>"},{"location":"modern-cpp-features/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"modern-cpp-features/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>.</p> <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre>"},{"location":"modern-cpp-features/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas.</p> <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre>"},{"location":"modern-cpp-features/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked).</p> <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> <p>Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>.</p> <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> <p>Using this reference-captures can have different names than the referenced variable.</p> <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre>"},{"location":"modern-cpp-features/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible.</p> <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre>"},{"location":"modern-cpp-features/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not.</p> <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"modern-cpp-features/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc.</p> <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre>"},{"location":"modern-cpp-features/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"modern-cpp-features/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings.</p> <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre>"},{"location":"modern-cpp-features/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"modern-cpp-features/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.</p> <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre>"},{"location":"modern-cpp-features/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top:</p> <ul> <li><code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>.</li> <li><code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</li> </ul> <p>Convert an array into a tuple:</p> <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre>"},{"location":"modern-cpp-features/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons:</p> <ul> <li>Avoid having to use the <code>new</code> operator.</li> <li>Prevents code repetition when specifying the underlying type the pointer shall hold.</li> <li>Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so:</li> </ul> <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> <p>The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety:</p> <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"modern-cpp-features/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"modern-cpp-features/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"modern-cpp-features/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues:</p> <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"modern-cpp-features/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing:</p> <ul> <li><code>T&amp; &amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></li> </ul> <p><code>auto</code> type deduction with lvalues and rvalues:</p> <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre> <p>Template type parameter deduction with lvalues and rvalues:</p> <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"modern-cpp-features/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template.</p> <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments.</p> <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre>"},{"location":"modern-cpp-features/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function.</p> <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre>"},{"location":"modern-cpp-features/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time.</p> <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre>"},{"location":"modern-cpp-features/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer.</p> <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre> <p>Extremely useful for readability, especially for complicated types:</p> <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so:</p> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> <p>The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"modern-cpp-features/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists:</p> <ul> <li><code>[]</code> - captures nothing.</li> <li><code>[=]</code> - capture local objects (local variables, parameters) in scope by value.</li> <li><code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference.</li> <li><code>[this]</code> - capture <code>this</code> by reference.</li> <li><code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</li> </ul> <pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> <p>By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty).</p> <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre>"},{"location":"modern-cpp-features/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>:</p> <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"modern-cpp-features/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates.</p> <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre>"},{"location":"modern-cpp-features/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>.</p> <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre>"},{"location":"modern-cpp-features/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution.</p> <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre>"},{"location":"modern-cpp-features/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc.</p> <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre>"},{"location":"modern-cpp-features/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression.</p> <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> <p>In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time:</p> <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre> <p>Constant expressions with classes:</p> <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre>"},{"location":"modern-cpp-features/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list.</p> <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre>"},{"location":"modern-cpp-features/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit:</p> <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre> <p>String to integer conversion:</p> <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre>"},{"location":"modern-cpp-features/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error.</p> <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre>"},{"location":"modern-cpp-features/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from.</p> <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre> <p>Class cannot be inherited from.</p> <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre>"},{"location":"modern-cpp-features/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor.</p> <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre> <p>With inheritance:</p> <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre>"},{"location":"modern-cpp-features/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.</p> <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre>"},{"location":"modern-cpp-features/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements.</p> <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>:</p> <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre>"},{"location":"modern-cpp-features/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves.</p> <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre>"},{"location":"modern-cpp-features/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments.</p> <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre> <p>Note that the braced list syntax does not allow narrowing:</p> <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead:</p> <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre>"},{"location":"modern-cpp-features/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier.</p> <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre>"},{"location":"modern-cpp-features/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"modern-cpp-features/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"modern-cpp-features/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"modern-cpp-features/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"modern-cpp-features/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types.</p> <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> <p>This feature is especially useful when certain return types cannot be resolved:</p> <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> <p>In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"modern-cpp-features/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"modern-cpp-features/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings.</p> <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre>"},{"location":"modern-cpp-features/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax:</p> <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> <p>where:</p> <ul> <li><code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces.</li> <li><code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</li> </ul> <p>Example:</p> <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre>"},{"location":"modern-cpp-features/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"modern-cpp-features/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference):</p> <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre> <p>Transferring <code>std::unique_ptr</code>s:</p> <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre>"},{"location":"modern-cpp-features/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>:</p> <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor:</p> <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"modern-cpp-features/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"modern-cpp-features/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>.</p> <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre>"},{"location":"modern-cpp-features/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types.</p> <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre>"},{"location":"modern-cpp-features/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared.</p> <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe.</p> <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre>"},{"location":"modern-cpp-features/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code:</p> <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre>"},{"location":"modern-cpp-features/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>.</p> <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre>"},{"location":"modern-cpp-features/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead.</p> <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre>"},{"location":"modern-cpp-features/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting.</p> <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre>"},{"location":"modern-cpp-features/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers:</p> <ul> <li><code>unordered_set</code></li> <li><code>unordered_multiset</code></li> <li><code>unordered_map</code></li> <li><code>unordered_multimap</code></li> </ul>"},{"location":"modern-cpp-features/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons:</p> <ul> <li>Avoid having to use the <code>new</code> operator.</li> <li>Prevents code repetition when specifying the underlying type the pointer shall hold.</li> <li>It provides exception-safety. Suppose we were calling a function <code>foo</code> like so:</li> </ul> <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> <p>The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety:</p> <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> <ul> <li>Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</li> </ul> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"modern-cpp-features/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"modern-cpp-features/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"modern-cpp-features/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be:</p> <ol> <li><code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation.</li> <li><code>std::launch::async</code> Run the callable object on a new thread.</li> <li><code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</li> </ol> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"modern-cpp-features/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"modern-cpp-features/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended series of books!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> </ul>"},{"location":"modern-cpp-features/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"modern-cpp-features/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"modern-cpp-features/#license","title":"License","text":"<p>MIT</p>"},{"location":"modern-cpp-features/CONTRIBUTING/","title":"Contributing","text":"<p>Before I get started, thank you for contributing! :)</p>"},{"location":"modern-cpp-features/CONTRIBUTING/#issues","title":"Issues","text":"<p>For any typos, errors, or new feature suggestions feel free to open a new issue.</p>"},{"location":"modern-cpp-features/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":"<p>I'm not very picky about how you should contribute, but I ask that the following are met:</p> <ul> <li>Proper spelling and grammar.</li> <li>If it's a language or library feature that you can write code with, please provide an   example of its usage. An optimal submission would also include a short real-world use case for the feature.</li> <li>Keep additions/deletions of content consistent with the cheatsheet's goals (see below).</li> </ul>"},{"location":"modern-cpp-features/CONTRIBUTING/#instructions","title":"Instructions","text":"<ul> <li>Make sure the feature is in the correct C++ version file (i.e. CPP11.md, etc.).</li> <li>Make sure you've added the feature to the table of contents.</li> </ul>"},{"location":"modern-cpp-features/CONTRIBUTING/#goals","title":"Goals","text":"<p>My goal for this cheatsheet is to prefer conciseness over absolute completeness. Examples of features should be minimal: if an example is overly complicated, large, or is more of an obscure usage of the feature then it will most likely be rejected in review. The reason for this goal is to teach users what the most popular uses of these features will be, and for a more thorough investigation, to learn about those from external C++ resources.</p>"},{"location":"modern-cpp-features/CPP11/","title":"C++11","text":""},{"location":"modern-cpp-features/CPP11/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++11 includes the following new language features:</p> <ul> <li>move semantics</li> <li>variadic templates</li> <li>rvalue references</li> <li>forwarding references</li> <li>initializer lists</li> <li>static assertions</li> <li>auto</li> <li>lambda expressions</li> <li>decltype</li> <li>type aliases</li> <li>nullptr</li> <li>strongly-typed enums</li> <li>attributes</li> <li>constexpr</li> <li>delegating constructors</li> <li>user-defined literals</li> <li>explicit virtual overrides</li> <li>final specifier</li> <li>default functions</li> <li>deleted functions</li> <li>range-based for loops</li> <li>special member functions for move semantics</li> <li>converting constructors</li> <li>explicit conversion functions</li> <li>inline-namespaces</li> <li>non-static data member initializers</li> <li>right angle brackets</li> <li>ref-qualified member functions</li> <li>trailing return types</li> <li>noexcept specifier</li> <li>char32_t and char16_t</li> <li>raw string literals</li> </ul> <p>C++11 includes the following new library features:</p> <ul> <li>std::move</li> <li>std::forward</li> <li>std::thread</li> <li>std::to_string</li> <li>type traits</li> <li>smart pointers</li> <li>std::chrono</li> <li>tuples</li> <li>std::tie</li> <li>std::array</li> <li>unordered containers</li> <li>std::make_shared</li> <li>std::ref</li> <li>memory model</li> <li>std::async</li> <li>std::begin/end</li> </ul>"},{"location":"modern-cpp-features/CPP11/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"modern-cpp-features/CPP11/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"modern-cpp-features/CPP11/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues:</p> <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"modern-cpp-features/CPP11/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing:</p> <ul> <li><code>T&amp; &amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code></li> <li><code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></li> </ul> <p><code>auto</code> type deduction with lvalues and rvalues:</p> <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre> <p>Template type parameter deduction with lvalues and rvalues:</p> <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"modern-cpp-features/CPP11/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template.</p> <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments.</p> <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function.</p> <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time.</p> <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer.</p> <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre> <p>Extremely useful for readability, especially for complicated types:</p> <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so:</p> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> <p>The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"modern-cpp-features/CPP11/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists:</p> <ul> <li><code>[]</code> - captures nothing.</li> <li><code>[=]</code> - capture local objects (local variables, parameters) in scope by value.</li> <li><code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference.</li> <li><code>[this]</code> - capture <code>this</code> by reference.</li> <li><code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</li> </ul> <pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> <p>By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty).</p> <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>:</p> <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"modern-cpp-features/CPP11/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates.</p> <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>.</p> <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution.</p> <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc.</p> <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression.</p> <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> <p>In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time:</p> <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre> <p>Constant expressions with classes:</p> <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list.</p> <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit:</p> <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre> <p>String to integer conversion:</p> <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error.</p> <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from.</p> <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre> <p>Class cannot be inherited from.</p> <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor.</p> <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre> <p>With inheritance:</p> <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.</p> <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements.</p> <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>:</p> <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves.</p> <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments.</p> <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre> <p>Note that the braced list syntax does not allow narrowing:</p> <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead:</p> <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier.</p> <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types.</p> <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> <p>This feature is especially useful when certain return types cannot be resolved:</p> <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> <p>In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"modern-cpp-features/CPP11/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings.</p> <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax:</p> <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> <p>where:</p> <ul> <li><code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces.</li> <li><code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</li> </ul> <p>Example:</p> <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"modern-cpp-features/CPP11/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference):</p> <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre> <p>Transferring <code>std::unique_ptr</code>s:</p> <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>:</p> <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor:</p> <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"modern-cpp-features/CPP11/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>.</p> <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types.</p> <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared.</p> <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe.</p> <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code:</p> <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>.</p> <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead.</p> <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting.</p> <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers:</p> <ul> <li><code>unordered_set</code></li> <li><code>unordered_multiset</code></li> <li><code>unordered_map</code></li> <li><code>unordered_multimap</code></li> </ul>"},{"location":"modern-cpp-features/CPP11/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons:</p> <ul> <li>Avoid having to use the <code>new</code> operator.</li> <li>Prevents code repetition when specifying the underlying type the pointer shall hold.</li> <li>It provides exception-safety. Suppose we were calling a function <code>foo</code> like so:</li> </ul> <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> <p>The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety:</p> <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> <ul> <li>Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</li> </ul> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"modern-cpp-features/CPP11/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"modern-cpp-features/CPP11/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be:</p> <ol> <li><code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation.</li> <li><code>std::launch::async</code> Run the callable object on a new thread.</li> <li><code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</li> </ol> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"modern-cpp-features/CPP11/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"modern-cpp-features/CPP11/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"modern-cpp-features/CPP11/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"modern-cpp-features/CPP11/#license","title":"License","text":"<p>MIT</p>"},{"location":"modern-cpp-features/CPP14/","title":"C++14","text":""},{"location":"modern-cpp-features/CPP14/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++14 includes the following new language features:</p> <ul> <li>binary literals</li> <li>generic lambda expressions</li> <li>lambda capture initializers</li> <li>return type deduction</li> <li>decltype(auto)</li> <li>relaxing constraints on constexpr functions</li> <li>variable templates</li> <li>[[deprecated]] attribute</li> </ul> <p>C++14 includes the following new library features:</p> <ul> <li>user-defined literals for standard library types</li> <li>compile-time integer sequences</li> <li>std::make_unique</li> </ul>"},{"location":"modern-cpp-features/CPP14/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"modern-cpp-features/CPP14/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>.</p> <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas.</p> <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked).</p> <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> <p>Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>.</p> <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> <p>Using this reference-captures can have different names than the referenced variable.</p> <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible.</p> <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not.</p> <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"modern-cpp-features/CPP14/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc.</p> <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings.</p> <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"modern-cpp-features/CPP14/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.</p> <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top:</p> <ul> <li><code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>.</li> <li><code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</li> </ul> <p>Convert an array into a tuple:</p> <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP14/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons:</p> <ul> <li>Avoid having to use the <code>new</code> operator.</li> <li>Prevents code repetition when specifying the underlying type the pointer shall hold.</li> <li>Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so:</li> </ul> <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> <p>The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety:</p> <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"modern-cpp-features/CPP14/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"modern-cpp-features/CPP14/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"modern-cpp-features/CPP14/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"modern-cpp-features/CPP14/#license","title":"License","text":"<p>MIT</p>"},{"location":"modern-cpp-features/CPP17/","title":"C++17","text":""},{"location":"modern-cpp-features/CPP17/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++17 includes the following new language features:</p> <ul> <li>template argument deduction for class templates</li> <li>declaring non-type template parameters with auto</li> <li>folding expressions</li> <li>new rules for auto deduction from braced-init-list</li> <li>constexpr lambda</li> <li>lambda capture this by value</li> <li>inline variables</li> <li>nested namespaces</li> <li>structured bindings</li> <li>selection statements with initializer</li> <li>constexpr if</li> <li>utf-8 character literals</li> <li>direct-list-initialization of enums</li> <li>[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes</li> <li>__has_include</li> <li>class template argument deduction</li> </ul> <p>C++17 includes the following new library features:</p> <ul> <li>std::variant</li> <li>std::optional</li> <li>std::any</li> <li>std::string_view</li> <li>std::invoke</li> <li>std::apply</li> <li>std::filesystem</li> <li>std::byte</li> <li>splicing for maps and sets</li> <li>parallel algorithms</li> <li>std::sample</li> <li>std::clamp</li> <li>std::reduce</li> <li>prefix sum algorithms</li> <li>gcd and lcm</li> <li>std::not_fn</li> <li>string conversion to/from numbers</li> </ul>"},{"location":"modern-cpp-features/CPP17/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"modern-cpp-features/CPP17/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors.</p> <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:</p> <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> <p>* - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"modern-cpp-features/CPP17/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator.</p> <ul> <li>An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds.</li> <li>An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both.</li> </ul> <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>.</p> <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>.</p> <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference.</p> <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.</p> <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file.</p> <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions.</p> <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre> <p>The code above can be written like this:</p> <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures.</p> <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight.</p> <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition.</p> <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value.</p> <pre><code>char x = u8'x';\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax.</p> <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>.</p> <ul> <li><code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label.</li> </ul> <pre><code>switch (n) {\n  case 1:\n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre> <ul> <li><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded.</li> </ul> <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre> <ul> <li><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended.</li> </ul> <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments.</p> <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable:</p> <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"modern-cpp-features/CPP17/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless).</p> <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.</p> <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type.</p> <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).</p> <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function.</p> <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments.</p> <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space:</p> <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations.</p> <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> <p>Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"modern-cpp-features/CPP17/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another:</p> <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre> <p>Inserting an entire set:</p> <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre> <p>Inserting elements which outlive the container:</p> <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre> <p>Changing the key of a map element:</p> <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected.</p> <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound.</p> <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0.</p> <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> <p>Additionally you can specify transformations for reducers:</p> <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations.</p> <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM).</p> <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function.</p> <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>:</p> <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer:</p> <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre>"},{"location":"modern-cpp-features/CPP17/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"modern-cpp-features/CPP17/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"modern-cpp-features/CPP17/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"modern-cpp-features/CPP17/#license","title":"License","text":"<p>MIT</p>"},{"location":"modern-cpp-features/CPP20/","title":"C++20","text":""},{"location":"modern-cpp-features/CPP20/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++20 includes the following new language features:</p> <ul> <li>coroutines</li> <li>concepts</li> <li>designated initializers</li> <li>template syntax for lambdas</li> <li>range-based for loop with initializer</li> <li>[[likely]] and [[unlikely]] attributes</li> <li>deprecate implicit capture of this</li> <li>class types in non-type template parameters</li> <li>constexpr virtual functions</li> <li>explicit(bool)</li> <li>immediate functions</li> <li>using enum</li> <li>lambda capture of parameter pack</li> <li>char8_t</li> <li>constinit</li> </ul> <p>C++20 includes the following new library features:</p> <ul> <li>concepts library</li> <li>synchronized buffered outputstream</li> <li>std::span</li> <li>bit operations</li> <li>math constants</li> <li>std::is_constant_evaluated</li> <li>std::make_shared supports arrays</li> <li>starts_with and ends_with on strings</li> <li>check if associative container has element</li> <li>std::bit_cast</li> <li>std::midpoint</li> <li>std::to_array</li> </ul>"},{"location":"modern-cpp-features/CPP20/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"modern-cpp-features/CPP20/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation:</p> <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> <p>The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited:</p> <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> <p>In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value:</p> <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"modern-cpp-features/CPP20/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form:</p> <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> <p>where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety.</p> <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> <p>There are a variety of syntactic forms for enforcing concepts:</p> <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> <p>The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression:</p> <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> <p>Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> <ul> <li>Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</li> </ul> <pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> <ul> <li>Compound requirements - an expression in braces followed by a trailing return type or type constraint.</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> <ul> <li>Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</li> </ul> <pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> <p>See also: concepts library.</p>"},{"location":"modern-cpp-features/CPP20/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized.</p> <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions.</p> <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem.</p> <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed.</p> <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed.</p> <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre> <p>It can also be applied to the substatement (body) of an iteration statement.</p> <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>.</p> <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration.</p> <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa.</p> <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>.</p> <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>.</p> <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before:</p> <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> <p>After:</p> <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value:</p> <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> <p>Capture parameter packs by reference:</p> <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings.</p> <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time.</p> <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"modern-cpp-features/CPP20/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts:</p> <ul> <li><code>same_as</code> - specifies two types are the same.</li> <li><code>derived_from</code> - specifies that a type is derived from another type.</li> <li><code>convertible_to</code> - specifies that a type is implicitly convertible to another type.</li> <li><code>common_with</code> - specifies that two types share a common type.</li> <li><code>integral</code> - specifies that a type is an integral type.</li> <li><code>default_constructible</code> - specifies that an object of a type can be default-constructed.</li> </ul> <p>Comparison concepts:</p> <ul> <li><code>boolean</code> - specifies that a type can be used in Boolean contexts.</li> <li><code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</li> </ul> <p>Object concepts:</p> <ul> <li><code>movable</code> - specifies that an object of a type can be moved and swapped.</li> <li><code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped.</li> <li><code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed.</li> <li><code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</li> </ul> <p>Callable concepts:</p> <ul> <li><code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types.</li> <li><code>predicate</code> - specifies that a callable type is a Boolean predicate.</li> </ul> <p>See also: concepts.</p>"},{"location":"modern-cpp-features/CPP20/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output).</p> <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers.</p> <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span.</p> <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount.</p> <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header.</p> <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context.</p> <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string.</p> <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom.</p> <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another.</p> <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow).</p> <pre><code>std::midpoint(1, 3); // == 2\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>.</p> <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre>"},{"location":"modern-cpp-features/CPP20/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"modern-cpp-features/CPP20/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"modern-cpp-features/CPP20/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"modern-cpp-features/CPP20/#license","title":"License","text":"<p>MIT</p>"},{"location":"projects/cuda/","title":"CUDA","text":"<p>CUDA is a general-purpose parallel computing platform and programming model developed by NVIDIA to leverage the massive parallel processing power of GPUs. CUDA's scalable programming model uses abstractions like thread group hierarchies, shared memories, and barrier synchronization to enable fine-grained and coarse-grained parallelism, allowing programs to automatically scale across various GPU architectures, by adjusting the number of multiprocessors and memory partitions.</p>"},{"location":"projects/cuda/#cuda-c-programming","title":"CUDA C++ Programming","text":"<ul> <li><code>vector_add.cu</code></li> <li><code>matrix_mul.cu</code></li> <li><code>reduction.cu</code></li> <li><code>stream_example.cu</code></li> <li><code>unified_memory.cu</code></li> </ul>"},{"location":"projects/cuda/#further-reading","title":"Further Reading","text":"<ul> <li>CUDA Toolkit Documentation</li> <li>CUDA C++ Programming Guide</li> </ul>"},{"location":"projects/galois/","title":"Galois Field C++ library for Reed-Solomon Erasure Coding","text":"<p>Work in progress...</p>"}]}