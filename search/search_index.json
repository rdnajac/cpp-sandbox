{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++ sandbox","text":"<p>A collection of C++ code snippets and examples.</p>"},{"location":"#projects","title":"Projects","text":"<ul> <li>TCP client/server</li> <li><code>std::chrono</code></li> </ul>"},{"location":"#docs","title":"<code>docs/</code>","text":"<p>Made with Material for MkDocs</p> <pre><code>pip install -r requirements.txt\nmkdocs serve\nopen http:localhost:8000\n</code></pre> <p>[!NOTE] Each subdirectory in this repository contains a <code>README.md</code> file that is symlinked to the <code>docs/</code> directory so that the markdown is compiled into an HTML page that can be viewed in a browser with the rest of the docs.</p>"},{"location":"#resources","title":"Resources","text":"<p>There are a lot of cool guides and resources out there and I've compiled the ones I've found most helpful here and included them as a submodules in this repo so that they can be easily accessed and updated. The search plugin that comes with the Material for MkDocs theme can be used to search through all the resources at once, even if they're excluded from the nav.</p> <p>I found this cool repo called and I liked it so much, it's built along with the rest of the docs.</p>"},{"location":"#columbia-os-dev-guide","title":"Columbia OS Dev Guide","text":"<p>I took an Operating Systems class at Columbia and the TA staff wrote some really helpful guides that I found myself referring to a lot, even after graduating. They're publicly available here, but I'm unsure if this is the most up-to-date version.</p>"},{"location":"#recitations","title":"Recitations","text":"<p>I've included the recitations from the class in the resources folder. If someone from the CU CS departments finds this and wants me to take it down, please let me know.</p>"},{"location":"#vim-config","title":"vim config","text":"<p>Special shoutout to this page that sent me down a years-long rabbit hole of vim plugins and configurations.</p>"},{"location":"#c-resources","title":"C++ Resources","text":"<p>Modern C++ Features</p> <p>Access it here.</p> <p>When in doubt, check out the C++ Reference.</p>"},{"location":"a-tour-of-cpp/","title":"A Tour of C++","text":"<p>During my time at Columbia University, I had the privilege of taking Bjarne Stroustrup's course, \"Design using C++\". Now that I have graduated, I've decided to compile all of my notes into a comprehensive guide. This document serves as an easy reference to accompany the repository of code snippets and examples I have been developing.</p>"},{"location":"a-tour-of-cpp/#attribution","title":"Attribution","text":"<p>The material in this document is based on concepts and information from: Stroustrup, B. (2022). A Tour of C++ (C++ In-Depth Series) (3rd ed.). Addison-Wesley Professional.</p>"},{"location":"a-tour-of-cpp/#table-of-contents","title":"Table of Contents","text":"<ol> <li>The Basics</li> <li>User-Defined Types</li> <li>Modularity</li> <li>Error Handling</li> <li>Classes</li> <li>Essential Operations</li> <li>Templates</li> <li>Concepts and Generic Programming</li> <li>Standard-Library</li> <li>Strings and Regular Expressions</li> <li>Input and Output</li> <li>Containers</li> <li>Algorithms</li> <li>Ranges</li> <li>Pointers and Containers</li> <li>Utilities</li> <li>Numerics</li> <li>Concurrency</li> </ol>"},{"location":"a-tour-of-cpp/#the-basics","title":"The Basics","text":"<pre><code>using namespace std;    // make names from std visible without std::\n</code></pre>"},{"location":"a-tour-of-cpp/#variables","title":"Variables","text":"<p>Use <code>auto</code> to let the compiler deduce the type of a variable unless there is a specific reason to specify the type.</p> <pre><code>auto i = 7;     // i is an int\nauto d = 1.2;   // d is a double\nauto qq {true}; // qq is a bool\n</code></pre>"},{"location":"a-tour-of-cpp/#constants","title":"Constants","text":"<p>Use <code>const</code> to define a constant. Use <code>constexpr</code> for a constant expression. For example:</p> <pre><code>constexpr double square(double x) { return x*x; }\n</code></pre>"},{"location":"a-tour-of-cpp/#loops","title":"Loops","text":"<p>A \"range-<code>for</code>-statement\" traverses a sequence in the simplest way:</p> <pre><code>int v[] = {0, 1, 2, 3, 4, 5};\n\nfor (auto x : v) cout &lt;&lt; x &lt;&lt; '\\n';\n</code></pre> <p>Another example:</p> <pre><code>for (auto&amp; x : v) x *= 2;\n</code></pre>"},{"location":"a-tour-of-cpp/#user-defined-types","title":"User-Defined Types","text":"<ul> <li>Use 'class' to hide representation and provide an interface.</li> <li>Use 'struct' to group related data without hiding.</li> <li>Prefer 'enum class' over plain enums.</li> <li>Consider std::variant as a type-safe alternative to unions.</li> <li>Use user-defined literals for expressive value specification.</li> </ul>"},{"location":"a-tour-of-cpp/#structures","title":"Structures","text":"<p>Structures group related data elements:</p> <pre><code>struct DNASequence {\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    std::string source;\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#classes","title":"Classes","text":"<p>Classes extend structures by adding member functions:</p> <pre><code>class DNA {\npublic:\n    DNA(std::vector&lt;Nucleotide&gt; seq) : sequence{std::move(seq)} {}\n    void addNucleotide(Nucleotide n) { sequence.push_back(n); }\n    size_t length() const { return sequence.size(); }\nprivate:\n    std::vector&lt;Nucleotide&gt; sequence;\n};\n</code></pre> <p>Usage:</p> <pre><code>DNA dna({Nucleotide::A, Nucleotide::T, Nucleotide::G});\ndna.addNucleotide(Nucleotide::C);\nstd::cout &lt;&lt; \"DNA length: \" &lt;&lt; dna.length() &lt;&lt; '\\n';\n</code></pre> <p>Jump ahead to Classes for more information.</p>"},{"location":"a-tour-of-cpp/#enumerations","title":"Enumerations","text":"<p>Use strongly typed enumerations:</p> <pre><code>enum class Nucleotide {\n    A, // Adenine\n    T, // Thymine\n    G, // Guanine\n    C  // Cytosine\n};\n</code></pre> <p>Nucleotide base = Nucleotide::A;</p>"},{"location":"a-tour-of-cpp/#unions","title":"Unions","text":"<p>Modern C++ prefers std::variant over unions:</p> <pre><code>#include &lt;variant&gt;\n\nstd::variant&lt;DNA, std::string&gt; genetic_info;\ngenetic_info = DNA({Nucleotide::A, Nucleotide::T});\ngenetic_info = \"ATGC\";  // Now contains a string\n</code></pre>"},{"location":"a-tour-of-cpp/#user-defined-literals","title":"User-Defined Literals:/","text":"<p>Define custom literals:</p> <pre><code>DNA operator\"\"_dna(const char* seq, size_t len)\n{\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    for (size_t i = 0; i &lt; len; ++i) {\n        switch(seq[i]) {\n            case 'A': nucleotides.push_back(Nucleotide::A); break;\n            case 'T': nucleotides.push_back(Nucleotide::T); break;\n            case 'G': nucleotides.push_back(Nucleotide::G); break;\n            case 'C': nucleotides.push_back(Nucleotide::C); break;\n            default: throw std::invalid_argument(\"Invalid nucleotide\");\n        }\n    }\n    return DNA(nucleotides);\n}\n\nauto my_dna = \"ATGC\"_dna;\n</code></pre>"},{"location":"a-tour-of-cpp/#type-aliases","title":"Type Aliases","text":"<p>Use 'using' for type aliases:</p> <p>using DNAStrand = std::vector; <p>[!NOTE] I don't like using these in C because they obscure the type of the variable. However, I don't have enough experience with C++ to know if if this is best practice.</p>"},{"location":"a-tour-of-cpp/#modularity","title":"Modularity","text":"<p>Declarations (interfaces, .h, .hpp) and definitions (implementations, .c, .cpp) should be separate. Where modules are supported (C++20), use them!</p> <p>[!TIP] Header files should emphasize logical structure.</p>"},{"location":"a-tour-of-cpp/#namespaces","title":"Namespaces","text":"<p>Namespaces help prevent name collisions and organize code:</p> <pre><code>namespace genetics {\n    class DNA { /* ... */ };\n    class RNA { /* ... */ };\n}\n\n// Use with qualification\ngenetics::DNA myDNA;\n\n// Or bring specific names into scope\nusing genetics::RNA;\nRNA myRNA;\n\n// Avoid bringing entire namespaces into global scope\n// using namespace genetics; // Not recommended\n</code></pre> <p>Use namespaces to group related functionality and avoid polluting the global namespace.</p>"},{"location":"a-tour-of-cpp/#modules","title":"Modules","text":"<p>Modules (C++20) offer better encapsulation and faster compilation than header files:</p> <pre><code>// genetics.ixx\nexport module genetics;\n\nexport class DNA { /* ... */ };\nexport class RNA { /* ... */ };\n\n// Not exported, internal to module\nclass Ribosome { /* ... */ };\n</code></pre> <p>Usage:</p> <pre><code>import genetics;\ngenetics::DNA myDNA;\n</code></pre> <p>Benefits:</p> <ul> <li>Faster compilation (parsed once, not per translation unit)</li> <li>No need for include guards</li> <li>Better control over what's exported</li> <li>Fewer macro-related issues</li> </ul>"},{"location":"a-tour-of-cpp/#error-handling","title":"Error Handling","text":""},{"location":"a-tour-of-cpp/#exceptions","title":"Exceptions","text":"<p>You can throw custon exceptions after defining a class derived from std::exception. For example:</p> <pre><code>class BadLengthException : public std::exception {\nprivate:\n    int length;\n    std::string message;\n\npublic:\n    BadLengthException(int len) : length(len) {\n        message = std::to_string(length);\n    }\n\n    const char* what() const noexcept override {\n        return message.c_str();\n    }\n};\n</code></pre> <ul> <li>invariants</li> <li>error-handling alternatives</li> <li>assertions</li> </ul>"},{"location":"a-tour-of-cpp/#classes_1","title":"Classes","text":"<p>Three important kinds of C++ classes are:</p> <ul> <li>concrete types</li> <li>abstract types</li> <li>virtual functions</li> </ul>"},{"location":"a-tour-of-cpp/#concrete-types","title":"Concrete Types","text":"<p>They behave \"just like built-in types.\"!</p>"},{"location":"a-tour-of-cpp/#classical-user-defined-arithmetic-type","title":"Classical user-defined arithmetic type","text":"<pre><code>class complex {\n    double re, im; // representation: two doubles\npublic:\n    complex(double r, double i) :re{r}, im{i} {}    // construct complex from two scalars\n    complex(double r) :re{r}, im{0} {}              // construct complex from one scalar\n    complex() :re{0}, im{0} {}                      // default complex: {0,0}\n    complex(complex z) :re{z.re}, im{z.im} {}       // copy constructor\n\n    double real() const { return re; }\n    void real(double d) { re=d; }\n    double imag() const { return im; }\n    void imag(double d) { im=d; }\n\n    complex&amp; operator+=(complex z)\n    {\n        re+=z.re;       // add to re and im\n        im+=z.im;\n        return *this;   // return the result\n    }\n\n    complex&amp; operator-=(complex z)\n    {\n        re-=z.re;\n        im-=z.im;\n        return *this;\n    }\n\n    complex&amp; operator*=(complex); // defined out-of-class somewhere\n    complex&amp; operator/=(complex); // defined out-of-class somewhere\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#abstract-types","title":"Abstract Types","text":"<p>Insulates the user from implementation details by decoupling the interface from the representation.</p> <p>Since we don\u2019t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store and access them through references or pointers.</p> <pre><code>class Container {\npublic:\n    virtual double&amp; operator[](int) = 0;    // pure virtual function\n    virtual int size() const = 0;           // const member function\n    virtual  \u0303Container() {}                 // destructor\n\n    // const member function  // destructor (\u00a75.2.2)\n};\n</code></pre> <p>[!NOTE] The curious <code>=0</code> syntax says the function is pure virtual; that is, some class derived from Container must define the function.</p>"},{"location":"a-tour-of-cpp/#heirarchies","title":"Heirarchies","text":"<p>Syntax:</p> <pre><code>class Vector_container : public Container {\n    std::vector&lt;double&gt; v;\n    public:\n    double&amp; operator[](int i) override { return v[i]; }\n    int size() const override { return v.size(); }\n};\n</code></pre> <p>[!NOTE] We use override to indicate that we are overriding a virtual function.</p>"},{"location":"a-tour-of-cpp/#essential-operations","title":"Essential Operations","text":""},{"location":"a-tour-of-cpp/#copy-and-move","title":"Copy and Move","text":"<pre><code>class Vector {\npublic:\n    Vector(const Vector&amp; a);              // copy constructor\n    Vector&amp; operator=(const Vector&amp; a);   // copy assignment\n\n    Vector(Vector&amp;&amp; a);                   // move constructor\n    Vector&amp; operator=(Vector&amp;&amp; a);        // move assignment\n};\n\nVector::Vector(const Vector&amp; a)           // copy constructor\n    :elem{new double[a.sz]},              // allocate space for elements\n     sz{a.sz}\n{\n    for (int i=0; i!=sz; ++i)             // copy elements\n        elem[i] = a.elem[i];\n}\n\nVector::Vector(Vector&amp;&amp; a)                // move constructor\n    :elem{a.elem},                        // \"grab the elements\" from a\n     sz{a.sz}\n{\n    a.elem = nullptr;                     // now a has no elements\n    a.sz = 0;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#resource-management","title":"Resource Management","text":"<pre><code>template&lt;typename T&gt;\nclass Vector {\nprivate:\n    T* elem;   // elem points to an array of sz elements of type T\n    int sz;\npublic:\n    Vector(int s) :elem{new T[s]}, sz{s}  // constructor: acquire resources\n    {\n        for (int i=0; i!=s; ++i)          // initialize elements\n            elem[i] = T{};\n    }\n    ~Vector() { delete[] elem; }          // destructor: release resources\n    // ... copy and move operations ...\n};\n</code></pre>"},{"location":"a-tour-of-cpp/#operator-overloading","title":"Operator Overloading","text":"<pre><code>complex&amp; complex::operator+=(complex z)\n{\n    re+=z.re;    // add to the real part\n    im+=z.im;    // add to the imaginary part\n    return *this;\n}\n\ncomplex operator+(complex a, complex b)\n{\n    return a+=b;\n}\n// and so on...\n</code></pre>"},{"location":"a-tour-of-cpp/#conventional-operations","title":"Conventional Operations","text":"<pre><code>class Vector {\npublic:\n    T&amp; operator[](int i) { return elem[i]; }              // for non-const Vectors\n    const T&amp; operator[](int i) const { return elem[i]; }  // for const Vectors\n    int size() const { return sz; }\n};\n\nbool operator==(const Vector&amp; a, const Vector&amp; b)\n{\n    if (a.size() != b.size()) return false;\n    for (int i=0; i!=a.size(); ++i)\n        if (a[i]!=b[i]) return false;\n    return true;\n}\n\nbool operator!=(const Vector&amp; a, const Vector&amp; b)\n{\n    return !(a==b);\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#user-defined-literals_1","title":"User-Defined Literals","text":"<pre><code>constexpr complex&lt;double&gt; operator\"\"i(long double d)\n{\n    return {0,d};  // complex is a literal type\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#templates","title":"Templates","text":"<p><code>&lt;T&gt;</code></p>"},{"location":"a-tour-of-cpp/#parameterized-types","title":"Parameterized Types","text":"<pre><code>template&lt;typename T&gt;\nclass Vector {\nprivate:\n    T* elem;   // elem points to an array of sz elements of type T\n    int sz;\npublic:\n    explicit Vector(int s);\n    ~Vector() { delete[] elem; }\n\n    // ... copy and move operations ...\n\n    T&amp; operator[](int i);\n    const T&amp; operator[](int i) const;\n    int size() const { return sz; }\n};\n\nVector&lt;char&gt; vc(200);          // vector of 200 characters\nVector&lt;string&gt; vs(17);         // vector of 17 strings\nVector&lt;list&lt;int&gt;&gt; vli(45);     // vector of 45 lists of integers\n</code></pre>"},{"location":"a-tour-of-cpp/#parameterized-operations","title":"Parameterized Operations","text":"<pre><code>template&lt;typename Container, typename Value&gt;\nValue sum(const Container&amp; c, Value v)\n{\n    for (auto x : c)\n        v += x;\n    return v;\n}\n\nvoid user(Vector&lt;int&gt;&amp; vi, std::list&lt;double&gt;&amp; ld, std::vector&lt;complex&lt;double&gt;&gt;&amp; vc)\n{\n    int x = sum(vi,0);              // the sum of a vector of ints (add ints)\n    double d = sum(vi,0.0);         // the sum of a vector of ints (add doubles)\n    double dd = sum(ld,0.0);        // the sum of a list of doubles\n    auto z = sum(vc,complex{0.0});  // the sum of a vector of complex&lt;double&gt;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#template-mechanisms","title":"Template Mechanisms","text":"<pre><code>// Variable templates\ntemplate&lt;typename T&gt;\nconstexpr T pi = T{3.1415926535897932385};  // variable template\n\n// Template aliases\ntemplate&lt;typename Value&gt;\nusing String_map = Map&lt;string,Value&gt;;  // Map is some map template\n\nString_map&lt;int&gt; m;  // m is a Map&lt;string,int&gt;\n\n// Variadic templates\ntemplate&lt;typename T, typename... Tail&gt;\nvoid print(T head, Tail... tail)\n{\n    cout &lt;&lt; head &lt;&lt; ' ';\n    if constexpr(sizeof...(tail) &gt; 0)\n        print(tail...);\n}\n\nprint(42, \"hello\", 3.14, \"world\");\n\n// Fold expressions\ntemplate&lt;typename... T&gt;\nint sum(T... v)\n{\n    return (v + ... + 0);  // add all elements of v starting with 0\n}\n\nint x = sum(1, 2, 3, 4, 5);  // x becomes 15\n</code></pre>"},{"location":"a-tour-of-cpp/#concepts-and-generic-programming","title":"Concepts and Generic Programming","text":""},{"location":"a-tour-of-cpp/#concepts","title":"Concepts","text":"<p>Concepts define requirements on template arguments, enabling better error messages and overload resolution.</p> <pre><code>template&lt;typename T&gt;\nconcept Arithmetic = requires(T x, T y) {\n    { x + y } -&gt; std::convertible_to&lt;T&gt;;\n    { x - y } -&gt; std::convertible_to&lt;T&gt;;\n    { x * y } -&gt; std::convertible_to&lt;T&gt;;\n    { x / y } -&gt; std::convertible_to&lt;T&gt;;\n};\n\ntemplate&lt;Arithmetic T&gt;\nT sum(std::vector&lt;T&gt; const&amp; v) {\n    T result = 0;\n    for (auto const&amp; z : v) result += z;\n    return result;\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#generic-programming","title":"Generic Programming","text":"<p>Generic programming allows writing algorithms that work with any type satisfying certain requirements.</p> <pre><code>template&lt;typename Iter, typename T&gt;\nIter find(Iter first, Iter last, const T&amp; value) {\n    while (first != last &amp;&amp; *first != value) ++first;\n    return first;\n}\n\nstd::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\nauto it = find(v.begin(), v.end(), 3);\n</code></pre>"},{"location":"a-tour-of-cpp/#variadic-templates","title":"Variadic Templates","text":"<p>Variadic templates allow functions and classes to accept any number of arguments of any type.</p> <pre><code>template&lt;typename T&gt;\nvoid print(T arg) {\n    std::cout &lt;&lt; arg &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename T, typename... Args&gt;\nvoid print(T first, Args... rest) {\n    std::cout &lt;&lt; first &lt;&lt; ' ';\n    print(rest...);\n}\n\nprint(1, \"hello\", 3.14);\n</code></pre>"},{"location":"a-tour-of-cpp/#template-compilation-model","title":"Template Compilation Model","text":"<p>Templates are compiled when instantiated, which happens in the translation unit where they are used. This requires template definitions to be available in headers.</p> <pre><code>// mylibrary.h\ntemplate&lt;typename T&gt;\nT square(T x) { return x * x; }\n\n// main.cpp\n#include \"mylibrary.h\"\nint main() {\n    auto result = square(5);\n}\n</code></pre>"},{"location":"a-tour-of-cpp/#standard-library","title":"Standard-Library","text":"<p>Provides the most common fundamental data structures together with the fundamental algorithms used on them.</p> <p>[!TIP] There are no standard library modules for C++20, but check out Make Your Own <code>module std</code> for a workaround.</p>"},{"location":"a-tour-of-cpp/#strings-and-regular-expressions","title":"Strings and Regular Expressions","text":"<ul> <li>strings</li> <li>string views</li> <li>regular expressions</li> </ul>"},{"location":"a-tour-of-cpp/#input-and-output","title":"Input and Output","text":"<ul> <li>state</li> <li>user-defined types</li> <li>formatting</li> <li>streams</li> <li>c-style</li> <li>file system</li> </ul>"},{"location":"a-tour-of-cpp/#containers","title":"Containers","text":""},{"location":"a-tour-of-cpp/#vector","title":"vector","text":""},{"location":"a-tour-of-cpp/#insert","title":"insert","text":"<p>Insert expects an iterator and a value to insert:</p> <pre><code>v.insert(v.begin() + 2, 5); // insert 5 at position 2\n</code></pre> <p>Use <code>v.begin()</code> to get an iterator to the beginning of the vector, then add an offset to get the desired position.</p>"},{"location":"a-tour-of-cpp/#append-to-end","title":"append to end","text":"<p>Use <code>push_back</code> to append to the end of a vector:</p> <pre><code>v.push_back(7);\n</code></pre>"},{"location":"a-tour-of-cpp/#find-and-insert-after","title":"find and insert after","text":"<p>Use <code>std::find</code> to find a value in a vector:</p> <pre><code>auto it = std::find(v.begin(), v.end(), 5);\nif (it != v.end()) {\n    v.insert(it + 1, 6);\n}\n</code></pre> <ul> <li><code>list</code></li> <li><code>forward_list</code></li> <li><code>map</code></li> <li><code>unordered_map</code></li> <li>allocators</li> <li>container overview</li> </ul>"},{"location":"a-tour-of-cpp/#algorithms","title":"Algorithms","text":""},{"location":"a-tour-of-cpp/#iterators","title":"Iterators","text":"<p>Example:</p> <ul> <li>use of predicates</li> <li>algorithm overview</li> <li>parallel algorithms</li> </ul>"},{"location":"a-tour-of-cpp/#ranges","title":"Ranges","text":"<ul> <li>views</li> <li>generators</li> <li>pipelines</li> <li>concepts overview</li> </ul>"},{"location":"a-tour-of-cpp/#pointers-and-containers","title":"Pointers and Containers","text":"<ul> <li>pointers</li> <li>containers</li> <li>alternatives</li> </ul>"},{"location":"a-tour-of-cpp/#utilities","title":"Utilities","text":"<ul> <li>time</li> <li>function adaption</li> <li>type functions</li> <li><code>source_location</code></li> <li><code>move()</code> and <code>forward()</code></li> <li>bit manipulation</li> </ul>"},{"location":"a-tour-of-cpp/#numerics","title":"Numerics","text":"<ul> <li>mathematical functions</li> <li>numerical algorithms</li> <li>complex numbers</li> <li>random numbers</li> <li>vector arithmetic</li> <li>numeric limits</li> <li>mathematical constants</li> </ul>"},{"location":"a-tour-of-cpp/#concurrency","title":"Concurrency","text":"<ul> <li>tasks and <code>thread</code>s</li> <li>sharing data</li> <li>waiting for events</li> <li>communicating tasks</li> <li>coroutines</li> </ul>"},{"location":"advprog/","title":"Advanced Programming","text":"<p>Exercises and examples from the Advanced Programming course at Columbia University. Originally written in C, rewritten in C++.</p>"},{"location":"advprog/#bitmask","title":"Bitmask","text":"<p>This program demonstrates the use of bitmasks in C++.</p>"},{"location":"advprog/#references","title":"References","text":"<ul> <li>Jae's class</li> <li>cppreference.com</li> <li>GeeksforGeeks</li> <li>Bitmask in C++</li> </ul>"},{"location":"cuda/","title":"CUDA","text":"<p>CUDA is a general-purpose parallel computing platform and programming model developed by NVIDIA to leverage the massive parallel processing power of GPUs. It allows developers to use C++ and other programming languages to solve complex computational problems more efficiently than on CPUs. CUDA's scalable programming model uses abstractions like thread group hierarchies, shared memories, and barrier synchronization to enable fine-grained and coarse-grained parallelism. This model allows CUDA programs to automatically scale across various GPU architectures, from high-performance devices to mainstream GPUs, by adjusting the number of multiprocessors and memory partitions.</p>"},{"location":"cuda/#using-cuda","title":"Using CUDA","text":"<p>This repository contains several CUDA examples demonstrating various concepts:</p> <ol> <li><code>vector_add.cu</code>: Basic vector addition kernel</li> <li><code>matrix_multiply.cu</code>: Matrix multiplication using shared memory</li> <li><code>reduction.cu</code>: Parallel reduction using shared memory</li> <li><code>stream_example.cu</code>: Using CUDA streams for concurrent execution</li> <li><code>unified_memory.cu</code>: Using Unified Memory</li> </ol> <p>To compile and run these examples, use the provided Makefile:</p> <pre><code>make\n./vector_add\n./matrix_multiply\n./reduction\n./stream_example\n./unified_memory\n</code></pre>"},{"location":"cuda/#further-reading","title":"Further Reading","text":"<ul> <li>CUDA Toolkit Documentation</li> <li>CUDA C++ Programming Guide</li> </ul>"},{"location":"module/","title":"Make Your Own <code>module</code>std`","text":"<p>If an implementation does not currently support modules or lacks a standard module equivalent, we can revert to using traditional headers, which are widely available and standardized. The challenge lies in identifying the necessary headers to include.</p> <p>[!CAUTION] Modules deliberately don\u2019t export macros. If you need macros, use <code>#include</code> instead.</p>"},{"location":"module/#stdh-header","title":"<code>std.h</code> Header","text":"<p>We can cram all the headers we want into a single header file, <code>std.h</code>, then include it in our source files, but <code>#include</code>ing so much can give very slow compiles [Stroustrup,2021b].</p>"},{"location":"module/#std-module","title":"<code>std</code> \"Module\"","text":"<p>It includes all necessary headers in the global module fragment (before <code>export module std;</code>), then exports specific entities from the standard library.</p> <pre><code>module;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;memory&gt;\n#include &lt;algorithms&gt;\n// ...\n\nexport module std;\nexport istream;\nexport ostream;\nexport iostream;\n// ...\n</code></pre>"},{"location":"module/#import-a-header-unit","title":"Import a header unit","text":"<pre><code>export module std;\n\nexport import \"iostream\";\nexport import \"string\";\nexport import \"vector\";\nexport import \"list\";\nexport import \"memory\";\nexport import \"algorithms\";\n// ...\n</code></pre> <p>[!WARNING] This approach has several drawbacks:</p> <ul> <li>It treats each header as a separate module-like entity.</li> <li>It can inject names into the global namespace.</li> <li>It may leak macros, which regular modules don't do.   But it's still pretty cool.</li> </ul>"},{"location":"module/#actually-defining-the-module","title":"Actually defining the module","text":"<p>File: <code>std.cppm</code></p> <pre><code>export module std;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nexport using std::cout;\nexport using std::cin;\nexport using std::string;\nexport using std::vector;\n</code></pre> <p>Command:</p> <pre><code>clang++ -std=c++20 -fmodules-ts -c std.cppm\n</code></pre> <p>Error:</p> <pre><code>std.cppm:8:19: error: using declaration referring to 'cout' with module linkage cannot be exported\n</code></pre> <p>It looks like we can't export <code>using</code> declarations on Apple clang version 15.0.0 (clang-1500.3.9.4)</p>"},{"location":"pimpl/","title":"Pointer to Implementation (PImpl)","text":"<p>Based on example from Code Signal practice question</p>"},{"location":"pimpl/#problem","title":"Problem","text":"<p>Given this header file:</p> <pre><code>#ifndef INTEGER_CONTAINER_HPP_\n#define INTEGER_CONTAINER_HPP_\n\n\n/**\n * `IntegerContainer` interface.\n */\nstruct IntegerContainer {\n\n  /**\n   * Should add the specified integer `value` to the container\n   * and return the number of integers in the container after the\n   * addition.\n   */\n  virtual int Add(int value) {\n    // Default implementation\n    return 0;\n  }\n\n  /**\n   * Should attempt to remove the specified integer `value` from\n   * the container.\n   * If the `value` is present in the container, remove it and\n   * return `true`, otherwise, return `false`.\n   */\n  virtual bool Delete(int value) {\n    // Default implementation\n    return false;\n  }\n\n  virtual inline ~IntegerContainer() = 0;\n};\nIntegerContainer::~IntegerContainer() = default;\n\n#endif  // INTEGER_CONTAINER_HPP_\n</code></pre>"},{"location":"pimpl/#implementation","title":"Implementation","text":"<pre><code>/* -------------------------- */\n/* integer_container_impl.hpp */\n#ifndef INTEGER_CONTAINER_IMPL_HPP_\n#define INTEGER_CONTAINER_IMPL_HPP_\n\n#include \"integer_container.hpp\"\n#include &lt;memory&gt;\n\nclass IntegerContainerImpl : public IntegerContainer {\npublic:\n    IntegerContainerImpl();\n    ~IntegerContainerImpl() override;\n    IntegerContainerImpl(const IntegerContainerImpl&amp;) = delete;\n    IntegerContainerImpl&amp; operator=(const IntegerContainerImpl&amp;) = delete;\n    IntegerContainerImpl(IntegerContainerImpl&amp;&amp;);\n    IntegerContainerImpl&amp; operator=(IntegerContainerImpl&amp;&amp;);\n\n    int Add(int value) override;\n    bool Delete(int value) override;\n\nprivate:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; pImpl;\n};\n\n#endif // INTEGER_CONTAINER_IMPL_HPP_\n\n/* -------------------------- */\n/* integer_container_impl.cpp */\n#include \"integer_container_impl.hpp\"\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass IntegerContainerImpl::Impl {\npublic:\n    int Add(int value) {\n        container_.push_back(value);\n        return container_.size();\n    }\n\n    bool Delete(int value) {\n        auto it = std::find(container_.begin(), container_.end(), value);\n        if (it != container_.end()) {\n            container_.erase(it);\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::vector&lt;int&gt; container_;\n};\n\nIntegerContainerImpl::IntegerContainerImpl() : pImpl(std::make_unique&lt;Impl&gt;()) {}\nIntegerContainerImpl::~IntegerContainerImpl() = default;\nIntegerContainerImpl::IntegerContainerImpl(IntegerContainerImpl&amp;&amp;) = default;\nIntegerContainerImpl&amp; IntegerContainerImpl::operator=(IntegerContainerImpl&amp;&amp;) = default;\n\nint IntegerContainerImpl::Add(int value) {\n    return pImpl-&gt;Add(value);\n}\n\nbool IntegerContainerImpl::Delete(int value) {\n    return pImpl-&gt;Delete(value);\n}\n</code></pre>"},{"location":"pimpl/#alternative-implementation","title":"Alternative Implementation","text":"<p>Just define the functions like this:</p> <pre><code>/* -------------------------- */\n/* integer_container_impl.cpp */\n#include \"integer_container_impl.hpp\"\n\nint IntegerContainerImpl::Add(int value) {\n    container_.push_back(value);\n    return container_.size();\n}\n\nbool IntegerContainerImpl::Delete(int value) {\n    auto it = std::find(container_.begin(), container_.end(), value);\n    if (it != container_.end()) {\n        container_.erase(it);\n        return true;\n    }\n    return false;\n}\n</code></pre>"},{"location":"pimpl/#level-2","title":"Level 2","text":"<p>Add support for calculating the median of the numbers stored in the container.</p> <p><code>std::optional&lt;int&gt; GetMedian()</code> \u2014 should return the median integer - the integer in the middle of the sequence after all integers stored in the container are sorted in ascending order. If the length of the sequence is even, the leftmost integer from the two middle integers should be returned. If the container is empty, this method should return std::nullopt.</p> <pre><code>std::optional&lt;int&gt; IntegerContainerImpl::GetMedian() {\n    if (pImpl-&gt;container_.empty()) {\n        return std::nullopt;\n    }\n\n    std::vector&lt;int&gt; sorted = pImpl-&gt;container_;\n    std::sort(sorted.begin(), sorted.end());\n\n    if (sorted.size() % 2 == 0) {\n        return sorted[sorted.size() / 2 - 1];\n    }\n\n    return sorted[sorted.size() / 2];\n}\n</code></pre>"},{"location":"qsort/","title":"Quicksort","text":"<p>The <code>qsort()</code> function is a modified partition-exchange sort, or quicksort.</p> <pre><code>#include &lt;stdlib.h&gt;\n\nvoid\nqsort(void *base, size_t nel, size_t width,\n    int (*compar)(const void *, const void *));\n</code></pre>"},{"location":"qsort/#compar-function","title":"<code>compar</code> function","text":"<p>The <code>compar</code> function is a user-supplied function that returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.</p> <pre><code>int compar(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n</code></pre> <p>Here, the <code>compar</code> function compares dereferenced pointers-to-integers and returns the difference between the two values. If the difference is negative, the first argument is considered less than the second. If the difference is zero, the two arguments are considered equal.</p>"},{"location":"qsort/#time-complexity","title":"Time complexity","text":"<p>The time complexity of quicksort is O(n log n) on average, but O(n^2) in the worst case.</p> <p>The space complexity is O(log n) on average, but O(n) in the worst case.</p>"},{"location":"qsort/#sorting-in-c","title":"Sorting in C++","text":"<p>The C++ standard library provides a <code>std::sort()</code> function that is implemented using a hybrid sorting algorithm, which often includes quicksort as one of its components.</p>"},{"location":"tcp/","title":"TCP Echo Server and Client","text":"<p>This project implements a simple TCP echo server and client in C++. The server listens for incoming connections and echoes back any data it receives. The client connects to the server, sends a message, and prints the response.</p>"},{"location":"tcp/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++17 compatible compiler (e.g., GCC 7+ or Clang 5+)</li> <li>Make build system</li> <li>POSIX-compatible operating system (Linux, macOS, etc.)</li> </ul>"},{"location":"tcp/#project-structure","title":"Project Structure","text":"<p>The project consists of the following files:</p> <ul> <li><code>server.cpp</code>: Implementation of the TCP echo server</li> <li><code>client.cpp</code>: Implementation of the TCP echo client</li> <li><code>utils.h</code>: Header file for utility functions</li> <li><code>utils.cpp</code>: Implementation of utility functions</li> <li><code>Makefile</code>: Build script for compiling the project</li> </ul>"},{"location":"tcp/#building-the-project","title":"Building the Project","text":"<p>To build the project, follow these steps:</p> <ol> <li>Open a terminal and navigate to the project directory.</li> <li>Run the following command:</li> </ol> <pre><code>make\n</code></pre> <p>This will compile both the server and client executables.</p>"},{"location":"tcp/#running-the-server","title":"Running the Server","text":"<p>To start the echo server, use the following command:</p> <pre><code>./server &lt;port&gt;\n</code></pre> <p>Replace <code>&lt;port&gt;</code> with the port number you want the server to listen on (e.g., 8080).</p> <p>Example:</p> <pre><code>./server 8080\n</code></pre> <p>The server will start and listen for incoming connections on the specified port.</p>"},{"location":"tcp/#running-the-client","title":"Running the Client","text":"<p>To run the client and send a message to the server, use the following command:</p> <pre><code>./client &lt;message&gt; &lt;server-ip&gt; &lt;server-port&gt;\n</code></pre> <ul> <li>Replace <code>&lt;message&gt;</code> with the text you want to send to the server.</li> <li>Replace <code>&lt;server-ip&gt;</code> with the IP address of the server (use 127.0.0.1 for localhost).</li> <li>Replace <code>&lt;server-port&gt;</code> with the port number the server is listening on.</li> </ul> <p>Example:</p> <pre><code>./client \"Hello, Server!\" 127.0.0.1 8080\n</code></pre> <p>The client will connect to the server, send the message, receive the echo response, and display it.</p>"},{"location":"tcp/#cleaning-up","title":"Cleaning Up","text":"<p>To remove all compiled files and start fresh, run:</p> <pre><code>make clean\n</code></pre> <p>This will remove the server and client executables, as well as any object files.</p>"},{"location":"tcp/#note","title":"Note","text":"<p>This project is designed for educational purposes and may not be suitable for production environments without further enhancements.</p>"},{"location":"resources/time-complexity/","title":"Time Complexity","text":"<p>Time complexity is a measure of the amount of time an algorithm takes to complete as a function of the size of the input. It is often expressed using big-O notation, which describes the upper bound of the time taken by an algorithm as a function of the size of the input.</p>"},{"location":"resources/time-complexity/#big-o-notation","title":"Big-O notation","text":"<p>Big-O notation describes the upper bound of the time taken by an algorithm as a function of the size of the input. It is used to describe the worst-case performance of an algorithm. For example, an algorithm with a time complexity of O(n) will take at most n steps to complete, where n is the size of the input.</p> <pre><code>int sum(int n)\n{\n    int total = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        total += i;\n    }\n    return total;\n}\n</code></pre> <p>The <code>sum</code> function has a time complexity of O(n) because it takes at most n steps to complete, where n is the input to the function.</p>"},{"location":"resources/time-complexity/#common-time-complexities","title":"Common time complexities","text":"Notation Name Example O(1) Constant time Accessing an element in an array by index (index arithmetic) O(log n) Logarithmic time Binary search (if the input is sorted) O(n) Linear time Finding the maximum element in an array (one-pass) O(n log n) Linearithmic time Quicksort, mergesort (average case) O(n^2) Quadratic time Bubble sort, selection sort (use of nested loops) O(2^n) Exponential time Recursive Fibonacci calculation O(n!) Factorial time Generating all permutations of a set"},{"location":"resources/time-complexity/#comparing-time-complexities","title":"Comparing time complexities","text":"<p>The following table shows how the time complexity of different algorithms compares as the size of the input grows.</p> Input size O(log n) O(n) O(n log n) O(n^2) O(2^n) O(n!) 10 3 10 30 100 1024 3628800 100 7 100 664 10000 1.27e+30 9.33e+157 1000 10 1000 9965 1000000 1.07e+301 4.02e+2567 <p>You get the idea.</p>"},{"location":"resources/cs3157recitations/","title":"COMS 3157 Recitation Notes","text":"<p>NOTE FOR FALL 2022 STUDENTS: these recitations notes are for the version of COMS 3157 taught by Jae Woo Lee. John, who is teaching it in Fall 2022, is publishing links to his recitation notes directly to this semester's course website. You are still welcome to consult these recitation notes for reference.</p> <p>This repository contains the recitation notes for Columbia's Advanced Programming class, COMSW3157, as taught by Jae Woo Lee. For more information about the class, visit the course homepage.</p> <p>These recitations are held weekly by the various TAs, generally using these notes as the basis for their sections. Issues, patches, and comments, especially by current and former students, are welcome.</p> <p>Contents:</p> <ul> <li>Recitation Note A: Introduction to UNIX, compile your first C    program.</li> <li>Recitation Note B: Makefiles. <ul> <li>You may find the sample-Makefile a useful reference.</li> </ul> </li> <li>Recitation Note C: Configuring and using Git for version control and file tracking.</li> <li>Recitation Note D: Bits, Binary, and C Basics<ul> <li>Bits &amp; Binary: Two's complement, bitwise operators, and Boolean logic.</li> <li>C Basics: syntax, data types, expressions, and statements.</li> </ul> </li> <li>Recitation Note E: Parts of memory, pointers, and arrays. (i.e. malloc).<ul> <li>See also the very useful code directory,   especially <code>pointerfun.c</code> and its output <code>pointerfun-output</code> for some   interesting experiments with pointers and memory addresses.</li> </ul> </li> <li>Recitation Note F: Function pointers.</li> <li>Recitation Note G: Structs, Unions, Const, C strings.</li> <li>Recitation Note H: Linked lists and similar data structures (REMOVED).</li> <li>Recitation Note I Using GDB and valgrind for debugging.</li> <li>Recitation Note J: The UNIX stack. Users, permissions, file   attributes. Processes, forking, and signals. <ul> <li>See also <code>jsh</code>, the Jae shell, in the code   directory for a fun example of forking.</li> </ul> </li> <li>Recitation Note K: <code>size_t</code>. File IO, including reading, writing,   and seeking in files.</li> <li>Recitation Note L: Interprocess communication: pipes, FIFO, and sockets. TCP/IP stack information and netcat basics. </li> <li>Recitation Note M: C++ intro. Classes and structs. Stack vs heap allocation   in C++. The basic 4. Implicit conversion and operator overloading.</li> <li>Recitation Note N: C++ generics, templates,   containers, metaprogramming.</li> <li>Recitation Note O: Smart pointer explanation.</li> <li>Recitation Note Z: Bonus recitation -- Unix 2.</li> </ul> <p>Additionally you can read the Mid-Semester Review to brush up on past material in the first part of the course; or  Mid-Semester Review 2 for the second part (ie up to basic C++).</p> <p>Finally, we've collected a number of interesting articles, posts, etc about C and related stuff in the reading list.</p>"},{"location":"resources/cs3157recitations/final-review/","title":"Final Exam Review","text":"<p>Our final review session typically goes through one of the sample exams.  We're also providing this outline of some important topics in case it helps organize your studying (but it's not meant to be exhaustive).</p> <p>If you find a topic you're not familiar with, click the link to the full review session notes. Make sure you understand the topic thoroughly before moving on. Remember, the exams are written to test how deep your knowledge goes!</p>"},{"location":"resources/cs3157recitations/final-review/#topics-from-midterm-1","title":"Topics from Midterm 1","text":""},{"location":"resources/cs3157recitations/final-review/#bits-bytes-and-binary","title":"Bits, Bytes, and Binary","text":"<p>Main article: Bits, Bytes, and Binary</p> <ul> <li>Definition of bit, byte, MSB, LSB</li> <li>Hexadecimal, octal</li> <li>Two's complement</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#c-basics","title":"C Basics","text":"<p>Main article: C Basics</p> <ul> <li>Data types and their sizes<ul> <li>Integer: <code>char</code>, <code>short</code> <code>int</code>, <code>long,</code>long long`</li> <li>Floating point: <code>float</code>, <code>double</code></li> <li><code>sizeof</code> operator</li> </ul> </li> <li>ASCII table<ul> <li>Know the relationships (don't memorize)</li> </ul> </li> <li>C strings (<code>char</code> arrays)</li> <li>Syntax<ul> <li>Bitwise operators <code>&amp;</code>, <code>|</code>, <code>^</code> <code>~</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></li> <li>Literal notations: <code>'</code>, <code>\"</code>, <code>0x</code>, and <code>0</code></li> <li>Order of operations</li> </ul> </li> </ul>"},{"location":"resources/cs3157recitations/final-review/#git","title":"Git","text":"<p>Main article: Git</p> <ul> <li>Usage of basic commands: <code>clone</code>, <code>status</code>, <code>add</code>, and <code>commit</code></li> <li>Tracking state</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#makefiles","title":"Makefiles","text":"<p>Main article: Makefiles</p> <ul> <li>Understand each line of Jae's sample Makefile</li> <li>Declaring targets &amp; dependencies<ul> <li>Implicit rules</li> <li>Phony targets</li> </ul> </li> <li>Build process: preprocessing, compiling, and linking</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#function-pointers","title":"Function Pointers","text":"<p>Main article: Function Pointers</p> <ul> <li>Syntax examples: goshdarnfunctionpointers.com</li> <li>Usage, e.g. in <code>traverseList()</code> and <code>qsort()</code></li> </ul>"},{"location":"resources/cs3157recitations/final-review/#memory","title":"Memory","text":"<p>Main article: Memory and Pointers</p> <ul> <li>Common Valgrind errors &amp; how to fix them<ul> <li>Valgrind manual, Section 4.2: Explanation of error messages from Memcheck.</li> </ul> </li> <li>Process memory layout (relative position of stack, heap, static, code)</li> <li>Pointers<ul> <li>Regular pointer vs double pointer</li> <li>Why is <code>void *</code> different / special?</li> </ul> </li> </ul>"},{"location":"resources/cs3157recitations/final-review/#topics-from-midterm-2","title":"Topics from Midterm 2","text":""},{"location":"resources/cs3157recitations/final-review/#file-io","title":"File I/O","text":"<p>Main article: File I/O</p> <ul> <li>Usage of library functions related to <code>FILE *</code><ul> <li>Examples: <code>fopen()</code>, <code>fdopen()</code>, <code>fgets()</code>, <code>fwrite()</code></li> </ul> </li> <li>Files you get automatically: <code>stdin</code>, <code>stdout</code>, <code>stderr</code><ul> <li>Buffering differences</li> </ul> </li> <li>File permissions<ul> <li>What does <code>644</code> mean? Same as <code>rw-r--r--</code>?</li> </ul> </li> </ul>"},{"location":"resources/cs3157recitations/final-review/#fork-exec","title":"Fork &amp; Exec","text":"<p>Main article: Fork / Exec, IPC and TCP/IP</p> <ul> <li>Process vs program</li> <li>Usage of <code>fork()</code> and <code>execl()</code><ul> <li>Idiomatic fork-then-exec pattern</li> </ul> </li> <li>Zombies and <code>waitpid()</code></li> <li>Pipes and shell redirection<ul> <li>Difference between <code>|</code>, <code>&gt;</code>, and <code>&gt;&gt;</code></li> <li>Named pipe</li> <li>Netcat version of <code>mdb-lookup-server</code></li> </ul> </li> </ul>"},{"location":"resources/cs3157recitations/final-review/#sockets","title":"Sockets","text":"<p>Main article: IPC and TCP/IP</p> <ul> <li>Sockets API<ul> <li>Understand (but don't memorize) Jae's TCP sample code</li> <li><code>socket()</code>, <code>bind()</code>, <code>listen()</code>, <code>accept()</code>, <code>connect()</code>, <code>send()</code>,     <code>recv()</code>, etc.</li> </ul> </li> <li>Five-layer networking model (OSI model)</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#http","title":"HTTP","text":"<ul> <li>Basic structure of requests and responses</li> <li>Important status codes: 200, 400, 404, 501</li> <li>HTTP 1.0 vs HTTP 1.1</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#topics-introduced-after-the-midterms","title":"Topics introduced after the midterms","text":""},{"location":"resources/cs3157recitations/final-review/#software-architecture","title":"Software Architecture","text":"<p>Main article: See lecture notes</p> <ul> <li>Client-server architecture</li> <li>Web app architecture: presentation, application, data</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#c-basics_1","title":"C++ Basics","text":"<p>Main article: Introducing C++</p> <ul> <li>Classes and structs<ul> <li>Object lifecycle (Basic 4)</li> </ul> </li> <li>References</li> <li>Heap allocation: <code>new</code> and <code>delete</code></li> <li>Function overloading</li> <li>\"Real\" strings: <code>MyString</code> and <code>std::string</code></li> </ul>"},{"location":"resources/cs3157recitations/final-review/#templates-containers","title":"Templates &amp; Containers","text":"<p>Main article: C++ Templates &amp; Containers</p> <ul> <li>Template syntax for classes and functions</li> <li>Compiling templates<ul> <li>Why do we need to put all template code into the <code>.h</code> file?</li> </ul> </li> <li>Standard library containers: <code>vector</code> and <code>list</code></li> <li>Iterators</li> </ul>"},{"location":"resources/cs3157recitations/final-review/#smart-pointers","title":"Smart Pointers","text":"<p>Main article: Smart Pointers</p> <ul> <li>Reference counting</li> <li>Behaviors &amp; usage<ul> <li>How does <code>SmartPtr</code> use the Basic 4 to update the reference count?</li> <li>What parts are on the stack vs the heap?</li> </ul> </li> </ul> <p>Thanks for reading our notes. Good luck on the final! You're gonna do great. \ud83c\udf3b</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/","title":"Mid-Semester Review 1","text":"<p>This document is an outline of what's covered in our mid-semester review session. If you'd like more detail, use the link in each section to see the full review session notes for that topic.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#bits-bytes-and-binary","title":"Bits, Bytes, and Binary","text":"<p>Main article: Bits, Bytes, and Binary</p> <p>Let's refresh our memory about memory:</p> <ul> <li>Bit (b)</li> <li>A single digit in binary</li> <li>Two possible values: 1 or 0</li> <li>Byte (B)</li> <li>8 bits make a byte</li> <li>Can take on 2^8 = 256 different values (from 0 to 255, inclusive)</li> <li>Hexadecimal</li> <li>A base-16 numerical notation that can represent up to 15 in a single digit</li> <li>Uses base-10 + first 5 letters of alphabet:     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f }</li> <li>2 hexadecimal digits make a byte</li> <li>Least significant bit (LSB)</li> <li>Right-most binary digit</li> <li>Most significant bit (MSB)</li> <li>Left-most binary digit</li> <li>Indicates positive or negative for signed integers</li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-1/#twos-complement","title":"Two's Complement","text":"<ul> <li>MSB indicates whether number is positive (0) or negative (1)</li> <li>If negative, invert all bits and add 1 to find out what number is     represented</li> </ul> <p>The table shows the same bit pattern interpreted as unsigned and signed integers, assuming that integers are 3 bits long:</p> Binary unsigned decimal two's complement decimal 000 0 0 001 1 1 010 2 2 011 3 3 100 4 -4 101 5 -3 110 6 -2 111 7 -1"},{"location":"resources/cs3157recitations/midsemester-review-1/#c-basics","title":"C Basics","text":"<p>Main article: C Basics</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#data-types-numbers","title":"Data Types: Numbers","text":"<p>Memory size for each type depends on system, and only restrictions are that</p> <pre><code>char &lt;= short &lt;= int &lt;= long &lt;= long long\n</code></pre> <p>CLAC machines follow:</p> Type Size <code>char</code> 1 byte <code>short</code> 2 bytes <code>int</code> 4 bytes <code>long</code> 8 bytes <code>long long</code> 8 bytes <p>Use the <code>sizeof</code> operator to find the size of a data type in bytes:</p> <pre><code>// sizeof on a data type\nprintf(\"ints are %d bytes\", sizeof(int));\n\n// Works on variable names too\nchar *p;\nprintf(\"pointers are %d bytes\", sizeof(p));\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#ascii","title":"ASCII","text":"<ul> <li>The \"character\" or <code>char</code> data type is simply a very small integer</li> <li>C uses a system called ASCII encoding to assign a number to each character<ul> <li>For example, <code>'a'</code> is 97</li> </ul> </li> <li>See ASCII table for the     complete list<ul> <li>Focus on understanding relationships between values rather than trying     to memorize the whole thing</li> <li>For example, capital letters have smaller numerical values than     lowercase ones</li> </ul> </li> </ul> <p>Here are some integer declarations and the corresponding values of the variables:</p> Declaration x (dec) y (dec) <code>int x;</code> undefined - <code>int x, y;</code> undefined undefined <code>int x = 0, y;</code> 0 undefined <code>char x = 'x';</code> 120 - <code>char x = '\\n';</code> 10 - <code>char x = '\\13';</code> 11 - <code>char x = '0';</code> 48 - <code>char x = '\\0';</code> 0 - <code>char x = 0;</code> 0 -"},{"location":"resources/cs3157recitations/midsemester-review-1/#different-notations-for-integer-literals","title":"Different notations for integer literals","text":"<ul> <li>Single quote <code>'</code> means character (double quotes <code>\"</code> are for strings)</li> <li><code>0x</code> at the beginning means hexadecimal notation</li> <li><code>0</code> at the beginning means octal notation</li> </ul> <p>So, the following literals all have the same value:</p> <pre><code>'@'   // character literal\n0x40  // hexadecimal\n0100  // octal\n64    // decimal\n</code></pre> <p>Some more hex and octal examples:</p> <pre><code>(0xFFFFFFFF == -1)    // equal to 1 (which is true, but C doesn't have true)\n(037777777777 == -1)  // 1 (true)\n0xFFFFU               // 65535\n0177777U              //  65535\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#floating-point-types","title":"Floating point types","text":"<p>The only implementation constraint is that</p> <pre><code>float &lt;= double &lt;= long double\n</code></pre> <p>Floating point types can be expressed with a decimal point or scientific notation:</p> <pre><code>float miles = 1.8;\ndouble avogadro = 6.02e23; // 6.02 x 10^23\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#strings","title":"Strings","text":"<ul> <li>No string object in C</li> <li>C \"strings\" are an array of characters</li> <li>Have a null byte (<code>'\\0'</code> or <code>0</code>) at the end</li> </ul> <pre><code>char *s = \"cs3157\";\n// similar to the array { 'c', 's', '3', '1', '5', '7', '\\0' }\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#bitwise-operators","title":"Bitwise Operators","text":"<ul> <li><code>&amp;</code> can be used to \"mask\" or turn off all bits except certain ones. For   example:</li> </ul> <pre><code>n = n &amp; 0177; // n bitwise-and 00000001111111\n</code></pre> <ul> <li><code>|</code> can be used to ensure that bits are set:</li> </ul> <pre><code>n = n | 0177; // n bitwise-or 00000001111111\n</code></pre> <ul> <li>It's easy to confuse bitwise and <code>&amp;</code> with logical and <code>&amp;&amp;</code>:</li> </ul> <pre><code>printf(\"%d\\n\", 1 &amp; 2);  // 0\nprintf(\"%d\\n\", 1 &amp;&amp; 2); // 1\n</code></pre> <ul> <li> <p><code>^</code> is a bitwise exclusive or. The resulting bit is 1 if the inputs were   different, and 0 if they were the same.</p> </li> <li> <p><code>~</code> flips all the bits.</p> </li> <li> <p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> shift their left operand by the number of digits specified by   the right operand. Left shifting fills vacated bits by zero. Right shifting   typically fills with whatever the MSB was.</p> </li> </ul> <pre><code>int x = 2;\nint y = x &lt;&lt; 2; // y == 8\nint z = x &gt;&gt; 1; // z == 1\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#order-of-operations","title":"Order of Operations","text":"<p>Make sure you're familiar with operator precedence in C.</p> <p>Based on the precedence rules, what does <code>*p++</code> do?</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#test-yourself-c-basics","title":"Test yourself: C Basics","text":"<p>On midterm 1, a common type of question provides a C program, then asks you to evaluate some expressions based on what was declared or run in that program.</p> <p>The instructions will typically say:</p> <ul> <li>For integer expressions, write the actual number value in decimal notation.<ul> <li>Remember \u2014 <code>char</code> is a type of integer!</li> <li>Boolean expressions, such as <code>x == 1</code>, are also integer expressions.     This means you should never write \"true\" or \"false.\"</li> </ul> </li> <li>For non-integer expressions, write the type name, in the format that you use     to declare a variable of that type.</li> <li>Write \"INVALID\" if a given expression is not a valid C expression.</li> </ul> <p>On the front of the exam, you might find useful information like:</p> <p>Language: C Compiler: gcc Platform: Ubuntu Linux 16.04, 64-bit version Primitive type sizes: <code>sizeof(int)</code> is 4 and <code>sizeof(int *)</code> is 8</p> <p>Now you know tons about the other types!</p> <p>Consider the following program:</p> <pre><code>struct Node {\n  void *data;\n  struct Node *next;\n};\n\nint main(int argc, char **argv)\n{\n  int a = 3;\n  int b[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n  struct Node arr[5] = { &amp;a, arr + 1, b, arr + 2, \"hello\", arr + 3 };\n</code></pre> <p>Some tricky (maybe not) questions now:</p> <ul> <li><code>b[2]</code></li> <li><code>sizeof(b)</code></li> <li><code>sizeof(b[2])</code></li> <li><code>sizeof(&amp;b[0])</code></li> <li><code>\"hello\"</code></li> <li><code>arr[1].data[4]</code></li> <li><code>arr[0].data[4]</code></li> <li><code>sizeof(arr[3].next)</code></li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-1/#git","title":"Git","text":"<p>Main article: Git</p> <p>Some key Git commands to understand the basic usage of:</p> <pre><code>git clone\ngit status\ngit add\ngit commit\n</code></pre> <p>Use <code>git help &lt;command&gt;</code> to see the manual page for a command.</p> <p>Make sure you know what levels of tracking exist:</p> <ul> <li>untracked</li> <li>tracked, unmodified</li> <li>tracked, modified, but unstaged</li> <li>tracked, modified, staged</li> <li>tracked, committed</li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-1/#makefiles","title":"Makefiles","text":"<p>Main article: Makefiles</p> <p>Let's review Jae's sample Makefile piece by piece:</p> <pre><code>CC  = gcc\nCXX = g++\n</code></pre> <p>Make has a pre-configured rules for how to compile C programs. We just need to set Makefile variables for the C compiler (<code>CXX</code>) and C++ compiler (<code>CXX</code>).</p> <pre><code>INCLUDES =\n\nCFLAGS   = -g -Wall $(INCLUDES)\nCXXFLAGS = -g -Wall $(INCLUDES)\n</code></pre> <p>Here we define our own variable, <code>INCLUDES</code>, which use to specify directories to search for header files during compilation. For example, the value <code>-I/home/jae/cs3157</code> would tell the compiler to look in <code>/home/jae/cs3157</code> for header files.</p> <p>Also set the flags we want each compilation to run with. What do these flags mean? We also reference our <code>INCLUDES</code> to add those flags as well.</p> <pre><code>LDFLAGS = -g\n</code></pre> <p>Flags to pass during the linking step.</p> <pre><code>LDLIBS =\n</code></pre> <p><code>LDLIBS</code> will automatically be appended to the linker commands. These are flags like <code>-lm</code> for linking the math library. It's analogous to our <code>INCLUDES</code> from the compilation step.</p> <p>Now we define the dependencies of our files. The first target we specify is run if we simply type <code>make</code>:</p> <pre><code>main: main.o myadd.o\n</code></pre> <p>This rule means that make should produce an executable <code>main</code> by linking <code>main.o</code> and <code>myadd.o</code>. When either <code>.o</code> file is modified, it will regenerate <code>main</code> the next time we run <code>make</code>.</p> <p>If we don't provide a command to run, make follows this implied linking rule:</p> <pre><code>$(CC) $(LDFLAGS) &lt;all-dependent-.o-files&gt; $(LDLIBS)\n</code></pre> <p>It also assumes that <code>main</code> depends on <code>main.o</code>, so we could have omitted <code>main.o</code> like this:</p> <pre><code>main: myadd.o\n</code></pre> <p>(Take a moment to understand how all of that works. Makefile dependencies are an important topic!)</p> <pre><code>main.o: main.c myadd.h\n</code></pre> <p>Again, we don't specify a command here because make assumes the implicit rule:</p> <pre><code>$(CC) -c $(CFLAGS) &lt;the-.c-file&gt;\n</code></pre> <p>Just as before, the dependency of <code>main.o</code> on <code>main.c</code> is implicit. So we could have omitted <code>main.c</code>.</p> <p>Why does main.o depend on main.h?</p> <pre><code>myadd.o: myadd.c myadd.h\n</code></pre> <p>Same as previous.</p> <pre><code>.PHONY: clean\nclean:\n        rm -f *.o a.out core main\n</code></pre> <p>Since the <code>clean</code> target is \"phony,\" make won't look for a file named <code>clean</code> to decide whether it should run the commands in the target. So <code>make clean</code> will always run, even if there is a file named <code>clean</code> in the directory.</p> <p>The first phony target removes the compiler-generated files so that only the source code is left.</p> <pre><code>.PHONY: all\nall: clean main\n</code></pre> <p>Make runs its dependencies left-to-right. So the <code>all</code> target will first run <code>clean</code>, then generate <code>main</code>. Run <code>make all</code> when you want to completely recompile the program from scratch, without using any previously compiled files.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#function-pointers","title":"Function Pointers","text":"<p>Main article: Function Pointers</p> <ul> <li>Problem: want to write an algorithm then let users customize its     functionality<ul> <li>Example: a sorting algorithm may let users specify whether characters     should be compared lexicographically, or by Unicode value</li> </ul> </li> <li>Solution: The caller passes a pointer to a function that implements the     desired feature</li> </ul> <p>Example of accepting a function as an parameter to your function:</p> <pre><code>void notifier(int (*fn)()) {\n  printf(\"Starting\\n\");\n  fn();\n  printf(\"Finished\\n\");\n}\n</code></pre> <ul> <li>Basic layout for a function pointer type is     <code>returnType (*functionName)(parameterType1, parameterType2, ...)</code><ul> <li>More examples: goshdarnfunctionpointers.com</li> </ul> </li> <li>This denotes the return and parameter types of functions you can accept</li> <li>Parentheses are necessary even if there are no arguments</li> <li>What does the function do?</li> </ul> <p>Passing a function as a parameter:</p> <pre><code>int wasteTime() {\n  int i;\n  for (i = 0; i &lt; 1000000; i++) { }\n  printf(\"Finished counting to %d\\n\", i);\n  return i;\n}\n\nint main(int argc, char **argv) {\n  wasteTime(); // Calling the function directly\n  notifier(wasteTime); // Passing a pointer to the function\n\n  return 0;\n}\n</code></pre> <ul> <li>Notice the difference between calling a function directly and passing it as     a function pointer</li> <li>Everything in the program is stored in memory \u2014 this means the <code>wasteTime</code>     function's code also has an address</li> <li>Calling a function causes the program to start executing code at that     address</li> <li>Getting a pointer to the function instead gets the value of that address<ul> <li>Value can be stored in a variable or passed as a parameter</li> </ul> </li> </ul> <p>Storing a function pointer in a variable (this example is equivalent to the one above):</p> <pre><code>int main(int argc, char **argv) {\n  int (*f1)();\n  f1 = wasteTime;\n\n  f1(); // Calling the function through the function pointer\n  notifier(f1); // Passing a pointer to the function\n\n  return 0;\n}\n</code></pre> <ul> <li>Call function pointers by adding parentheses to the end of the variable name</li> <li>Check out Jae's notes (lecture 7) for more complicated examples</li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-1/#memory-errors","title":"Memory Errors","text":"<p>Main article: Memory and Pointers</p> <p>Here are some common Valgrind errors:</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#illegal-read-write-errors","title":"Illegal read / write errors","text":"<pre><code>int a[10];\na[10] = 42; // wrote past the end of the array\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#illegal-frees","title":"Illegal frees","text":"<pre><code>char *p = malloc(16);\nfree(p);\nfree(p); // p was already freed, so you can't free it again\n</code></pre>"},{"location":"resources/cs3157recitations/midsemester-review-1/#use-of-uninitialized-values","title":"Use of uninitialized values","text":"<pre><code>char *p = malloc(16);\nchar c = p[0]; // nothing was written to p[0] before reading from it\n\nint n;\nprintf(\"%d\\n\", n); // nothing was written to n before passing it as an argument\n</code></pre> <p>You can find a full list of errors and more detailed explanations in the Valgrind manual, Section 4.2: Explanation of error messages from Memcheck.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1/#other-exam-tips","title":"Other exam tips!","text":"<p>Just some things it might pay to know well:</p> <ul> <li>What <code>MdbRec</code> structs look like and how to use them</li> <li>How to use the functions from lab3 and what they return</li> <li>What the pipeline for lab5 looked like and how it worked</li> <li>Please follow directions! The exam will be graded in the same way your     labs are graded if not less lenient. Read all the directions. Take your time     to understand them. If it says \"write the line number and the code that     should be on that line,\" do just that!</li> </ul> <p>Thanks for reading these notes. Good luck on the exam!</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/","title":"Mid-Semester Review 2","text":"<p>This is a quick summary of topics leading up to the second midterm. It is by no means fully comprehensive; use the rest of the lecture notes and recitation notes to help if you're unclear on anything.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#files","title":"Files","text":"<p>Main article: File I/O</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#3-channels","title":"3 channels","text":"<p>Remember that all C programs are automatically given 3 channels for input and output: <code>stdin</code> (0), <code>stdout</code> (1), and <code>stderr</code> (2). Make sure you understand their purposes and how to interact with them using function such as <code>fprintf()</code>.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#redirecting-io","title":"Redirecting I/O","text":"<p>It is possible to redirect the source of <code>stdin</code> or the destination of <code>stderr</code> and <code>stdout</code>. Make sure you understand how to use <code>&gt;</code>, <code>&lt;</code>, and <code>&gt;&gt;</code>.</p> <p>Remember <code>|</code>? We'll talk about that in the Pipes section below.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#file-io","title":"File I/O","text":"<p><code>FILE *</code>'s (file handles) are your best friends; they're just fancy pointers for files. As noted above, all C programs start with <code>FILE *</code>s <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p> <p>You open a file with <code>fopen()</code>, which takes two strings: the name of the file you want to open and the mode in which you want to open it. Modes include <code>r</code>, <code>w</code>, <code>a</code>, <code>r+</code>, <code>w+</code>, <code>a+</code>, and all of the previous with a <code>b</code> tacked on the end. Do you remember the differences? (Hint: check out the <code>man</code> page.)</p> <p>You read from and write to the file with functions <code>fgets()</code>/<code>fputs()</code>, <code>fprintf()</code>/<code>fscanf()</code>, and <code>fread()</code>/<code>fwrite()</code>. Hopefully you're familiar with these functions by now; if not, reviewing the <code>man</code> pages is a great idea.</p> <p>Don't forget that you need to close the file when you're done by using <code>fclose()</code>. Before closing, you can use <code>feof()</code> or <code>ferror()</code> to see if anything weird happened while you were interacting with the file.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#buffering","title":"Buffering","text":"<p>Buffering determines how often the contents of a stream are sent to their destination. Unbuffered streams are constantly flushed to its destination. Line-buffered streams are only flushed to its destination after a newline character is written. Block-buffered streams are flushed when they reach a certain size. You can use <code>fflush(fp)</code> to manually flush the buffer for any file pointer.</p> <ul> <li><code>stderr</code> is unbuffered - remember why? (hint: debugging!)</li> <li><code>stdout</code> is line-buffered when it's connected to the terminal</li> <li>everything else is block-buffered</li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-2/#forkexec","title":"Fork/Exec","text":"<p>Main article: Fork / Exec</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#quick-unix-overview","title":"Quick UNIX overview","text":"<p>Before we can talk about <code>fork()</code> and <code>exec()</code>, here's a quick review of the UNIX system.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#users-and-permissions","title":"Users and Permissions","text":"<p>Unix systems have three different ways to allocate permissions: owner (a user), group, and everyone else.</p> <ul> <li>Owner The owner is always a user and the owner can own both files and directories.</li> <li>Group A file or directory is assigned to a group, usually but not always the user group that the owner belongs to.</li> <li>Others Those who are not in the assigned group, nor an owner, belong to the others.</li> </ul> <p>There are also three UNIX file permissions: read, write, and execute. Make sure you're comfortable with the binary and octal representations of these permissions. For example: 100 is the ability to only read, and has a value of 4. 111 is read, write, and execute, and has value 7. These numbers can be combined for owner, group, and others as well, like <code>chmod 644</code>. (Exercise: who has what permissions on a file after <code>chmod 644</code>?)</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#processes","title":"Processes","text":"<p>A program is a packaged set of instructions, whereas a process is an instance of a program. A program can have many processes associated with it. For example, we can run multiple instances of an executable independently, thereby initiating multiple processes that run that program. We can create more processes associated with the executable by splitting a process with the fork system call, as we'll soon see.</p> <p>Confused? Here's an analogy: Let's say you have a recipe for an amazing soup. While you only have one recipe, you can have multiple pots cooking at once. A program is like that recipe; you can have multiple processes (pots) running at once.</p> <p>Each process has a unique, non-negative numeric identifier known as the process ID (<code>pid</code>).</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#fork","title":"<code>fork()</code>","text":"<p>We can create new processes using the <code>fork()</code> system call. The process that calls <code>fork()</code> is the parent process; this creates a second process called the child process, essentially splitting your original process into two processes.</p> <p>After <code>fork()</code>, the parent and child process both execute all code after the <code>fork()</code> statement. <code>fork()</code> is called once in the parent, but returns twice: once in the parent and once in the child. The return value of <code>fork()</code> depends on if it's executing within the child process or parent process.</p> <ul> <li>If <code>fork()</code> is returning in the parent process, it returns the child's <code>pid</code></li> <li>If <code>fork()</code> is returning in the child process, it returns 0</li> </ul> <p>This means you can identify which process you are in simply by checking the return value of <code>fork()</code>.</p> <p>Note that the process ID of the child process is NOT equal to 0. Also note that the order of execution of the child and parent processes relative to each other is unpredictable.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#exec","title":"<code>exec()</code>","text":"<p>Now that you've used <code>fork()</code>, you have two exact copies of the same process. That's great, but it can be limiting. The <code>exec()</code> family of functions lets you turn your current process into an instance of another program. Cool!</p> <p>You create the new program with <code>exec()</code> by specifying arguments, which include things like the new program name and any command line arguments. (Check out the <code>man</code> page for more info.) Once the call to <code>exec()</code> has been made, the process running <code>exec()</code> stops executing the code of its original program and begins executing the code of the new program. Your process has no memory (ha-ha) of the previously running program: its program code, data, heap, and stack are replaced with those of the new program. If the new program ends, the process exits and never returns to the code of your old program. This means that any code following a call to <code>exec()</code> will only be executed if the call to <code>exec()</code> fails.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#dealing-with-terminated-processes","title":"Dealing with Terminated Processes","text":"<p>When a child process terminates before the parent process, the parent is responsible for ensuring the child process is reaped. In other words, the system resources associated with the child process need to be released, otherwise the child will become a zombie.</p> <p>But what if a parent process terminates before the child? Then the child becomes an orphan; it is usually then \"adopted\" by <code>init</code> (<code>pid</code>=1). (<code>init</code> is the first process started by an operating system; everything else is <code>fork</code>/<code>exec</code>'d from there.)</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#pipes","title":"Pipes","text":"<p>Main article: IPC and TCP/IP</p> <p>Pipes allow one-way data flow and can connect processes having a common ancestor. We can use a pipe to connect the <code>stdout</code> of one process to the <code>stdin</code> of another. For example, we can \"pipe\" the output of <code>program1</code> to <code>program2</code> like this:</p> <pre><code>./program1 | ./program2\n</code></pre> <p>Note that pipes and file redirects are not directly interchangeable. <code>&gt;</code> is used to direct <code>stdout</code> into a file; <code>|</code> is used to direct <code>stdout</code> into another process's <code>stdin</code>. Look at the difference between the following examples:</p> <pre><code>cat hello.txt &gt; goodbye.txt     // puts contents of hello.txt into a file called goodbye.txt\ncat hello.txt &gt; less            // puts contents of hello.txt into a __file__ called less\ncat hello.txt | less            // puts contents of hello.txt as stdin to the program less\n</code></pre> <p>You can, however, combine <code>|</code> and redirects (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;&gt;</code>). Give it a try! And check out the next section.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#fifo-aka-named-pipe","title":"FIFO, aka Named Pipe","text":"<p>A FIFO (First In First Out) or named pipe provides a slightly more flexible form of communication than a regular pipe. Since we can refer to FIFOs by name, we can get a bit more creative with how we use them.</p> <p>Recall the pipeline from Lab 5:</p> <pre><code>mkfifo mypipe\ncat mypipe | nc -l &lt;port #&gt; | /home/jae/.../mdb-lookup-cs3157 &gt; mypipe\n</code></pre> <p><code>mypipe</code> serves as a link between <code>nc</code> and <code>mdb-lookup-cs3157</code>. This accomplishes a circular pipeline: * <code>cat</code> pulls contents out of <code>mypipe</code> * The first <code>|</code> sends contents from <code>cat mypipe</code> to <code>nc</code> * The second <code>|</code> sends the output of <code>nc</code> as input to <code>mdb-lookup-cs3157</code> * <code>&gt;</code> sends output of <code>mdb-lookup-cs3157</code> into <code>mypipe</code> * Now there's something in <code>mypipe</code> for <code>cat</code> to pull out, and we start all over again</p> <p>Note that we redirect (<code>&gt;</code>) into <code>mypipe</code>, not <code>|</code> into it. <code>mypipe</code> itself is not a program or process, it's more like a file that we can read from and write to.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#sockets","title":"Sockets","text":"<p>Main article: IPC and TCP/IP</p> <p>Pipes and FIFOs are fine for local, one-way data flow, but often we want to communicate between processes that may not even be on the same machine. Sockets are a way to do just that. A socket is a type of file used for network communication between processes. Sockets are generalizations of pipes: with sockets, we can achieve both intramachine communication, as with our above examples, and intermachine communication. Additionally, sockets allow for two-way interprocess communication, unlike pipes. To talk about sockets, let's take a quick detour to TCP/IP.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#tcpip","title":"TCP/IP","text":"<p>TCP/IP is the protocol that makes the world go 'round. The internet is powered by IP (Internet Protocol), and almost all the traffic is TCP (Transmission Control Protocol). IP sends bundles of bytes called packets toward IP addresses. Instead of having to memorize IP addresses, we can use DNS to translate between IP addresses and hostnames.</p> <p>There are five protocol layers of TCP/IP networking: 1. Physical 2. Link 3. IP 4. Transport 5. Application The sockets API connects Transport and Application layers. We're mostly concerned with the Application layer.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#back-to-sockets","title":"Back to sockets","text":"<p>In order to send data via a socket connection, we need a few means of identification to figure out where the data needs to go: an IP address and a port number. The IP address is a unique identifier that is assigned to a computer or device on a TCP/IP network. A port number works together with an IP address to identify the application or process on the host to which data must be transmitted. If it helps, you can consider Beej's analogy: an IP address is like a hotel address and a port number is like a room number in that hotel. Port numbers range from 0 to 65535, but we can only use ports 1024 and above.</p> <p>We won't go over the socket API in depth here, but make sure you understand all the steps to create a server socket and a client socket. Definitely use the Donahoo slides to help you out.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#netcat","title":"Netcat","text":"<p><code>nc</code> is the Swiss army knife of the networking world. You can set up a server-client connection with the following commands:</p> <p>Set up a server listening on <code>&lt;port&gt;</code>: <pre><code>nc -l &lt;port&gt;\n</code></pre></p> <p>Connect a client to the server above: <pre><code>nc &lt;hostname or IP address of server&gt; &lt;server port&gt;\n</code></pre></p> <p>Vanilla <code>nc</code> has two jobs: get connected and share information. The server waits until a client connects to it. After that happens, some neat <code>stdin</code>/<code>stdout</code> redirecting happens. The server sends all of its <code>stdin</code> to the client, and prints everything it receives from the client to <code>stdout</code>. The same happens with the client: its <code>stdin</code> is sent to the server, and it prints what it receives from the server to <code>stdout</code>. So, effectively, the <code>stdin</code> of the client is sent to the <code>stdout</code> of the server, and the <code>stdin</code> of the server is sent to the <code>stdout</code> of the client. You can think of it as a super simple instant messenger!</p> <p><code>nc</code> can obviously do more complex things when used in conjunction with pipes, named pipes, redirects, etc. Take another look at the pipeline from Lab 5 and make sure you fully understand it.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#http","title":"HTTP","text":"<p>Make sure you understand HTTP in depth (to the extent that you needed it for Lab 6). You can read more about HTTP/1.0 here.</p> <p>To request information from a server, you can formulate a GET request as follows: <pre><code>GET /path/file.html HTTP/1.0\n[zero or more headers ...]\n[a blank line, must be '\\r\\n']\n</code></pre> The response from the web server looks something like this: <pre><code>HTTP/1.0 200 OK\nDate: Fri, 31 Dec 1999 23:59:59 GMT\nContent-Type: text/html\nContent-Length: 1354\n\n&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;Happy New Millennium!&lt;/h1&gt;\n(more file contents)\n.\n.\n.\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#c-basics","title":"C++ Basics","text":"<p>Main article: Introducing C++</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#whats-different","title":"What's different?","text":"<ul> <li>Classes/structs: default constructor</li> <li>References</li> <li>Stack allocation and heap allocation (<code>new</code>/<code>delete</code>)</li> <li>The Basic 4</li> <li>Function overloading</li> <li>\"Real\" strings (<code>MyString</code>)</li> </ul>"},{"location":"resources/cs3157recitations/midsemester-review-2/#references","title":"References","text":"<p>In C, when you call a function, you pass arguments by value: a brand new copy of the argument is made for the function to use. That's why we needed pointers. Remember the following example? <pre><code>void swap(int x, int y) {\n    int tmp = x;\n    x = y;\n    y = tmp;\n    return;\n}\n</code></pre> This doesn't actually work, because <code>swap()</code> gets its own copies of the parameters. <code>swap()</code> never even touches the \"original\" <code>x</code> and <code>y</code> that it is called with. Instead, you needed to do something like this: <pre><code>void swap(int *x, int *y) {\n    int tmp = *x;\n    *x = *y;\n    *y = tmp;\n    return;\n}\n</code></pre> C++ has something new: a construct known as a reference. You can think of a reference as a dereferenced pointer to something. Here's a quick example: <pre><code>int x = 5;\nint&amp; y = x; //y is a reference to x\n\nx = 6; //y is now 6\ny = 7; //x is now 7\n</code></pre> <code>y</code> and <code>x</code> are essentially the same thing. You could write <code>swap()</code> in C++ like this: <pre><code>void swap(int&amp; x, int&amp; y) {\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre> Cool, right?</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#stack-and-heap-allocation","title":"Stack and Heap Allocation","text":"<p>Allocating space on the stack for a struct in C++ looks exactly the same as it does in C, e.g. <pre><code>struct Pt myPt; // you can omit the \"struct\" in C++\n</code></pre> Even though they look the same, though, they actually don't operate the same way. In C++, classes and structs have special functions called constructors that initialize all data members and base classes when the class/struct is allocated.</p> <p>Heap allocation is also different in C++. You can still use <code>malloc()</code> and <code>free()</code>, but <code>malloc()</code> doesn't allow you to call the constructor. Instead, you can use the <code>new</code> keyword, like this: <pre><code>Pt *myPt = new Pt; //allocates sizeof(Pt) space on heap, calls constructor\nPt *someArray = new Pt[10]; //heap-allocated array of Pts\n</code></pre> Just like every <code>malloc()</code> must have a <code>free()</code>, every <code>new</code> must have a <code>delete</code>: <pre><code>delete myPt;\ndelete [] someArray;\n</code></pre></p> <p>Don't mix up <code>malloc()</code>/<code>free()</code> and <code>new</code>/<code>delete</code>.</p>"},{"location":"resources/cs3157recitations/midsemester-review-2/#the-basic-4","title":"The Basic 4","text":"<ol> <li>Constructor<ul> <li>Called when an object is allocated on stack/heap</li> </ul> </li> <li>Destructor<ul> <li>Called when an object goes out of scope/<code>delete</code> is used</li> </ul> </li> <li>Copy Constructor<ul> <li>Called when object needs to be copied (e.g. passed as argument)</li> </ul> </li> <li>Operator=()<ul> <li>Called when an object is assigned to a variable</li> </ul> </li> </ol> <p>Make sure you understand why all of the above are necessary when you're writing a class or struct.</p>"},{"location":"resources/cs3157recitations/reading-list/","title":"Reading list","text":""},{"location":"resources/cs3157recitations/reading-list/#the-descent-to-c","title":"The Descent to C","text":"<p>by Simon Tatham (author of PuTTY)</p> <p>An \"orientation\" to C for those coming from a higher level language (e.g., Java or Python). It helps explain why C is different, and how that's good (at least for some things). Probably most useful around lab 2, once you've actually  writen some C code. May also be useful as a review for midterm #1.</p>"},{"location":"resources/cs3157recitations/reading-list/#reading-c-type-declarations","title":"Reading C Type Declarations","text":"<p>Strategy for dissecting complex C declarations.</p>"},{"location":"resources/cs3157recitations/reading-list/#the-perils-of-java-schools","title":"The Perils of Java Schools","text":"<p>Jae's favorite article on CS education. It talks about why Java is a dangerous language to learn with, and C is important for education. </p>"},{"location":"resources/cs3157recitations/reading-list/#standard-input","title":"Standard Input","text":"<p>Totally confused by UNIX stdin, stdout, etc? This short article may help clarify how standard input and output work for processes in UNIX.</p>"},{"location":"resources/cs3157recitations/reading-list/#learn-c-the-hard-way","title":"Learn C the Hard Way","text":""},{"location":"resources/cs3157recitations/reading-list/#why-mobile-web-apps-are-slow","title":"Why Mobile Web Apps are Slow","text":"<p>by Drew Crawford</p> <p>This is a lonng article, probably best to read toward the end of the class. Comments by Jonathan Balsano.</p> <p>Why?</p> <p>It touches on some really important technical aspects of mobile programming that you'll learn about as part of your CS education here. (Also, you probably didn't think you were going to need those concepts in the developer world - they're probably only useful for academia, right?) After AP you should be able to get through it, but you might be a little confused. I encourage you to hold onto the article, though, because after you take courses like Fundamentals, OS, and PLT, more and more of the article will make sense and tie together the ideas you've learned in a very real and applicable way. In a really nerdy way, I was excited while reading it because I could feel all these seemingly unrelated things coming together in a very technical way.</p> <p>Also, I've heard people complain you learn things you'll never use again in this class, like C, memory management, etc. \"Garbage collected languages like Ruby, Python, and Java are the way of the future\" they say. My response to this has always been that its still important to learn the languages because its not just about the language, but the abstractions C and C++ are built around. In particular, C's (and in turn C++'s) syntax and constructs are so tightly linked to the OS underneath its impossible to learn pointers and arrays without understanding some essential OS concepts (like memory).</p> <p>What?</p> <p>A lot of things, but the last part about memory management is most applicable to what we've learned in this class.</p> <p>\"Why's he keep bringing up memory?\" you're thinking. It's because the third argument in the article, the part about Garbage Collection and Automatic Reference Counting (ARC, basically smart pointers in Objective C). Here's my quick summary that's surely missing about 95% of the information in the article:</p> <p>In a world that's becoming increasingly mobile, we're hitting up against a lot of the boundaries of processing power, in part because of the need for portability. Over the past decade, our answer to making things faster has often been \"Just throw more CPUs/servers/computers at it\" but that's not really possible in the mobile world due to size and power constraints. Unfortunately, in memory constricted environments (like your phone) being oblivious to memory isn't going to work. </p> <p>In these cases, you're going to have to understand how memory works. Whether you're working on Android (with garbage collection) or iOS (ARC), you need to know how much memory you're using underneath, because for the next 5-10 years (at least) the mobile memory problem seems unlikely to change.</p>"},{"location":"resources/cs3157recitations/reading-list/#c-vs-c-linus-perspective","title":"C vs C++: Linus' perspective","text":"<p>Linus Torvalds, the man who wrote Git and Linux kernel, is a famous C++ hater.  Here is his famous hate mail on C++: http://article.gmane.org/gmane.comp.version-control.git/57918</p>"},{"location":"resources/cs3157recitations/reading-list/#att-labs-video-on-unix","title":"AT&amp;T Labs Video on UNIX","text":"<p>http://www.youtube.com/watch?v=tc4ROCJYbm0</p> <p>It is a 1982 video from AT&amp;T introducing their shinny new invention: UNIX.  It talks about some of the things we covered/will cover this week and next week, but you get to hear it from the true giants in the field: the late Dennis Ritchie (the inventor of C &amp; co-inventor of UNIX), Ken Thompson (co-inventor of UNIX), Brian Kernighan (the K in K&amp;R), and our own Professor Al Aho (the A in AWK, the grand daddy of all modern scripting languages).</p>"},{"location":"resources/cs3157recitations/reading-list/#wwwdaemon","title":"WWWDaemon","text":"<p>The original (ok, a very early version, 0.1) HTTP web server by Tim Berner's Lee. Very similar to lab7 server.</p>"},{"location":"resources/cs3157recitations/reading-list/#stanford-cs106l-course-reader","title":"Stanford CS106L Course Reader","text":"<p>Stanford's intro C++ class has a lab section, 106L. They've written a ~600 page textbook, but it's an incredibly good resource for learning all about everything we've done. For example, they have pages and pages on how linking works. Highly recommended, but be aware it's focused only on C++, so most of the stuff applies to C, but not all.</p>"},{"location":"resources/cs3157recitations/reading-list/#you-cant-dig-upwards","title":"You Can't Dig Upwards","text":"<p>An article about why only knowing Python is like only knowing how to drive an automatic transmission car. Basically, python is too easy, and you don't understand how a computer actually works.</p>"},{"location":"resources/cs3157recitations/reading-list/#valgrind-is-not-a-leak-checker","title":"Valgrind is NOT a Leak Checker","text":"<p>An article about why leak checking is one of the less useful features Valgrind offers. </p>"},{"location":"resources/cs3157recitations/reading-list/#to-add","title":"To Add","text":"<ul> <li>Heartbleed and goto fail writeups</li> <li>The Unreasonable Effectiveness of C</li> </ul>"},{"location":"resources/cs3157recitations/reading-list/#to-vet","title":"To Vet","text":"<ul> <li>C++ Value Semantics: http://akrzemi1.wordpress.com/2012/02/03/value-semantics/</li> <li>Integer Represenations: http://pages.cs.wisc.edu/~smoler/x86text/lect.notes/represent.html</li> <li>Why should I use a pointer, rather than an object?: http://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself</li> <li>How to debug small programs: http://ericlippert.com/2014/03/05/how-to-debug-small-programs/#</li> <li>C structure packing http://www.catb.org/esr/structure-packing/</li> <li> <ul> <li>Implementing malloc: http://danluu.com/malloc-tutorial/</li> </ul> </li> <li>21st Century C: O'Reilly book about how we're all dinosaurs for returning 0 from main http://clio.columbia.edu/catalog/10816384?counter=1</li> <li>Was C for Hipsters?</li> <li>HTTP Made Really Easy</li> <li>A Guide to Undefined Behavior in C and C++</li> <li>I Do Not Know C -- Q&amp;A with some tricky undefined behavior questions.</li> <li>What a C programmer should know about memory</li> <li>Are pointers and arrays equivalent in C?</li> <li>Back to Basics Joel Spolsky of Joel on Software writes about C strings being awful, and why malloc is slow, etc.</li> </ul>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/","title":"Unix, Text Editors, and Compiling","text":""},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#logging-in","title":"Logging in","text":"<ul> <li>If you're on a Mac, open up the Terminal app.</li> <li>If you're on Windows, install MobaXterm.</li> <li>Type <code>ssh your_uni@clac.cs.columbia.edu</code>. You will be prompted for your CLAC password.</li> <li>If you want to share graphical programs as well as the shell with the remote machine, enable X11 Forwarding: <code>ssh -Y your_uni@clac.cs.columbia.edu</code></li> </ul>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#changing-your-password","title":"Changing your password","text":"<p>Earlier this week, we generated a password and emailed it to you. You may want to change your password by entering the command:</p> <pre><code>passwd\n</code></pre> <p>Enter your current password and hit return. Then, enter your new password. For security reasons, your keystrokes are not displayed when typing passwords.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#what-about-clic","title":"What about CLIC?","text":"<p>You might've heard about CLIC, the CS department's computing service. We used to require CLIC accounts for this course, but we are now running our own computing infrastructure called CLAC. It stands for \"C Language is Awesome and Cool.\"</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#basic-unix","title":"Basic UNIX","text":""},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#paths","title":"Paths","text":"<p>A good place to start with UNIX is the filesystem structure. Our CLAC machines run Ubuntu Linux. Unlike Windows machines, UNIX uses forward slashes to separate each part of the file path.</p> <p>An example file path in UNIX might be <code>/usr/bin/dict</code>. The path <code>/</code> by itself denotes the highest level directory. If you start any path with a forward slash, it will assumed to be a path relative to the root directory <code>/</code>.</p> <p>Alternatively, your current directory is represented by <code>./</code>. In most cases you can leave this off. You can find out your current directory using the command <code>pwd</code>.</p> <p>If your current directory is <code>/students/alice</code> and you wish to reference the directory <code>/students</code> in a path, you can do so in two ways:</p> <ul> <li><code>/students</code> \u2014\u00a0an absolute path (begins with <code>/</code>)</li> <li><code>../</code> \u2014 a relative path (does not begin with <code>/</code>)</li> </ul> <p><code>../</code> denotes the directory above the current directory. You could reference the root directory <code>/</code> from the directory <code>/students/alice</code> using the relative path <code>../../</code>.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#basic-navigation","title":"Basic Navigation","text":"<p>When you log into CLAC, your current (working) directory will be <code>/students/your_uni</code>. Check this by typing:</p> <pre><code>pwd\n</code></pre> <p>This is your home directory. All of your files on CLAC are stored in this directory, and you can do pretty much whatever you want to them. You own the place.</p> <p>Let's view all the files in the current directory:</p> <pre><code>ls\n</code></pre> <p>Let's make some new directories here for your work in this class. Use the <code>mkdir</code> command to make a new directory:</p> <pre><code>mkdir cs3157\nmkdir cs3157/learning\n</code></pre> <p>Now let's move into your working directory. Use the change directory command, <code>cd</code>. All three commands below will do the same thing. (Which paths are relative, and which ones are absolute?)</p> <pre><code>cd cs3157/learning\ncd ./cs3157/learning\ncd /students/your_uni/cs3157/learning\n</code></pre> <p>Let's create a new text file using the <code>touch</code> command. This will create a new empty file if one does not exist, or update the last modified date if the file exists.</p> <pre><code>touch testing.txt\ntouch .hidden.txt\n</code></pre> <p>Did both commands work? Try the <code>ls</code> command again.</p> <p>Some commands in UNIX take flags. These are special arguments preceded by a dash. The two flags we use the most with <code>ls</code> are:</p> <ul> <li><code>-l</code> shows more information about each file, such as the size, owner, and permissions.</li> <li><code>-a</code> includes files that are hidden. In UNIX, these are files whose names start with a period, such as <code>.hidden.txt</code>.</li> </ul> <p>Try these commands. Notice how the output changes for each one.</p> <pre><code>ls\nls -l\nls -a\n</code></pre> <p>We can also combine flags for <code>ls</code>:</p> <pre><code>ls -la\n</code></pre> <p>Now let's delete our hidden file using the remove command, <code>rm</code>.</p> <pre><code>rm .hidden.txt\nls -la\n</code></pre> <p>Alright, now let's get rid of the directory we created here. Just as with <code>.hidden.txt</code>, we'll use the <code>rm</code> command.</p> <p>However, <code>rm</code> doesn't let you delete directories unless you specify to run it recursively (<code>-r</code>) (repeatedly go into each subdirectory and delete all files). It will also ask for confirmation that you want to delete files unless you tell it to force the delete (<code>-f</code>).</p> <pre><code>cd ../\nrm -rf learning\nls -la\n</code></pre> <p>One last thing as a side note: if you ever don't know how to use a command in UNIX (or even a function in the standard C library) you can use the <code>man</code> command. It will bring up the manual pages for the command you ask it for. Try to learn more about the ls command:</p> <pre><code>man ls\n</code></pre> <p>Use <code>q</code> to quit out of a man page.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#useful-tricks","title":"Useful Tricks","text":""},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#tab-completion","title":"Tab completion","text":"<p>Tab completion is a feature that auto-completes your commands when you press the tab key. For example, typing <code>tou</code> followed by the tab key will complete to <code>touch</code>. Tab completion also works for directory and file names.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#previous-command","title":"Previous command","text":"<p>You can go through your history by pressing the up and down arrows in terminal. This will navigate between previously used commands so that you can easily use the same commands over and over.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#reverse-intelligent-search-reverse-i-search","title":"Reverse intelligent search (reverse-i-search)","text":"<p>You can also search through your command history. Press Ctrl-R to bring up the search prompt. Start typing until you find the command you're looking for.</p> <p>This feature is especially useful for long, complicated commands that you rarely use. Instead of memorizing them, you can simply search your history.</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#text-editors","title":"Text Editors","text":"<p>There are two main text editors that you can use from inside terminal: <code>emacs</code> and <code>vim</code>. Although we are teaching the course with <code>vim</code>, which editor you use is ultimately your decision. (You could even write everything in <code>nano</code> if you really wanted, but it might get annoying.)</p>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#vim","title":"Vim","text":"<p>Vim is a difficult to use text editor and can be confusing at first. Its goal is to be incredibly efficient by preventing unnecessary movement of your hands around the keyboard. It operates in different modes, the most important of which will be normal (command) mode and insert mode.</p> <p>Launch Vim and tell it the filename you want to edit:</p> <pre><code>vim myfile\n</code></pre> <p>When you open vim, it will be in Normal mode. Typing will cause a variety of different operations to happen. For now switch to Insert Mode by pressing <code>i</code>. You should see <code>-- INSERT --</code> appear at the bottom of the screen. At this point anything you type will appear as text in the text file. This is fine for basic editing.</p> <p>Now let's switch back to Normal mode. Press the <code>esc</code> key to switch back.</p> <p>Most vim commands execute as soon as you type them. Here are some basic commands that will execute immediately:</p> <ul> <li><code>h</code> (left), <code>j</code> (down), <code>k</code> (up), and <code>l</code> (right) are how you move while in     Normal mode. You may also use the arrow keys.</li> <li><code>dd</code> deletes the current line</li> <li><code>D</code> deletes from the current location to the end of the line</li> <li><code>yy</code> copies the current line</li> <li><code>p</code> pastes whatever has been previously copied or deleted</li> <li><code>0</code> jumps to the beginning of the line</li> <li><code>$</code> jumps to the end of the current line</li> <li><code>w</code> jumps to the beginning of the next word (<code>W</code> uses a broader definition of word)</li> <li><code>b</code> jumps to the end of the previous word (likewise <code>B</code>)</li> <li><code>u</code> undoes the last change</li> <li><code>Ctrl-R</code> redoes the last change</li> </ul> <p>Some vim commands will not be executed until you press enter. These begin with a colon.</p> <ul> <li><code>:w [optional filename]</code> \u2014 save the current file if no file name is passed,     or write the current file to specified location.</li> <li><code>:x</code> or <code>:wq</code> \u2014 save and quit</li> <li><code>:e filename</code> \u2014 open the filename specified</li> <li><code>:q</code> \u2014 quit vim and return to the shell</li> <li><code>:[line number]</code> \u2014 jump to that line</li> </ul> <p>In vim, most commands work with some sort of combination between prepositions and actions. For example, <code>gg=G</code> would indent the entire file, as <code>gg</code> takes you to the beginning of the file, <code>=</code> auto-indents a line, and <code>G</code> jumps to the end of the file.</p> <p>To practice the above commands and learn some more, try running the built-in tutorial:</p> <pre><code>vimtutor\n</code></pre> <p>Alternatively, check out Open Vim's Tutorial for another interactive vim lesson. Or play a little NES Zelda type game while learning vim, with Vim Adventures.</p> <p>After learning vim, you might want to configure it. This is done by editing the .vimrc file in your home directory. Let's check out our current settings.</p> <pre><code>vim ~/.vimrc\n</code></pre> <p>There should be default settings there already, but you can look to make changes here in the future. Jae and the TAs will send out their configurations later, but a good starting point is to enable line numbers and syntax highlighting by adding this to your .vimrc:</p> <pre><code>set number\nsyntax on\n</code></pre>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#emacs","title":"Emacs","text":"<p>May be skipped for time</p> <p>Emacs is an easier to pick up text editor, and many of its commands are identical to those of the shell.</p> <p>Let's start by editing a new file in emacs:</p> <pre><code>emacs myfile\n</code></pre> <p>As soon as emacs starts running, you will be able to type into it. There is no special insert mode like in vim. You can backspace at any time without having to switch between modes.</p> <p>Emacs has the same functionality as vim, and we present the basics below:</p> <ul> <li>'Ctrl-f' will move your cursor forward, 'Ctrl-b' will move it back, 'Ctrl-p'     will move it up, 'Ctrl-n' will move it down; the arrow keys work as well</li> <li>'Ctrl-s' will search for a word forward, 'Ctrl-r' will search for a word backward</li> <li>'Ctrl-a' goes to beginning of line, 'Ctrl-e' goes to end</li> <li>'Ctrl-k' will delete the portion of the current line after the cursor</li> <li>'Ctrl-spacebar' to select text to manipulate</li> <li>'Esc-w' to copy text, 'Ctrl-w' to cut text, Ctrl-y' will paste your most     recently copied/deleted text</li> <li>'Esc-g g' then enter a line number to jump to a particular line in the buffer</li> </ul> <p>To exit and save we will use Ctrl-X + Ctrl-C. If you just want to save then use Ctrl-X + Ctrl-S.</p> <p>Just like vim, emacs also has a configuration file that you can edit. This is .emacs file within your home directory. Let's check out our emacs settings.</p> <pre><code>emacs ~/.emacs\n</code></pre> <p>There should be default settings there already, but feel free to add more for shortcuts.</p> <p>Note that backspaces can be a little funky when ssh-ing into CLAC and your backspace button might actually be sending \"Ctrl + H\" instead! To fix this you *will have to add the following lines to your .emacs file.</p> <pre><code>;; make sure backspace deletes backwards\n(normal-erase-is-backspace-mode 1)\n;; make sure your backspace is mapped correctly\n(global-set-key \"\\C-h\" 'backward-delete-char)\n</code></pre> <p>And if you want mouse support, you'll have to add the following:</p> <pre><code>(require 'mouse) ; mouse support\n(xterm-mouse-mode t) ; Turn on mouse mode\n(defun track-mouse (e)) ; Track the mouse\n(setq mouse-sel-mode t) ; Mouse selection\n(delete-selection-mode 1) ; For deleting the current selection\n(global-set-key [mouse-4] (lambda () (interactive) (scroll-down 1))) ; For scrolling up\n(global-set-key [mouse-5] (lambda () (interactive) (scroll-up 1))) ; For scrolling down\n</code></pre>"},{"location":"resources/cs3157recitations/A-Unix/unix-editors-compiling/#compiling-and-linking-a-c-program","title":"Compiling and Linking a C Program","text":"<p>Just like Java code, C code can't be run directly on the CPU. It's converted to an executable in these three steps:</p> <ol> <li> <p>Pre-processing: This is when the compiler processes lines that start      with a hashmark <code>#</code>. For example, a line like <code>#include \"somefile.h\"</code> would      be replaced with the contents of somefile.h. All other lines are passed      onto the next step without modification.</p> </li> <li> <p>Compiling: This converts the C source code into a lower level language      that's specific to the operating system and type of CPU in the computer. It      reads C source code files (such as <code>foo.c</code>) and saves its output to object      files (<code>foo.o</code>).</p> </li> <li> <p>Linking: The previous step may have produced several .o files that each      contain part of our program's code. Linking puts all of that code together      into a single file that we can execute.</p> </li> </ol> <p>Let's take a look at this process in an actual program. We'll create a simple program that computes 1 + 2 by calling a function in another file.</p> <p>main.c</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"myadd.h\"\n\nint main(int argc, char **argv) {\n  printf(\"The sum is: %d \\n\", add(1, 2));\n  return 0;\n}\n</code></pre> <p>myadd.h</p> <pre><code>#ifndef __MYADD_H__\n#define __MYADD_H__\nint add(int a, int b);\n#endif\n</code></pre> <p>Now let's try to compile myadd. First we'll build the object file for main.c. Notice the compiler directive <code>#include</code>. This tells the compiler to just copy paste the specified file into the current file at that location. The reason we include this line in main.c is so that if we reference a function in either of these files before it is defined, the compiler can know its header.</p> <p>As an example, in main.c we have <code>add(1, 2);</code>. The compiler wants to make sure that this is a valid function call, but knows nothing of the function \"add\", what type it will return, or what its explicit parameters are. Including myadd.h will tell the compiler that \"add\" returns type int, and accepts two integer parameters.</p> <p>Let's compile <code>main.c</code>:</p> <pre><code>gcc -g -Wall -c main.c\n</code></pre> <p>What do these parameters mean?</p> <ul> <li><code>-g</code> \u2014 include extra information so that, if the program crashes, we can     know which line and function caused the crash</li> <li><code>-Wall</code> \u2014\u00a0turns on a lot of compile-time warnings. Warnings are likely     problems with your code, but they aren't so severe as to be errors that mean     it won't run at all. These can be small problems now that cause big crashes     later, so it's best to turn this on when compiling and fix all warnings.</li> <li><code>-c</code> \u2014 only preprocess and compile the files (do not link them yet)</li> </ul> <p>After running the command above, you should have a main.o in your directory.</p> <p>There was one other set of directives that we've used now. The <code>#ifndef</code> <code>#define</code> and <code>#endif</code> directives. The first and the last define a block of code that should only be included if a pre-processor variable is not defined. This will prevent multiple header files from conflicting. If myadd.h is included more than once, the first time the pre-processor will define _MYADD_H and each time thereafter will skip over the entire file.</p> <p>Pause here for a moment, and think: what haven't we done yet?</p> <p>We haven't even written the <code>add()</code> function yet. It's nowhere at all. However, gcc let us compile main.c without even giving us a warning! That's because we included <code>myadd.h</code>, which gives a prototype for the add function, so gcc knows that the function call in <code>main()</code> is valid. That's all the compiler needs, it doesn't care how <code>add()</code> works, just that it will exist and is being validly used.</p> <p>However if we try to link it into an executable, we get an error because during linking, it actually needs the code for <code>add()</code>:</p> <pre><code>gcc -g main.o -o main\n</code></pre> <ul> <li><code>-o filename</code> \u2014\u00a0tells GCC what to name the output file</li> </ul> <p>myadd.c</p> <pre><code>#include \"myadd.h\"\nint add(int x, int y)\n{\n    return x + y;\n}\n</code></pre> <p>It's a good idea to `#include \"myadd.h\" in myadd.c even though we aren't required to. Doing this allows the compiler to make sure the functions we write in the .c file match the prototypes from the .h file. This feature will become more useful as our programs become more complicated.</p> <p>Now let's compile <code>myadd.c</code></p> <pre><code>gcc -g -Wall -c myadd.c\nls\n</code></pre> <p>And then finally link our two object files into the executable <code>main</code>.</p> <pre><code>gcc -g myadd.o main.o -o main\nls\n</code></pre> <p>You should now have an executable file in your directory <code>main</code>. Running <code>./main</code> will run your program.</p> <p>In this case, you must use <code>./</code> to indicate that you want to execute the program main in the current directory. Otherwise, it will try to look for a system program named \"main,\" which doesn't exist on our system.</p> <p>Building C programs by hand is extremely tedious. In the next review session, we'll learn how to automate compilation and linking with Makefiles.</p> <p>For more on compiling, linking, and debugging, see this article.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/","title":"Makefiles","text":"<p>Make is a UNIX utility that helps you compile programs by following a blueprint you specify.</p> <p>Calling <code>make</code> will first automatically search your current directory for a file called <code>Makefile</code>. Then, Make will use it to call various shell commands, according to the rules outlined therein. This allows you to chain together complex sequences of commands you would use to compile a program.</p> <p>In other words, you can execute all the preprocessing, compiling, and linking commands just by typing <code>make</code>. It's also a handy way to automate cumbersome tasks, like cleaning up build products.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#the-myadd-makefile-in-10-steps","title":"The <code>myadd</code> <code>Makefile</code> in 10 Steps","text":"<p>In this repository, you'll find a directory named <code>myadd-demo</code>, which contains an interactive, step-by-step demo which shows you how to create a simple Makefile from scratch. You may use the <code>./demo</code> to step through different versions of the <code>Makefile</code>, and use it to run <code>make</code> during each step. You may also inspect the <code>Makefile</code>s for each step under <code>myadd-demo/Makefiles</code>.</p> <p>This guide will follow the demo and explain what's happening with the <code>Makefile</code> at each step.</p> <p>If you prefer to just see a completed, annotated <code>Makefile</code>, you can check out the <code>sample-Makefile</code> in this directory. Note that it does not use all the features touched upon in this guide, but is sufficient for the entire 3157 course.</p> <p>You may also explore the <code>practice</code> directory for some practice with <code>Makefile</code>s.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#introduction","title":"Introduction","text":""},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#source-code","title":"Source code","text":"<p>Before we get started, let's (re)familiarize ourselves with the files we're compiling:</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#myaddh","title":"<code>myadd.h</code>","text":"<p>This is where the function prototype for the <code>add()</code> function is declared. It tells the compiler that somewhere in the final program, we'll have an implementation of the <code>add()</code> function, with the given type signature. If you're familiar with Java, you can think of this as something like a Java <code>interface</code> (though without the notion of a class).</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#myaddc","title":"<code>myadd.c</code>","text":"<p>This is where the <code>add()</code> function is actually implemented. Note that this <code>#include</code>s <code>myadd.h</code> because we want to make sure that the compiler knows which <code>add()</code> function we're implementing, and so that it can check that we're using the right type signature.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#mainc","title":"<code>main.c</code>","text":"<p>This is where we call the <code>add()</code> function, and print its result. We <code>#include</code> <code>myadd.h</code> because we're calling a function that we haven't implemented in this <code>.c</code> file (also called a compilation unit).</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#compilation","title":"Compilation","text":"<p>Recall that there are three actions we need to perform in order to build <code>main</code>:</p> <pre><code>gcc -g -Wall -c myadd.c         # compiles myadd.c =&gt; myadd.o\ngcc -g -Wall -c main.c          # compiles main.c =&gt; main.o\ngcc -g main.o myadd.o -o main   # links main.o and myadd.o =&gt; main\n</code></pre> <p>We use the <code>-g</code> and <code>-Wall</code> flags to include debugger symbols and enable all compiler warnings. The <code>-o</code> flag specifies that the resulting file shall be named as the argument after it, <code>main</code>.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-0","title":"Step 0","text":"<p>First, let's get the <code>Makefile</code> building just one thing. To do so, we write a rule to build a target. The syntax of a Makefile is as follows:</p> <pre><code>[target]: [dependencies...]\n    [shell command]\n    ...\n</code></pre> <p>This says that to build <code>target</code>, we must first satisfy the one or more <code>dependencies</code> that come after the <code>:</code>. Then, once dependencies are satisfied, we build the target with one or more shell commands.</p> <p>Note that before the shell command you must use a TAB character (and not just 4 or 8 spaces). Make sure your text editor is aware of this if you've configured it to expand your tabs.</p> <p>Let's write our rule to build <code>myadd.o</code>, from <code>myadd.c</code>:</p> <pre><code>myadd.o: myadd.c myadd.h\n    gcc -g -Wall -c myadd.c\n</code></pre> <p>Note that just because a file is a dependency doesn't mean that it actually needs to be used in the build command. We don't need to tell <code>gcc</code> about <code>myadd.h</code> because the <code>#include</code> preprocessor macro handles that for us. But we still need to let Make know that it should rebuild <code>myadd.o</code> if updates are made to either <code>myadd.c</code> or <code>myadd.h</code>, which is why we specify <code>myadd.h</code> as a dependency.</p> <p>With this as the only thing our <code>Makefile</code>, if we run <code>make</code>, we'll see that <code>myadd.o</code> is built for us!</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-1","title":"Step 1","text":"<p>Now, let's also write the rule for building <code>main.o</code>. Since <code>main.c</code> also <code>#include</code>s <code>myadd.h</code>, we should also specify that as a dependency:</p> <pre><code>main.o: main.c myadd.h\n    gcc -g -Wall -c main.c\n</code></pre> <p>Now, what happens when you type <code>make</code> will depend on where you've written this rule. If <code>make</code> is given no arguments, it will just build the first target that is explicitly specified in the <code>Makefile</code>. In the demo, we've written the <code>main.o</code> rule above the <code>myadd.o</code> rule, so if you type <code>make</code> now, you should see only <code>main.o</code> building.</p> <p>We can still build targets that aren't the default (top) target. If we wanted to explicitly tell Make to build <code>myadd.o</code>, we can run <code>make myadd.o</code>.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-2","title":"Step 2","text":"<p>Time to link! Let's put our linking rule at the very top, to make sure it's the default target when we run <code>make</code>:</p> <pre><code>main: main.o myadd.o\n    gcc -g main.o myadd.o -o main\n</code></pre> <p>Note that we did not specify <code>myadd.h</code> as a dependency. That's because linking doesn't need this header file at all. <code>main</code> will still be rebuilt if <code>myadd.h</code> is updated, but because it implicitly inherits this dependency from its own dependencies, <code>main.o</code> and <code>myadd.o</code>.</p> <p>Now that we have a more complex <code>Makefile</code>, we can dig deeper into what it means for a target to \"depend\" on others. Recall that every file in UNIX has a \"last modified\" timestamp, which is updated any time the file is changed or <code>touch</code>ed. A target is built only if it does not exist, or if one or more of its dependencies have a later timestamp than it. The reason Make does this rather than rebuilding the entire program from scratch is because for large software projects, rebuilding from scratch every time can be very inefficient. Instead, Make just rebuilds outdated targets as necessary.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-3","title":"Step 3","text":"<p>It's sometimes useful to clean up your project directory and get rid of all your build products. In this case, the <code>main</code> executable and any <code>.o</code> files. If we built anything by hand, we may also have produced an executable named <code>a.out</code>, which we'll want to get rid of too. We can do that with the following:</p> <pre><code>rm -rf main *.o a.out\n</code></pre> <p>We want to sure <code>rm</code> just does what its told (and doesn't choke on, say, some directory mischieviously named <code>main</code>), so we pass it the <code>-rf</code> flag. But having to type this all the time can be pretty cumbersome.</p> <p>It turns out that Make targets don't have to be files! We can create a shortcut for ourselves with the following rule:</p> <pre><code>clean:\n    rm -rf main *.o a.out\n</code></pre> <p>Now we can just clean up our project by running <code>make clean</code>. Isn't that neat?</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-4","title":"Step 4","text":"<p>Actually, there's a problem with the <code>Makefile</code> we left off with from step 3. Consider the following sequence of commands:</p> <pre><code>$ make\ngcc -g -Wall -c main.c\ngcc -g -Wall -c myadd.c\ngcc -g main.o myadd.o -o main\n$ touch clean\n$ make clean\nmake: `clean' is up to date.\n</code></pre> <p>If you run <code>ls</code> now, you'll find that nothing has been cleaned. You'll also find a file named <code>clean</code>, that was created by the <code>touch clean</code> command. Because this file already exists, and its timestamp is not older than any of its dependencies (since it has none), Make will not try to \"build\" the <code>clean</code> target.</p> <p>This kind of situation doesn't happen very often, but can be very frustrating when it does. To get around it, we need to tell Make that this is a \"phony\" target, using the special <code>.PHONY</code> directive, so that it ignores the timestamp and runs the <code>clean</code> target every time:</p> <pre><code>.PHONY: clean\nclean:\n    rm -rf main *.o a.out\n</code></pre>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#interlude","title":"Interlude","text":"<p>At this point, you now have the basis complete <code>Makefile</code>. You can jump to this part of the demo by running:</p> <pre><code>./demo explicit\n</code></pre> <p>Every target in here is explicit, which means for larger software projects, you'll be doing a lot of typing. But as you'll soon find out, Make is powerful enough to do some of the thinking for you, and save you from doing busy work.</p> <p>In the following sections, we'll be explaining some of the fancier things you can do with your Makefile by leveraging variables, implicit rules, and other nifty features.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-5","title":"Step 5","text":"<p>Make actually comes with a lot of the same features as shell scripting languages like Bash and Python. One of these is the ability to assign variables.</p> <p>Notice that every time compile, we use the same <code>-g -Wall</code> flags (in addition to the <code>-c</code> flag). It doesn't seem like a big deal now, but if we were compiling hundreds of compilation units and wanted to remove the <code>-Wall</code> flag from all of them, that could get really annoying. (More annoying than those pesky warnings you're trying to silence! But please leave in the <code>-Wall</code> flag for this class, it's a good habit make.)</p> <p>Instead, we add one more level ofindirection by assigning those flags to a compiler flags variable instead:</p> <pre><code>CFLAGS = -g -Wall\n</code></pre> <p>Now, in our rules, Make will substitute any instance of <code>$(CFLAGS)</code> it comes across with <code>-g -Wall</code>. For example:</p> <pre><code>gcc $(CFLAGS) -c main.c\n</code></pre> <p>We can do the same with the compiler command itself, <code>gcc</code>, as well as the <code>-g</code> flag we're passing to the linking rule:</p> <pre><code>CC = gcc\nLDFLAGS = -g\n</code></pre> <p><code>CC</code> stands for \"C Compiler,\" and <code>LDFLAGS</code> means \"linking flags.\" Now we can compile and link with the following:</p> <pre><code>$(CC) $(CFLAGS) -c main.c\n$(CC) $(LDFLAGS) main.o myadd.o -o main\n</code></pre> <p>Now we can easily swap out the compiler and linking flags for our entire project by modifying the build variables we've defined at the top of our <code>Makefile</code>.</p> <p>It's not entirely obvious yet why we chose to substitute these particular parts of our build commands, or why we're using such particular variable names. Why this is important will become clear in step 8 when we use implicit rules.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-6","title":"Step 6","text":"<p>Step 6 and step 7 reference special symbols that are beyond the scope of 3157. This tutorial only uses them to explicitly notate the intuitions behind the implicit rules. You may skip directly to step 8 to avoid getting caught up in the details.</p> <p>In the rule to build <code>main</code>, the shell command takes an argument of <code>-o main</code>, which tells <code>gcc</code> to name the output executable <code>main</code>. What if we just wanted to name it whatever the name of our target is?</p> <p>Make also provides special variables whose values are dependent on the rule in which they appear. They can be invoked using a <code>$</code> followed by a special character. You won't need to know any of these for the purposes of this course, but they provide useful notation to understand how implicit rules work.</p> <p>The special variable that is substituted with the name of the target is <code>$@</code>. We can rewrite the linking rule as follows:</p> <pre><code>main: main.o myadd.o\n    $(CC) $(LDFLAGS) main.o myadd.o -o $@\n</code></pre> <p>Within the <code>main</code> rule, <code>$@</code> will expand to <code>main</code>. Now, if we change <code>main</code>, the output executable name will change accordingly.</p> <p>You can try this out by playing around with your Makefile, then running <code>make</code>.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-7","title":"Step 7","text":"<p>We can use a couple more special variables to eliminate some of the filenames we explicitly reference in the shell commands for each rule.</p> <p>First, we can use <code>$^</code>, which will be substituted with every dependency of the target. We can use this for the <code>main</code> target once again:</p> <pre><code>$(CC) $(LDFLAGS) $^ -o $@\n</code></pre> <p>Make also provides a special variable which will expand to only the first dependency of a target, <code>$&lt;</code>. This is especially handy for the compilation rules:</p> <pre><code>$(CC) $(CFLAGS) -c $&lt;\n</code></pre> <p>Notice that at this point, the build commands in our <code>Makefile</code> don't explicitly mention anything about the target they're building or the dependencies they're using. For example, there's no mention of <code>main.o</code>, <code>main.c</code>, or <code>myadd.h</code> in <code>main.o</code>'s build commands. There's probably another opportunity to simplify our <code>Makefile</code> even more just around the corner...</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-8","title":"Step 8","text":"<p>The guys who wrote Make also realized that there are some pretty common patterns when it comes to compiling C software projects, so they built the ability to recognize these patterns into Make. These are what we call \"implicit rules.\"</p> <p>The built-in implicit rules will use the file extensions of the targets and dependencies to infer what build command pattern to invoke. It will then fill in build command automatically, which will be looking for extra configuration options like compiler flags from specially designated build variables.</p> <p>Specifically, the built-in C implicit rules will look for build variables such as <code>CC</code>, <code>CFLAGS</code>, and <code>LDFLAGS</code>... which we've already defined for ourselves! They will also use the dependencies you've listed to figure what needs to be compiled, what needs to be linked, and what needs to be used as the output name. So we can just go ahead and remove the build commands, and just write the targets and dependencies on their own:</p> <pre><code>main: main.o myadd.o\nmain.o: main.c myadd.h\nmyadd.o: myadd.c myadd.h\n</code></pre> <p>This will still build -- try running <code>make</code> to see for yourself. For larger software projects, implicit rules like these can go a long way.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#step-9","title":"Step 9","text":"<p>There's something else that the Make developers realized about the file naming conventions we use for C software projects: the name of the build target is often related to that of one of its dependencies. For example, <code>myadd.o</code> comes from <code>myadd.c</code>, and <code>main</code> comes from <code>main.o</code>.</p> <p>If you omit those dependencies, Make will look for them any way and use them during the compilation process. Thus we end up with a set of incredibly terse build rules:</p> <pre><code>main: myadd.o\nmain.o: myadd.h\nmyadd.o: myadd.h\n</code></pre> <p>And this still builds.</p> <p>There's a lot more fancy stuff you can do with your <code>Makefile</code>, but they're beyond the scope of this class, and certainly beyond the scope of our toy <code>myadd</code> software project. You can check out GNU's Make manual online to find out the full extent of what this utility can do.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#other-useful-make-variables","title":"Other Useful Make Variables","text":""},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#compiling-with-libraries","title":"Compiling with Libraries","text":"<p>The <code>Makefile</code> is a great way to manage how your software project interacts with other libraries. As you'll learn later, you'll need to pass extra flags to <code>gcc</code> in order for it to be aware of where the library files are. It's a common pattern for <code>Makefile</code>s to incorporate these flags while invoking implicit rules.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#includes","title":"<code>INCLUDES</code>","text":"<p>In order to tell <code>gcc</code> where to search for non-standard header files, you pass it the <code>-I</code> flag during compilation (but not linking). This can be passed in alongside <code>CFLAGS</code>, but you'll often see the following pattern:</p> <pre><code>INCLUDES = -Imy/include/path\nCFLAGS = -g -Wall $(INCLUDES)\n</code></pre> <p>We create a separate <code>INCLUDES</code> variable to distinguish between include paths and other compilation flags, but we pass it along with the <code>CFLAGS</code>.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#ldlibs","title":"<code>LDLIBS</code>","text":"<p>After everything is compiled, you'll need to link your project against a library where the library functions and variables are located. This is done using the <code>-l</code> flag. However, unlike with <code>INCLUDES</code>, we can't just stow away our <code>-l</code> flags alongside our <code>LDFLAGS</code>, because order does matter when you're linking.</p> <p>Thankfully, Make's implicit rules take this into account, and give us a separate build variable we can use. The <code>LDLIBS</code> variable comes after the <code>.o</code> files, while the <code>LDFLAGS</code> comes before. The full implicit rule actually looks something like this:</p> <pre><code>$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n</code></pre> <p>If you haven't assigned anything to <code>LDLIBS</code>, <code>$(LDLIBS)</code> will just silently disappear when it's expanded. We can use the implicit build variables like this:</p> <pre><code>LDFLAGS = -g -Lmy/libary/path\nLDLIBS = -lmylib\n</code></pre>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#compiling-c","title":"Compiling C++","text":"<p>When we compile C++ programs later on, we'll need a different compiler, though most of how it works is very similar. Specifically, we'll be using <code>g++</code>. We still need to compile and link in separate stages, and will still need to pass each stage compiler and linking flags.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#cxx","title":"<code>CXX</code>","text":"<p>When compiling C++ <code>.cpp</code> files, the implicit rule will look for <code>CXX</code> instead of <code>CC</code>, so we can make sure it uses the right compiler by doing the following:</p> <pre><code>CXX = g++\n</code></pre>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#cxxflags","title":"<code>CXXFLAGS</code>","text":"<p>Make will also expect a separate build variable for compiling C++, <code>CXXFLAGS</code>. If we just want to have <code>g++</code> use the same flags as when compiling C, we can use the following trick:</p> <pre><code>CXXFLAGS = $(CFLAGS)\n</code></pre> <p><code>$(CFLAGS)</code> can be followed by any number of C++-specific flags.</p> <p>The implicit rule for compiling C++ programs looks something like the following:</p> <pre><code>$(CXX) $(CXXFLAGS) -c $&lt;\n</code></pre> <p>You may want to revisit these notes once you begin writing C++ programs later in the semester.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#common-make-practices","title":"Common Make Practices","text":""},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#more-phony-targets","title":"More <code>.PHONY</code> Targets","text":"<p>Make can be used for a lot more than just building files. As with <code>make clean</code>, we can use it as a repository for commands that we would commonly use during the development process.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#all","title":"<code>all</code>","text":"<p>Sometimes, you might want to clean up everything and build everything from scratch. The target conventionally used for this is <code>all</code>. Its rule is usually written as follows:</p> <pre><code>.PHONY: all\nall: clean main\n</code></pre> <p><code>main</code> should be replaced with whatever your default build target is.</p> <p>The reason this works is because Make satisfies dependencies from left to right. So, running <code>make all</code> will first run <code>make clean</code>, then run <code>make main</code>. Since no build commands are specified underneath, Make will not do anything after satisfying <code>clean</code> and <code>main</code>.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#targets-and-default","title":"<code>TARGETS</code> and <code>default</code>","text":"<p>When you're building multiple targets, it can be useful to have a single variable to keep track of them. For example, if we're building two executables, <code>foo</code> and <code>bar</code>, alongside <code>main</code>, we would write the following at the top of my <code>Makefile</code>:</p> <pre><code>TARGETS = main foo bar\n</code></pre> <p>Then, in order to build all of these by default, we would write the topmost rule as a <code>.PHONY</code> rule:</p> <pre><code>.PHONY: default\ndefault: $(TARGETS)\n</code></pre> <p>Now we can build <code>main</code>, <code>foo</code>, and <code>bar</code> all at once by just typing <code>make</code>!</p> <p>Make sure that <code>clean</code> is aware of all of the <code>TARGETS</code>, not just <code>main</code>:</p> <pre><code>.PHONY: clean\nclean:\n    rm -rf $(TARGETS) *.o a.out\n</code></pre>"},{"location":"resources/cs3157recitations/B-Makefiles/makefiles/#test","title":"<code>test</code>","text":"<p>The <code>Makefile</code> can also be a handy place to stash test commands, especially ones that are really cumbersome to type. Later on, you may find yourself running the following quite often:</p> <pre><code>valgrind --leak-check=yes ./myprogram arg1 arg2\n</code></pre> <p>Instead of having to type all that out, we can just write the following in our <code>Makefile</code>:</p> <pre><code>test: default\n    valgrind --leak-check=yes ./myprogram arg1 arg2\n</code></pre> <p>Now, we can just test our code with <code>make test</code>!</p>"},{"location":"resources/cs3157recitations/B-Makefiles/practice/directions/","title":"Recitation 2: Practice","text":"<p>Try to do the following programs without a compiler, just pen and paper.</p>"},{"location":"resources/cs3157recitations/B-Makefiles/practice/directions/#problem-1","title":"Problem 1","text":"<p>Read the sample makefile below:</p> <p>p1/Makefile</p> <pre><code>  CC = gcc\n  CFLAGS = -Wall\n\n  .PHONY: run\n  run:\n    ./main\n</code></pre> <p>Oh, well that's a rather sparse Makefile. I guess we'll have to fill it in. Given the C files below, write this Makefile twice. (a) The first time with every rule written out in its entirety, without relying on Make to fill in all the stuff you've left out. (b) The second time, use all the defaults possible to make as short a makefile as possible.</p> <p>The requirements for the Makefile are as follows:</p> <ol> <li>Add a \"clean\" target that removes all compiled files.</li> <li>Add an \"all\" target that runs the clean target and then compiles</li> <li>Design your file such that typing <code>make</code> in the shell will result in all      compiled files being removed, the entire project being compiled, and the      compiled file being executed. NOTE: This requirement is incredibly bad      practice, but will illustrate a point about Makefiles.</li> <li>The executable should be called \"main\" and should have debugging flags</li> </ol> <p>p1/main.c</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"ops.h\"\n\nint main(int argc, char **argv) {\n  int five = add(2, 3);\n  int six = subtract(7, 1);\n  int seven = divide(14, 2);\n  int eight = multiply(2, 4);\n  printf(\"Five: %d\\nSix: %d\\nSeven: %d\\nEight: %d\\n\", five, six, seven, eight);\n  return 0;\n}\n</code></pre> <p>p1/ops.h</p> <pre><code>int add(int x, int y);\nint subtract(int x, int y);\nint divide(int x, int y);\nint multiply(int x, int y);\n</code></pre> <p>p1/ops.c</p> <pre><code>#include \"ops.h\"\n#include \"opsprinter.h\"\n\nint add(int x, int y) {\n  int ret = x + y;\n  printOp(x, '+', y, ret);\n  return ret;\n}\nint subtract(int x, int y) {\n  int ret = x - y;\n  printOp(x, '-', y, ret);\n  return ret;\n}\nint divide(int x, int y) {\n  int ret = x / y;\n  printOp(x, '/', y, ret);\n  return ret;\n}\nint multiply(int x, int y) {\n  int ret = x * y;\n  printOp(x, '*', y, ret);\n  return ret;\n}\n</code></pre> <p>p1/opsprinter.h</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid printOp(int x, char op, int y, int result);\n</code></pre> <p>p1/opsprinter.c</p> <pre><code>#include \"opsprinter.h\"\n\nvoid printOp(int x, char op, int y, int result) {\n  printf(\"%d %c %d = %d\\n\", x, op, y, result);\n}\n</code></pre>"},{"location":"resources/cs3157recitations/C-Git/git/","title":"Git","text":"<p>For this part of the recitation, we will follow Jae's \"git-tutorial\" which can be found on the mailing list and the course website. Here's a quick run through of the operations reviewed in the tutorial, along with some bonus operations.</p> <p>Git is version control software, where version control is \"a system that records changes to a file or set of files over time so that you can recall specific versions later\" (source). In other words, if you mess up your code really badly, you can use git to gracefully step back to an earlier version. To facilitate this, git needs you to take periodic snapshots of your code, called 'commits' in git parlance.</p> <p>In this class, we require that you make git commits to get full credit for your work. We want you to learn git because in industry, you will without a doubt be using version control.</p>"},{"location":"resources/cs3157recitations/C-Git/git/#version-control","title":"Version Control","text":"<p>A Version Control System (VCS) records changes made to a set of files. This allows programmers to maintain backups of their previous work without manually copying their files</p>"},{"location":"resources/cs3157recitations/C-Git/git/#configuration","title":"Configuration","text":"<p>You need to set your name and email so that your commits are associated with your identity:</p> <pre><code>git config --global user.name \"Your Full Name\"\ngit config --global user.email your_uni@columbia.edu\n</code></pre> <p>It's also nice to enable color in your console when using git:</p> <pre><code>git config --global --add color.ui auto\n</code></pre> <p>And set your editor globally (here vim, if you prefer emacs use that). Note that using the graphical version, <code>gvim</code>, is trickier, so we recommend you stick to the command line version.</p> <pre><code>echo \"EDITOR=vim\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"resources/cs3157recitations/C-Git/git/#getting-started","title":"Getting Started","text":"<p>In order to version control a directory, you have to 'initialize' it:</p> <pre><code>git init\n</code></pre> <p>But in this class, we won't be using <code>git init</code>. Instead, all students start by  making an exact copy of Jae's skeleton code. Git supports 'cloning', which does just   that:</p> <pre><code>git clone [source_directory] [destination_directory]\n</code></pre> <p>With the above command, you can take Jae's files and create your own copy. Neat!</p>"},{"location":"resources/cs3157recitations/C-Git/git/#updating-your-versioning","title":"Updating Your Versioning","text":"<p>Not all the files in a version controlled directory have to be under version control. You have to explicitly tell git to watch for changes in certain files. For information on which files are version controled, which have changed, etc. run:</p> <pre><code>git status\n</code></pre> <p>This will bring up file statuses. Remember that 'commiting' is equivalent to taking a snapshot at that time.</p> <p>There are 4 file statuses:</p> <ol> <li>Untracked: git is not watching for changes in this file.</li> <li>Tracked, unmodified:  git is watching this file for changes, but nothing has changed.</li> <li>Tracked, modified, unstaged: git is watching this file and it has changed, but you haven't told git you want to include the file in your next commit.</li> <li>Tracked, modified, staged: git is ready to commit the changes you've made.</li> </ol> <p>To move a file from status 3 to 4 (i.e. to ensure that the next commit you make registers  the changes you made to a file), you have to 'stage' it using the <code>add</code> command:</p> <pre><code>git add file1 file2\ngit add -p                      # individually pick for each set of changes whether to stage it\n</code></pre> <p>Once you have at least one file that is modified and staged, you can commit: </p> <pre><code>git commit -m \"some message\"    # explain what changes you made between now and your previous commit\n</code></pre>"},{"location":"resources/cs3157recitations/C-Git/git/#other-very-useful-commands","title":"Other Very Useful Commands","text":"<p>Checking up on your changes:</p> <pre><code>git status\ngit diff\ngit diff file1\ngit diff --cached\ngit log\ngit log --stat --summary\ngit log -p\n</code></pre> <p>To only stage changes (including deletions) to already tracked files, without adding untracked files:</p> <pre><code>git add -u\n</code></pre> <p>To remove a file from your git files, run:</p> <pre><code>git rm file1\n</code></pre> <p>To change a filename in git: </p> <pre><code>git mv oldfilename newfilename\n</code></pre> <p>Undoing changes:</p> <pre><code>git checkout -- [filename]\ngit reset HEAD [filename]\n</code></pre> <p>Going back in time:</p> <pre><code>git checkout &lt;commit hash&gt;\n</code></pre>"},{"location":"resources/cs3157recitations/C-Git/git/#examples","title":"Examples","text":"<p>Case 1: Adding a new file</p> <p></p> <p>Case 2: Working on an existing file from git repository</p> <p></p>"},{"location":"resources/cs3157recitations/C-Git/git/#other-tools","title":"Other Tools","text":"<pre><code>git grep [pattern]\ngit help\ngit help commit\nman git\nman gittutorial\n</code></pre> <p>Patches are rarely necessary, but the submit script for this class uses them.</p> <pre><code>git format-patch --stdout origin &gt; mywork.mbox\ngit am path/to/mywork.mbox\n</code></pre> <p>Remotes:</p> <pre><code>git remote add\ngit pull\ngit fetch &amp;&amp; git merge\ngit push\n</code></pre>"},{"location":"resources/cs3157recitations/C-Git/git/#gitignore","title":"gitignore","text":"<p>Git wants to track everything, but you don't want it to track everything. In particular you want to ignore all your object (<code>.o</code>) files, and your compiled executables. You can tell git to ignore certain files by using a gitignore file. It's a list of file names (including wildcards [when you use an asterisk])  for git to ignore when running commands like status.</p> <p>In your repository create a file named <code>.gitignore</code>, where each line is a pattern of filenames git should ignore. </p> <p>Example .gitignore file:</p> <pre><code>a.out\n*.o\n*.a\nmain\n*.mbox\n/labN-2015*\n</code></pre> <p>You can add the <code>.gitignore</code> file itself to the <code>.gitignore</code>, or you can add it to the repository. You may also create a global ignore file so you don't have to copy it to each repository. More details about that are in Github's help on ignoring files.</p>"},{"location":"resources/cs3157recitations/C-Git/git/#bonus","title":"Bonus","text":"<p>All of these recitation notes are tracked using git and hosted on GitHub. If we have time we'll come back to this during recitation, but here's some GitHub 101.</p> <ol> <li> <p>Create an account by going to github.com and signing up. Then, configure git for use with remote servers.</p> </li> <li> <p>Add your SSH keys to github. They have a handy tutorial to help out. All you should need to do is Step 4 - adding ssh keys.</p> </li> <li> <p>Try forking this repository. Pull your fork to your local machine.</p> <p>Digression: One of the reasons git is so great for working in distributed teams is a feature called branching. Branches are subsections of git commits that don't affect other branches. For example \"master\" is the branch that you'll do all your work on for this class. Let's say though you want to add more unix commands to recitation-1.md. You could create a branch called <code>improve_recitation1_unix</code> like so:</p> <pre><code>git checkout -b improve_recitation1_unix\n</code></pre> <p>This would create a new branch, and switch to it. On this branch you would make and commit your changes. When finished, you could switch back to the master branch and merge your changes from the feature branch as follows:</p> <pre><code>git checkout master\ngit merge improve_recitation1_unix\n</code></pre> <p>The reason branching is so useful is that it allows for multiple people to work on their own issues, and then merge their changes in only after they are certain their changes will not cause problems to the master branch. In this way, the master branch always represents a completely functioning project, while the branches may have broken code.</p> <p>Anyway, all this was a bit of a digression to discuss branching, but now that you have a fork of my respository, you can make changes on the master branch. When you're done, use <code>git push origin master</code> to push your changes back up to your fork, and then go to github.com to pull-request your changes. If I like what you've done, I'll definitely accept your pull request.</p> </li> </ol> <p>And that's about it for GitHub. Forking and branching are crucial to working on teams, both private and open-source. GitHub and git are great tools for managing all sorts of things, even notes, so make sure you're familiar with them. Proficiency in git and github is a desirable trait to have when job-hunting.</p> <p>Other useful tutorials:</p> <ul> <li>Be Social</li> <li>Create a Repository</li> </ul>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/","title":"Bits, Bytes, and Binary","text":"<p>Before we have a look at how memory works, let's take a bit of time to refresh our memory about bits:</p> <ul> <li>Bit (b):<ul> <li>A single digit in binary</li> <li>Can take on one of two possible values: 1 or 0</li> <li>Often used to represent on/off, true/false, etc.</li> </ul> </li> <li>Byte (B):<ul> <li>8 bits make a byte</li> <li>Can take on 2^8 = 256 different values (from 0 to 255, inclusive)</li> </ul> </li> <li>Hexadecimal:<ul> <li>A base-16 numerical notation that can represent up to 15 in a single digit</li> <li>Uses base-10 + first 6 letters of alphabet:   { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f }</li> <li>By convention, we prefix numbers in hexadecimal notation with \"0x\"   e.g. 0x3157</li> <li>Single digit can represent up to 2^4; two digits can represent 2^8</li> <li>Bytes are often represented using 2 hexadecimal digits</li> </ul> </li> <li>Least significant bit (LSB):<ul> <li>Right-most binary digit</li> <li>Usually denotes whether a number is even or odd</li> </ul> </li> <li>Most significant bit (MSB):<ul> <li>Left-most binary digit</li> <li>Meaning depends on representation:   for unsigned (positive) integers, this is just the largest place value;   for signed integers, see below (Two's complement)</li> </ul> </li> </ul>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#twos-complement","title":"Two's Complement","text":"<p>Two's complement is signed binary representation system; \"signed\" refers to the fact that we can also represent negative numbers, i.e. there is a bit which represents the positive/negative sign. Most modern computer use this representation for signed integers.</p> <p>The most significant bit (MSB, see above) tells us the sign of the number. If it's a 0, the number is positive, but if it's a 1, the number is negative.</p> <p>To figure out what negative number is represented (e.g. 1100):</p> <ol> <li>Make sure that MSB is 1; note that the number is negative (1100)</li> <li>Invert all the bits (1100 -&gt; 0011)</li> <li>Find the number's magnitude as if it were positive (0011 = 3)</li> <li>Add 1 to the magnitude (3 + 1 = 4)</li> <li>The value of the number is the negative of the result from step 4 (-4)</li> </ol> <p>So why do we use this weird form of representation? Well as it turns out, in two's complement, the computer can perform arithmetic on negative numbers as if they were positive numbers! (Find out more in w3827: Fundamentals of Computer Systems.)</p> <p>Let's look at how two's complement works in 3 bits first:</p> Binary unsigned decimal two's complement decimal 000 0 0 001 1 1 010 2 2 011 3 3 100 4 -4 101 5 -3 110 6 -2 111 7 -1 <p>Things to notice:</p> <ul> <li>We can only represent half as many positive integers   (max = 2^(3-1) - 1 = 4 - 1 = 3)</li> <li>We can represent 1 more negative integer than we can positive integers   (min = -(2^(3-1)) = -4)</li> <li>If we \"add\" 1 more to 111, it'll wraparound to 000</li> </ul> <p>In general, for N-bit two's complement:</p> <ul> <li>max = 2^(N-1) - 1</li> <li>min = -(2^(N-1))</li> </ul> <p>It's also important to be aware of some note-worthy boundaries (example in 32-bits, written in hex):</p> <ul> <li>All 0s (0x00000000) = 0</li> <li>Leading 0, rest are 1s (0x7FFFFFFF) = max (2147483647)</li> <li>Leading 1, rest are 0s (0x80000000) = min (-2147483648)</li> <li>All 1s (0xFFFFFFFF) = -1</li> </ul> <p>Try converting these hex numbers to binary and seeing for yourself!</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitwise-operators","title":"Bitwise Operators","text":"<p>Remember that bits can be used to represent boolean (true/false) values too. This means that we can operate on each bit as a boolean value using C's bitwise operators. They're a bit tricky, but they have a wide range of uses in systems programming, partly because they are extremely fast to compute.</p> <p>Note that these are different from C's boolean operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>)! Bitwise operators operate independently on each bit.</p> <p>If you need a refresher on boolean operators and their truth tables, see the appendix.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitwise-and","title":"Bitwise AND <code>&amp;</code>","text":"<p>Takes two integers as operands and returns a new integer where its bit pattern consists of 1s only where both operands also have 1s in the same position. For example:</p> <pre><code>int x = 5;          // 0101 in binary\nint y = 12;         // 1100 in binary\nassert(x &amp; y == 4); // 0100 (4)\n</code></pre> <p>This provides a handy way of checking the bit value at a given position, using a bitmask:</p> <pre><code>int mask = 0x8;         // 1000 in binary, for checking the 4th bit\nassert(!(x &amp; mask));    // 5 (0101) doesn't contain a 1 in the 4th bit\nassert(y &amp; mask);       // 12 (1100) contains a 1 in the 4th bit\n</code></pre> <p>It's called a bitmask because we place 0s in the digits we don't want to read, which will mask out the corresponding digits via the bitwise AND.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitwise-or","title":"Bitwise OR <code>|</code>","text":"<p>Behaves just like the bitwise AND, except with an OR operation. Takes two integers as operands and returns a new integer where its bit pattern consists of 1s where either operand also has a 1 in the same position. For example:</p> <pre><code>int x = 5;              // 0101 in binary\nint y = 12;             // 1100 in binary\nassert(x | y == 13);    // 1101 (13)\n</code></pre> <p>This is really useful for combining boolean options. For example, say we wanted to set access permissions on a file. In UNIX-like systems, we represent read, write, and execute permissions. A file may have any combination of those three permissions. We may represent them as follows:</p> Permission Symbolic Binary Decimal Read <code>r--</code> <code>100</code> 4 Write <code>-w-</code> <code>010</code> 2 Execute <code>--x</code> <code>001</code> 1 <p>So, let's set our variables in code:</p> <pre><code>int READ = 0x4;     // 100 in binary\nint WRITE = 0x2;    // 010 in binary\nint EXEC = 0x1;     // 001 in binary\n</code></pre> <p>If we wanted to specify permissions for reading and writing but not executing, we could do the following:</p> <pre><code>int perm = READ | WRITE; // 100 | 010 == 110\n</code></pre> <p>Later we can verify that the file has the right permissions by reading the corresponding bit using a bitmask.</p> <pre><code>assert(perm &amp; READ);    // can read\nassert(perm &amp; WRITE);   // can write\nassert(!(perm &amp; EXEC)); // cannot execute\n</code></pre> <p>Some of this may seem familiar if you've ever used <code>ls -la</code> or <code>chmod</code>. You'll come across this again later when we take a second look at UNIX!</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitwise-xor","title":"Bitwise XOR <code>^</code>","text":"<p>Also known as a bitwise eXclusive OR; behaves just like the bitwise AND and OR, except with an XOR operation. Takes two integers as operands and returns a new integer where its bit pattern consists of 1s where only one of its operands has a 1 in the same position. For example:</p> <pre><code>int x = 6;          // 0110 in binary\nint y = 5;          // 0101 in binary\nassert(x ^ y == 3); // 0011 (3)\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitwise-not","title":"Bitwise NOT <code>~</code>","text":"<p>Also known as a bitwise complement. Takes integer as operand and returns an integer with all its bits flipped.</p> <pre><code>unsigned int x = 5; // 0101 in binary, unsigned\nint y = 5;          // 0101 in binary, signed\n\nassert(~x == 10);   // 1010 (10, unsigned)\nassert(~y == -6);   // 1010 (-6, signed)\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#bitshifting","title":"Bitshifting","text":"<p>Another useful operation is the bitshift. What we mean by \"shifting bits\" is pushing all the digits in a number. We can shift to the left, or shift to the right.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#leftshift","title":"Leftshift <code>&lt;&lt;</code>","text":"<p>For <code>x &lt;&lt; n</code>, each bit in <code>x</code> is shifted to the left (towards the MSB) by <code>n</code> digits:</p> <ul> <li>Left-shifting always fills the vacated bits on the right with 0s</li> <li>The displaced bits on the left are discarded</li> </ul> <p>Note that this is equivalent to mulitplying a number by 2^<code>n</code>!</p> <pre><code>int x = 1;              // 0001 in binary\nassert(x &lt;&lt; 2 == 4);    // 0100 (4)\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#rightshift","title":"Rightshift <code>&gt;&gt;</code>","text":"<p>For <code>x &gt;&gt; n</code>, each bit in <code>x</code> is shifted to the right (towards the LSB) by <code>n</code> digits:</p> <ul> <li>How the vacated bits get filled depends on what we're dealing with:</li> <li>Right shifting unsigned numbers fills vacated bits on the left with 0s</li> <li>Right shifting signed numbers produces results that vary     depending on the machine and compiler,     but on most modern computers, doing so will sign extend the number,     i.e. the value of the MSB (the sign) will be used to pad the vacated bits</li> <li>The displaced bits on the right are discarded</li> </ul> <p>Note that this is equivalent to dividing a number by 2^<code>n</code> (and discarding the remainder)!</p> <pre><code>int x = 5;              // 0101 in binary\nassert(x &gt;&gt; 2 == 1);    // 0001 (1)\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#appendix-truth-tables-for-bitwise-operations","title":"Appendix: Truth Tables for Bitwise Operations","text":""},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#and","title":"AND","text":"<p>If both bits are 1, the result will be 1. Otherwise, the result is 0.</p> <code>A</code> <code>B</code> <code>A &amp; B</code> 0 0 0 0 1 0 1 0 0 1 1 1"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#or","title":"OR","text":"<p>If either bit is 1, the result will be 1. Otherwise, the result is 0.</p> <code>A</code> <code>B</code> <code>A | B</code> 0 0 0 0 1 1 1 0 1 1 1 1"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#xor","title":"XOR","text":"<p>If both bits differ, the result is 1. If both bits are the same, the result is 0.</p> <code>A</code> <code>B</code> <code>A ^ B</code> 0 0 0 0 1 1 1 0 1 1 1 0"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/bits-and-binary/#not","title":"NOT","text":"<p>The result is the opposite of the bit's current value.</p> <code>A</code> <code>~A</code> 0 1 1 0"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/","title":"C Basics","text":"<p>C is a general-purpose programming language developed by Dennis Ritchie at Bell Labs in the early 1970s. It introduced a lot of the syntactic and programming conventions we see in the numerous programming languages it influenced, including Java, Javascript, Go, C#, Objective-C, and of course C++.</p> <p>C code maps very efficiently to lower-level machine code, giving programmers very precise control of the execution of their program. Because of this, it's often used in systems programming for low-latency, low-overhead, close-to-hardware applications.</p> <p>Now, without further ado, let's take a look at C!</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#types","title":"Types","text":"<p>Before going into detail about the different types available in C, it's important to convey what we mean by the term, \"type\" (though without getting too technical with a mathematical definition).</p> <p>For our purposes, and colloquially speaking, a type in C is just how we choose to understand the data we find in memory. It defines how much data we should be expecting to read, and how to understand the data we find. </p> <p>Now, with that in mind, let's look at some types!</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#integer-types","title":"Integer Types","text":"<p>Integers in C all use the binary number system we discussed previously; two's complement for signed integers, and regular binary for unsigned. So the only difference between integer types (of the same signedness) is their size, which is also related to the range of values they can represent.</p> <p>C only defines the size of each type in relation to the others:</p> <pre><code>char &lt;= short &lt;= int &lt;= long &lt;= long long\n</code></pre> <p>Technically there's nothing stopping them from all of them being the same size, but it's all dependent on what kind of machine and compiler you're using. CLAC machines use the following:</p> Type Size <code>char</code> 1 byte <code>short</code> 2 bytes <code>int</code> 4 bytes <code>long</code> 8 bytes <code>long long</code> 8 bytes <p>On most modern machines, the sizes for <code>char</code>, <code>short</code>, and <code>int</code> are fairly consistent, and the same as what we have on CLAC. However, the sizes for <code>long</code> and <code>long long</code> vary a lot from system to system.</p> <p>You can always test it out for yourself:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"char: %lu\\n\n            short: %lu\\n\n            int: %lu\\n\n            long: %lu\\n\n            longlong: %lu\\n\",\n        sizeof(char), sizeof(short), sizeof(int),\n        sizeof(long), sizeof(long long));\n    return 0;\n}\n</code></pre> <p>There are some more technical details different ways of declaring integers, which you can find in the Appendix.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#floating-point-types","title":"Floating-Point Types","text":"<p>There are three types for floating-point numbers in C, for single-precision, double-precision, and extended-precision floating point. How they're bitwise represented differs from machine to machine, but most modern computers use the IEEE-754 floating-point standard (if you're curious to see what that looks like in binary, see the Appendix).</p> <p>Like with integers, the sizes are defined relative to each other. They are:</p> <pre><code>float &lt;= double &lt;= long double\n</code></pre> <p>The sizes on CLAC are as follows:</p> Type Size <code>float</code> 4 bytes <code>double</code> 8 bytes <code>long double</code> 16 byetes <p>Again, you can test it out for yourself:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"float: %lu\\n\n            double: %lu\\n\n            long double: %lu\\n\",\n        sizeof(float), sizeof(double), sizeof(long double));\n    return 0;\n}\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#declarations-casting-literals","title":"Declarations, Casting, Literals","text":""},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#variable-declarations","title":"Variable Declarations","text":"<p>Just like in Java, we declare variables using the following syntactic structure (note that the <code>[]</code>s indicate that the type modifiers are optional, and the <code>..</code> indicate that there can be multiple modifiers):</p> <pre><code>[&lt;modifiers..&gt;] &lt;type&gt; [&lt;modifiers..&gt;] &lt;variable name&gt;;\n</code></pre> <p>This declares a variable, but does not initialize it. That is to say, we've told the compiler how much space we want and how to read what we'll eventually put there, but we've not actually put anything there yet! There's no guarantee what garbage might be written in the piece of memory we're given, so trying to access it will result in undefined behavior (no guarantees for what will happen during compilation or execution; you'll here us talk about this a lot, specifically about avoiding it).</p> <pre><code>int x;              // x is declared, but uninitialized\nprintf(\"%d\", x);    // undefined behavior; don't do this!\nx = 4;              // x is now initialized to 4\n</code></pre> <p>We can also declare multiple variables of the same type all at once, separating the variable names with a <code>,</code>:</p> <pre><code>int y, z;           // y and z are declared, but both uninitialized\n</code></pre> <p>Just like in Java, we can declare and initialize our variables all at once:</p> <pre><code>int x = 2;          // x is declared and initialized to 2\nint y = 0, z;       // y and z are declared, only y is initialized (to 0)\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#type-casting","title":"Type Casting","text":"<p>Also like in Java, we can cast variables from one type to another. We do so with the following syntax:</p> <pre><code>(&lt;type&gt;) &lt;variable&gt;\n</code></pre> <p>This comes in handy for changing the type of a variable to suit the interface of a function we might want to call, or to trick the compiler (as you saw before).</p> <p>For example, let's say that we have a function <code>foo()</code> that takes a single <code>float</code> as its parameter:</p> <p><pre><code>int x = 34;\nfoo((float) x);\n</code></pre> When we cast from an integer type to a floating-point type, the compiler produces instructions to convert our integer representation to floating-point representation.</p> <p>Keep in mind that when we convert between integer types,  we extend/truncate our integer in order to fit it into the size of the type we are casting it to. Note this can lead to some strange-looking results! For example, if we're casting from a positive <code>long</code> to an <code>int</code>, and the <code>long</code> happened to have a 1 value at the bit position corresponding to the MSB of an <code>int</code>, the result may be a negative number:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 4;\n    int i = 4;\n    long l = 3000000000;\n\n    printf(\"char to int: %d\\n\", (int) c);       // prints 4\n    printf(\"int to float: %f\\n\", (float) i);    // prints 4.000000\n\n    printf(\"long (no cast): %ld\\n\", ll);        // prints 3000000000\n    printf(\"long to int: %d\\n\", (int) ll);      // prints -1294967296\n\n    return 0;\n}\n</code></pre> <p>As you can see, downcasting the 8-byte <code>long</code> truncated our integer, which means something very different as a signed, 4-byte integer.</p> <p>When we convert between floating-point types of different levels of precision, again the compiler helps us do the conversion, though we may lose precision if we're casting from a more precise floating-point type to a less precise one.</p> <p>We can actually use casting to \"cast away\" some of the things the compiler tries to enforce for us, like pointer types and <code>const</code>ness. Check out the Appendix for more details.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#literals","title":"Literals","text":"<p>Literals are values hard-coded into our program. Most literals look fairly self-explanatory (especially numeric literals), but there are some C-specific notations that we should be aware about.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#octal-and-hexadecimal-literals","title":"Octal and Hexadecimal Literals","text":"<p>Octal (base 8) literals start with a leading <code>0</code>. The following digits can only consist of <code>0</code> through <code>7</code>.</p> <p>Hexadecimal (base 16) literals start with a leading <code>0x</code> or <code>0X</code> The following digits can only consist of <code>0</code> through <code>9</code> and <code>a</code> through <code>f</code> (capitalization doesn't matter).</p> <p>Let's look at different ways of writing the number 42:</p> <pre><code>42      // decimal\n052     // octal\n0X2A    // hexadecimal\n0x2a    // also hexadecimal\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#unsigned-literals","title":"<code>unsigned</code> Literals","text":"<p>To specify that a number is unsigned, it should be followed by a <code>u</code> or a <code>U</code>. For example:</p> <pre><code>8u\n0xffffffffu\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#long-and-long-long-literals","title":"<code>long</code> and <code>long long</code> Literals","text":"<p>A number by itself is understood by the compiler to be an <code>int</code> by default. To specify that it is a <code>long</code> or <code>long long</code>, use <code>l</code>/<code>L</code> and <code>ll</code>/<code>LL</code> respectively by appending it to the end of the number. For example:</p> <pre><code>4l\n4LL\n0x4l\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#floating-point-literals","title":"Floating-point literals","text":"<p>Floating numbers can be written several different ways:</p> <ul> <li>Just as a number: <code>42</code> (inferred)</li> <li>A number with a decimal: <code>42.</code>, <code>4.2</code>, <code>.42</code></li> <li>Exponent form: <code>4e2</code></li> </ul> <p>These are all <code>double</code>s by default; one can specify <code>float</code> or <code>long double</code> using suffixes <code>f</code>/<code>F</code> or <code>l/L</code> respectively.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#character-literals","title":"Character literals","text":"<p>You might've noticed that, unlike in Python or Javascript, in C, single quotation marks <code>'</code> aren't the same as double quoatation marks <code>\"</code>. This is becauase single quotation marks are used for single character literals, while double quotation marks are used for string literals (see below).</p> <p>C uses ASCII encoding for characters, which assigns each character an integer. Recall that a <code>char</code> is usually 1 byte; this is because each ASCII character can be representedy a single byte (it only specifies 128 characters). Have a look at The ASCII Table to see what's what.</p> <p>Instead of assigning raw numbers to <code>char</code>s, we can alternatively write them as character literals:</p> <pre><code>char a = 'a';           // same as writing char a = 97\nchar newline = '\\n';    // same as writing char newling = 10\nassert(a == 97);\nassert(newline == 10;\n</code></pre> <p>The backslash <code>\\</code> is used to specify an escape sequence, to denote characters that might be difficult to otherwise type out. Here are some common escape sequences:</p> Escape Sequence Character Description <code>\\n</code> newline <code>\\r</code> carriage return <code>\\\\</code> backslash <code>\\'</code> single quote <code>\\\"</code> double quote <p>A <code>\\</code> may also be followed by a numeric value in octal notation; <code>\\x</code> may be followed by a numeric value in hexadecimal notation. So, consider the following:</p> <pre><code>char a = 0;\nchar b = '0';       // 48 in binary\nchar c = '\\0';\nchar d = '\\x0';\n\nassert(a != b);\nassert(a == c);\nassert(a == d);\n</code></pre> <p><code>char</code> literals can be added and subtracted just like any other number, so if you wanted to find what position in the alphabet the letter <code>j</code> is, you could do something like the following:</p> <pre><code>'j' - 'a'\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#string-literals","title":"String Literals","text":"<p>We write string literals as a sequence of valid <code>char</code> literals (including escaped characters), surrounded by double quotation marks <code>\"</code>:</p> <pre><code>\"I am a not really a 'string', just an array of characters.\\n\"\n</code></pre> <p>String literals actually represent a null-terminated array of characters, which the compiler pre-allocates for us in static memory.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#expressions-and-statements","title":"Expressions and Statements","text":"<p>In C, we differentiate between expressions and statements. Simply put, statements don't necessarily have a value, whereas expressions do. All expressions can be statements, but not all statements can be expressions.</p> <p>This will become clearer as we look at some examples.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#expressions","title":"Expressions","text":"<p>A C expression is any syntactic construct that yields a value. It can be as simple as a variable or a literal, or it can be combinations of other expressions via operators. Function calls are also expressions that yield value of what they return.</p> <p>We're not going to go through all the operators one by one, but we'll note some important details and gotchas.</p> <p>For variables <code>x</code> and <code>y</code>, and some function <code>foo()</code>, the following are examples of expressions:</p> <pre><code>3157\nx\nx + y\nx = y + 3157\nx += y\nx++\nfoo(x, y + 3157)\n</code></pre> <p>Note that an assignment <code>=</code> operation is also an expression! It assigns the value of its right operand to its left operand, and yields the value of the left operand. This might seem weird at first, but it allows us to do things like:</p> <pre><code>x = y = 3157\nx = (y = 3157)\n</code></pre> <p>The second line unpacks it a little bit: it's saying, assign <code>3157</code> to <code>y</code>, and then assign the value of that to <code>x</code>.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#uncommon-operators","title":"Uncommon Operators","text":"<p>Well, these aren't really uncommon, but it's possible you haven't seen these yet depending on what language experience you've had before.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#self-assignment-","title":"Self-assignment <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>|=</code>","text":"<p>Apply the operation before the <code>=</code> to the left and right operand, then assign to the left operand. So, <code>x += y</code> is the same as <code>x = x + y</code></p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#incrementdecrement-","title":"Increment/decrement <code>++</code> <code>--</code>","text":"<p>Used to add 1 or subtract 1 from its operand. There are two flavors of these operators: the prefix version <code>++x</code> <code>--x</code> (appears on the left of the operand) increments/decrements first, and yields the value after the operation (<code>x++</code> is equivalent to <code>x += 1</code>); the postfix version <code>x++</code> <code>x--</code> (appears on the right of the operand) increments/decrements as well, but yields the value before the operation.</p> <pre><code>int b1 = 5, a1 = 5;\nint b2 = ++b1;           // b2 is assigned the value of 6\nint a2 = a1++;           // a2 is assigned the value of 5\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#ternary-conditional-operator","title":"Ternary conditional operator <code>? :</code>","text":"<p>This is the syntax for the ternary operator:</p> <pre><code>&lt;expression-1&gt; ? &lt;expression-2&gt; : &lt;expression-3&gt;\n</code></pre> <p>The value of a conditional expression is dependent on that of the expression before the <code>?</code> operator. If <code>&lt;expression-1&gt;</code> is non-zero, then the conditional value yields the value of <code>&lt;expression-2&gt;</code>; otherwise it yields the value of <code>&lt;expression-3&gt;</code>. Here's an example:</p> <pre><code>int t = 1, f = 0;\nint a = t ? 42 : 24;        // a is assigned the value of 42\ndouble b = f ? 4.2 : 1e20;   // b is assigned the value of 1e20\n</code></pre> <p>It's sort of the same idea as an if/then/else, but keep in mind that those are separate, syntactic constructs in C (which we will cover below).</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#boolean-operators","title":"\"Boolean\" operators","text":"<p>You've probably noticed that there is no boolean type in C. That's we simply represent false with 0, and true with anything non-zero! This allows for some convenient shorthand: <code>if (x != 0)</code> is the same as <code>if(x)</code>.</p> <p>The comparison operators, <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>==</code> <code>=!</code>.</p> <p>Operations that typically return boolean values in other languages instead return 1 for true and 0 for false in C. This includes the comparison operators, <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>==</code> <code>=!</code>, and the logical operators <code>&amp;&amp;</code> <code>||</code> <code>!</code>. We can confirm this with the following code:</p> <pre><code>printf(\"'true': %d\\n\", 0 &lt; 3);  // prints 1\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#short-circuit-evaluation","title":"Short circuit evaluation <code>&amp;&amp;</code> <code>||</code>","text":"<p>Usually, an expression that contains subexpressions (as operands to an operator, or as arguments to a function call) will first evaluate those subexpressions before evaluating the greater overall expression. So let us consider the following two functions:</p> <pre><code>int foo(void) {\n    printf(\"foo!\\n\");\n    return 1;\n}\n\nint bar(void) {\n    printf(\"bar!\\n\");\n    return 0;\n}\n</code></pre> <p>The following expression will evaluate both <code>foo()</code> and <code>bar()</code> function calls:</p> <pre><code>foo() + bar()\n</code></pre> <p>We can tell by the fact that both <code>foo!</code> and <code>bar!</code> are printed.</p> <p>However, <code>&amp;&amp;</code> and <code>||</code> use short circuit evaluation; this means that their operands are evaluated only as necessary. For example, for the expression <code>L &amp;&amp; R</code>, if we know <code>L</code> is 0 (false), we know the value of the logical AND expression is going to be 0 regardless of what happens with <code>R</code>. The operators skip the operands which they know are no longer necessary. To demonstrate:</p> <pre><code>foo() &amp;&amp; bar();     // prints foo! bar!\nfoo() || bar();     // only prints foo!\nbar() &amp;&amp; foo();     // only prints bar!\nbar() || foo();     // prints bar! foo!\n</code></pre> <p>This means that for some short-circuited statement like <code>foo() || bar()</code>, as long as <code>foo()</code> returns a nonzero value, <code>bar()</code> will never even be called.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#operator-precedence","title":"Operator Precedence","text":"<p>Like in any other programming or symbolic language, C defines an order of operations for each of its operators. This way, both the programmer and compiler can agree on what order to evalaute expressions.</p> <p>You should be familiar with a lot of the most common rules (like multiplication/division before addition/subtraction), but there is one note-worthy gotcha that is quite commonly used in C:</p> <pre><code>*p++\n</code></pre> <p>This doesn't increment the variable you get from dereferencing <code>p</code>; instead, this expression takes on the value of <code>*p</code>, and then increments <code>p</code> afterwards. It's not the same as <code>(*p)++</code>; it's more along the lines of something like, <code>*p, p++</code>, where the two operations are done upon <code>p</code> separately.</p> <p>Aside from that, C operators are pretty straightforward to read and write. CPP Reference has a pretty clear listing of each operator, their precedence, and their associativity.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#l-values-and-r-values","title":"L-values and R-values","text":""},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#statements","title":"Statements","text":""},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#if-else-statements","title":"If-Else Statements","text":"<pre><code>if(condition)\n  if(condition2) {\n    printf(\"conditions met\");\n    return 0;\n  }\n  else\n    printf(\"no conditions met\");\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#switch-statements","title":"Switch Statements","text":"<pre><code>switch(v) {\n  case 1: // v == 1\n    printf(\"v is 1\");\n    break;\n  case 2:\n    printf(\"v is 2\");\n    break;\n  default:\n    printf(\"v is neither 1 nor 2\");\n}\n</code></pre>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#loops","title":"Loops","text":"<pre><code>int i;\nfor(i = 0; i &lt; 10; i++) {\n    // do things here\n}\nwhile(i) { //condition checked at the beginning\n    //other things\n    i--;\n}\n\ndo {\n    //more things\n} while(i &lt; 5); //condition is checked at the end\n</code></pre> <p>Using <code>break;</code> inside a loop will break out of the innermost loop. Using <code>continue;</code> will stop executing the current iteration of the loop and skip to the next iteration. <code>for(;;)</code> is an idiom for an infinite loop. <code>goto label</code> will jump to a line beginning with <code>label:</code>. Be careful with gotos.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#appendix-optional-language-reference-material","title":"Appendix: Optional Language Reference Material","text":""},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#integer-declarations","title":"Integer Declarations","text":"<p>There are a few type modifiers we can use to specify exactly what kind of integer we want our compiler to declare for us.</p> <p>When we declare an integer type, we can modify it with the keyword <code>signed</code> or <code>unsigned</code> to tell the compiler the signedness of the integer. When unspecified, most integer types are signed by default.</p> <p>C also allows the programmer to use <code>long</code> and <code>short</code> as modifiers for <code>int</code>, which are the same as not having used the keyword <code>int</code> at all. So don't be alarmed if you see a <code>long int</code> type! It's just a <code>long</code>.</p> <p>Also, if we don't write <code>int</code> and only specify the signedness, it's an <code>int</code>.</p> <p>The following types in each row are equivalent:</p> <pre><code>| `short`                 | `short int`               | `signed short`        | `signed short int`     |\n| `long`                  | `long int`                | `signed long`         | `signed long int`      |\n| `long long`             | `long long int`           | `signed long long`    | `signed long long int` |\n| `int`                   | `signed`                  | `signed int`          |                        |\n| `unsigned int`          | `unsigned`                |                       |                        |\n| `unsigned short`        | `unsigned short int`      |                       |                        |\n| `unsigned long`         | `unsigned long int`       |                       |                        |\n| `unsigned long long`    | `unsigned long long int`  |                       |                        |\n</code></pre> <p>This is just a detail to watch out for, but not super important. By convention, most of the time we use the notation in the leftmost column.</p>"},{"location":"resources/cs3157recitations/D-Bits-Binary-C-Basics/c-basics/#the-const-type-qualifier","title":"The <code>const</code> Type Qualifier","text":"<p>The <code>const</code> keyword tells that compiler that once a variable is initialized, it shouldn't be assigned to again. The type qualifier can come either before or after the type:</p> <pre><code>const int x;\nint const y;\n</code></pre> <p>Note that this is only compile-time enforced. We can trick the compiler in the same way we did above in order to print floats in binary.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/","title":"Memory and Pointers","text":"<p>Understanding pointers and the ins and outs of memory usage in your program is a fundamental part of what makes you a strong C programmer! This note breaks down important elements that go into this understanding.   </p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#memory","title":"Memory","text":""},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#address-space","title":"Address Space","text":"<p>Every process, i.e a running program, gets 512G of virtual memory space. The memory layout is given in the diagram below.</p> <p></p> <p>The stack grows downward starting from 512G while the program code, static variables, and heap variables are all at the bottom (0), sitting in that order (Check the diagram above). This means that when functions are called, space for them is built up on the stack and then cleared as they complete. Imagine function calls being stacked on top of each other (but upside down) and then being popped off last to first as they return. The stack is a temporary storage space. Check out this diagram to build intuition on how the stack changes throughout your program. </p> <p>The heap is where you dynamically allocate memory - it is a storage space that is not automatically managed like the stack. You use the heap if you want to manage how long something is stored in memory, which means you are responsible for clearing any space you allocate on the heap. You also use the heap if what you\u2019re storing is considerably large. This is because there is an OS dependent limit on how much data can be stored in the stack, so the heap is a good choice if you don\u2019t want your storage needs to saturate your stack. Also note that unlike the stack, the heap grows upwards (towards the stack). </p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#variables","title":"Variables","text":""},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#stack-variables","title":"Stack Variables","text":"<p>When you declare a variable in C, it is defined for the current scope and will be released (removed from memory) at the end of the scope. If you re-declare a variable inside a scope within a \u2018nested\u2019 scope (see below), you won't be able to change the outer variable.</p> <pre><code>int x;\nx = 0;\n//do things with x\n{\n    int x;\n    x = 1;\n    //x is now 1 within here\n}\n//x is still 0 out here\n</code></pre> <p>The variables inside the curly braces are stack variables (also known as  automatic variables), and are stored on the stack. Their scope is local to a block (meaning code enclosed by curly braces, as shown above). They are created (pushed on the stack) when entering the block and destroyed (popped off the stack) upon exit.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#static-and-global-variables","title":"Static and Global Variables","text":"<p>Static and Global variables are stored in the static section of the C memory layout (see diagram above). 'static' has different meanings depending on where you declare your value. In general, global and static variables are created when the program runs, and they persist until the program ends. They have the lifetime of the program. They cannot be re-declared or re-initialized.</p> <pre><code>static int file_static = 0; // static global variable\n\nint foo(int auto_1) {\n    static int block_static = 0; //static variable\n}\n</code></pre> <p>A static global variable is declared by using the \u2018static\u2019 keyword on a variable declaration outside of any code blocks in the file, i.e outside of any function. Its scope is limited to the current file. It\u2019s accessible anywhere in the file it is declared in, but not in any other file. </p> <p>A static variable is declared by using the \u2018static\u2019 keyword on a variable declaration inside a function. It is initialized once and retains its value over successive calls of that function, as shown here (source):</p> <pre><code>int foo()\n{\n    static int x = 5; // assign value of 5 only once\n    x++;\n    return x;\n}\n\nint main()\n{\n    printf(\"%d\\n\", foo()); // prints 6\n    printf(\"%d\\n\", foo()); // prints 7\n    return 0;\n}\n</code></pre> <p>A global variable is like a special case of static variables. It is accessible from all files in the program, and can be accessed from other files using the <code>extern</code> keyword. See below:</p> <p>In one file:</p> <pre><code>int global_static = 0;\n\nint main() {\n    global_static++;\n    magic_print();\n    return 0;\n}\n</code></pre> <p>In another file:</p> <pre><code>void magic_print() {\n    extern int global_static;\n    printf(\"%d\\n\", global_static); // prints 1\n}\n</code></pre>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#pointers","title":"Pointers","text":"<p>Pointers are what will get you a job. Understanding pointers is crucial and using them naturally will make you stand out as a programmer. Let's start with the basics.</p> <p>Pointer: A variable that stores a memory address. That's it.</p> <p>There isn't just one data type called \"pointer\". Every pointer is a pointer-to-type, which encodes how to interpret the bytes you find in the memory address.</p> <p>In a variable declaration, an asterisk denotes the fact that the variable is a pointer.</p> <p>Here's an example:</p> <pre><code>int x = 5; // x is a plain int\nint *p; // p is a pointer-to-int\n</code></pre> <p>Spacing of asterisk doesn't matter, but <code>*p</code> is generally preferable as it  makes declarations clearer.  <code>int* p1, p2;</code> would lead you to assume that both  p1 and p2 are being declared as type int* (a pointer to an integer), but in  reality the compiler interprets this statement as if it was written  <code>int *p1; int p2;</code> - declaring p1 as a pointer to int and p2 as a normal int. Writing the declaration as <code>int *p1, p2</code> will avoid confusion in such cases.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#using-basic-pointers","title":"Using basic pointers","text":"<p>There are two basic operators that you use with pointers: </p> <p>The <code>&amp;</code> operator references a value, ie it gets the memory address of an already existing variable. It could then be stored into a pointer.</p> <pre><code>int x = 5; // x is a plain int\nint *p; // p is a pointer-to-int\np = &amp;x; // p now points to x\n</code></pre> <p>The <code>*</code> operator dereferences a pointer: it follows the pointer and gets the thing it points to.</p> <pre><code>int x = 5;\nint *p = &amp;x; \nprintf(\"%d\", *p); //prints out 5\n*p = 9;  // now x is 9\n</code></pre> <p><code>&amp;</code> and <code>*</code> are basically opposites: <code>&amp;</code> adds a level of indirection taking you further from the underlying value, while <code>*</code> removes a level, brining you closer. So <code>*&amp;x</code> is the same as <code>x</code>, as is <code>*&amp;*&amp;x</code>.</p> <p>There are limits though. Why do you think <code>&amp;&amp;x</code> is not valid? (Spoiler: because <code>&amp;x</code> is just a transient value of type <code>int *</code>, it's not a variable in memory, so you cannot get its memory address with the <code>&amp;</code> operator).</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#ok-so-why-use-pointers","title":"Ok, so why use pointers?","text":"<p>C is a call-by-value language which means all arguments to functions are  copied, and a local copy is made on that function's stack. Changes made inside the function are not reflected on the outside. Therefore if you want a function to modify a value that you have, you'll have to tell the function where to find the that value by memory address, not just give it the value:</p> <pre><code>void increment(int a) {\n  a++;\n}\n\nvoid actually_increment(int *b) {\n  (*b)++;\n}\n\nint main() {\n  int x = 1;\n  increment(x); // x is still 1\n  actually_increment(&amp;x); // x is now 2\n  return 0;\n}\n</code></pre> <p>Note not only the difference in the function, but how the parameters are passed. Passing a pointer is fundamentally a different type than passing a value.</p> <p>For more pointer examples, see <code>E-Memory-Pointers/code/basicpointers.c</code>.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#arrays","title":"Arrays ##","text":"<p>As per the C99 Standard: </p> <p>An array type describes a contiguously allocated nonempty set of objects with a particular member object type, called the element type. Array types are characterized by their element type and by the number of elements in the array.</p> <p>What exactly does that mean? Let's look at an example declaration and try to figure out.</p> <pre><code>int a[10];\n</code></pre> <p>This would allocate space on the stack for 10 elements of type <code>int</code>. The array is in contiguous memory locations. i.e., <code>a[1]</code> is located immediately after <code>a[0]</code>. Within the scope they were declared, arrays generally operate like you're used to in Java or other languages:</p> <pre><code>int a[10];\na[0] = 0;\nint i = 3;\na[i] = -1;\n</code></pre> <p>However note that arrays in C have no bound checking, so you can read/write an element past the end of the array. It may even work, at least most of the time, but it's undefined. Valgrind testing can catch some of this, and compiler warnings might catch others, but it's up to the programmer to be careful.</p> <pre><code>int a[10]\na[10000]; //the compiler lets you do this, but it's undefined\n</code></pre> <p>Declaring multidimensial arrays is also possible, but fairly rare.</p> <pre><code>int matrix[50][20];\n</code></pre> <p>The size of an array in C is returned by the <code>sizeof()</code> operator.</p> <pre><code>int a[10];\nprintf(\"%d\", sizeof(a)); // This will print \"40\"\n</code></pre> <p>The <code>sizeof()</code> operator returns the number of bytes occupied by the array. In this case, <code>a</code> is an array of 10 <code>int</code> elements. The <code>sizeof(int)</code> is 4, therefore the <code>sizeof(a)</code> = 40.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#pointer-arithmetic","title":"Pointer Arithmetic ##","text":"<p>If you have a pointer, you can do basic arithmetic with it to address adjacent elements. All arithmetic is with respect to the type of element being addressed, so if you have an int pointer <code>int *p</code>, <code>p+1</code> points to the next int, which is 4 bytes later. Think in terms of elements, not in terms of bytes.</p> <pre><code>int *p = q; //p is a pointer to int; it's pointing to the same place as q, exactly where doesn't matter now\np+1; //this is a pointer-to-int that's point to an integer that immediately follows p\n*(p+1); //this is an integer, the dereferenced value pointed to by the previous line\n*p++; //this returns the current derefenced value (ie the integer), and advances the pointer to the next element\n     //the above is VERY common when looping over arrays in C\n</code></pre>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#arrays-and-pointers","title":"Arrays and Pointers ##","text":"<p>You may have heard that \"arrays are pointers.\" While this is not true, arrays and pointers behave very similarly and it is important to know the differences!</p> <p>Jae's Grand Unified Theory of Pointers  Also known as Jae's GUT</p> <p>Given pointer <code>p</code> of type <code>T*</code> and integer <code>i</code> <code>*(p+i) == p[i]</code></p> <p>What does this mean? And how does it unify anything? Let's break it down. </p> <p>Given any pointer <code>p</code> of type <code>T*</code>, we can use pointer arithmetic to get the address of the next element with <code>p+1</code>. This address is <code>sizeof(T)</code> bytes after <code>p</code>. If this doesn't make sense, review the pointer arithmetic section above! </p> <p>We can understand <code>p+i</code> in the same way as above. The address returned by the expression is <code>sizeof(T)</code> * <code>i</code> bytes after <code>p</code>, or the address of the <code>i</code>th element of type <code>T</code> after <code>p</code>. E.g. <code>i=3</code>, and <code>T</code> is a <code>char</code>, then <code>p+i</code> returns a <code>char *</code> that holds the address three characters after <code>p</code>. </p> <p>Does it make sense that <code>p+i</code> is 3 bytes after <code>p</code>? If not, make sure to understand before moving on!</p> <p>What Jae's GUT says, other than feed me, is that the <code>p[i]</code> is exactly the same thing as <code>*(p+i)</code>. Essentially, we can use the square brackets <code>[]</code> with a pointer to find the address of the <code>i</code>th element away from <code>p</code>. Then we can dereference the new address and voil\u00e1, we have the <code>i</code>th element itself!</p> <p>If this is sounding a lot like an array, that's because it basically is! If we set a pointer to the beginning of an array, we can use the exact same syntax to access the elements in the array that we want.</p> <pre><code>int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nint *p = a; // p points to the first element of `a`, 0\nint *p = &amp;a[0]; //p still points to 0\n\n*(p+5) == a[5]; // 5 == 5\n\np+5 == a+5; // p+5 is a pointer to the 5th element of the array, so is a+5\n</code></pre> <p>Jae's GUT goes the other way too! Arrays, in cases of pointer arithmetic, operate as pointers to the first element.</p> <p>i.e. Given an array <code>a</code> of type <code>T</code> elements  a+1 == &amp;a[0]+1</p> <p>So aren't pointers and arrays the same? Wrong! Here are the cases in which arrays do not act like pointers.</p> <p><code>sizeof</code> operator</p> <p>As mentioned above, the size of an array is Note that as discussed above, <code>sizeof</code> is an operator, not a function.  Which means that for classic C <code>sizeof</code> is evaluated at compile time, so the value of the operator cannot be anything that depends on user input.</p> <p>Array is a constant variable</p> <pre><code>int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nint *p = a; // p points to the first element of `a`, 0\n\np++; // ok: `p` is just a pointer like any other, p now points to the next element in the array\na++; // illegal (will throw an error): `a` is an array name, a constant variable\n</code></pre> <p>Unlike a pointer, though, an array is a constant variable. You cannot change its assignment after it has been created, it must point to the same chunk of memory.</p> <p>Arrays cannot be passed into functions</p> <p>Note that once you pass an array into a function, the array becomes a pointer to the first element, and loses all its array-ness. So within the scope where <code>int a[10]</code> was declared, <code>sizeof(a)</code> returns the number of bytes of the array <code>a</code>, ie 40. But if you pass <code>a</code> into a function as <code>arr</code>, then <code>sizeof(arr)</code> is NOT 40, but 8, the size of a pointer.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#strings-in-c","title":"Strings in C","text":"<p>Strings in C are just a special case of arrays: C strings are arrays of characters with a null terminating character at the end.</p> <pre><code>char c[] = \"abc\";\nchar c[] = {'a', 'b', 'c', '\\0'}; // equivalent to the above line\nchar *s = \"my string\"; // modifiable pointer\n\"my string\"[0] == 'm'; //true!\n</code></pre> <p>There's a slight difference between these two definitions. <code>c</code> is an array which means you can't move where it points to: it's always going to point to the character  <code>a</code>. <code>s</code>, on the other hand, can be incremented and decremented and moved around  however you like. <code>\"my string\"</code>, however, can't be modified; it's a string literal! </p> <p>Some useful string functions (need to <code>#include string.h</code>):</p> <pre><code>char d[20];\nchar c[] = \"abc\";\n\nstrcpy(d, \"123\");\nstrcat(d, c);\n\nprintf(\"%s\\n\", d);          // prints 123abc\nprintf(\"%lu\\n\", strlen(d)); // prints 6\n\nstrncpy(d, \"456\", 2);       // only copy first n chars\nd[2] = '\\0';                // null terminate string\nstrncat(d, \"def\", 2);       // only cat first n chars\n\nprintf(\"%s\\n\", d);          // what does this print?\n</code></pre> <p>For a closer look at the strcpy function, see <code>E-Memory-Pointers/code/strcpy.c</code>.</p> <p>So how about an array of strings? Well that would be an array of arrays.</p> <pre><code>char *a[] = {\"hello\", \"world\" };\nchar **p = a;\nchar a[][10] = {\"hello\", \"world\" }; //what's the difference here?\n</code></pre> <p>You can find more examples of this in <code>E-Memory-Pointers/code/ptrtoptrs.c</code>.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#heap-allocations","title":"Heap allocations","text":"<p>Sometimes you need memory to persist across function calls (recall pseudo-pass-by-reference using pointers). Recall also that variables declared within a scope will be cleared once the scope's stack frame collapses. In other words, if you're trying to pass back a pointer to a variable that was declared within the function as a return value, it won't be there when you try to access it. To alleviate this you can allocate space on the heap using malloc.</p> <p>(From Jae's notes)</p> <pre><code>int *p = (int *) malloc(100 * sizeof(int));\n// malloc returns NULL if it cannot allocate the requested memory\nif (p == NULL) {\n  perror(\"malloc failed\");\n  exit(1); \n}\n// initialize all elements to 0\nfor (int i = 0; i &lt; 100; i++)\n  p[i] = 0;\n// another way to do the same thing\nmemset(p, 0, 100 * sizeof(int));\n//free() deallocates the memory block previously returned by malloc.\nfree(p);\n</code></pre>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#memory-errors","title":"Memory Errors","text":"<p>You'll be testing your code with valgrind for this class to make sure you don't have any memory errors in your code. This can include forgetting to free allocated memory, accessing memory that doesn't exist, etc. To run valgrind call:</p> <pre><code>valgrind --leak-check=full ./your_executable\n</code></pre> <p>Recall from other classes that if valgrind doesn't return, it means your program isn't returning (this is a case of the halting problem). If your valgrind isn't giving you line numbers (and is giving you hex codes) then you're not compiling with the debugging flag <code>-g</code>.</p> <p>The following are excerpts from <code>recitation-4-code/invalidwrite.c</code> and <code>recitation-4-code/leak.c</code>.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#valgrindmakefilegood","title":"Valgrind+Makefile=Good","text":"<p>Remembering to run valgrind, and retyping the command, is annoying. A clever way to more easily run valgrind repeatedly as part of your normal edit/compile/test loop is to add valgrind to your makefile. Remember how you can include phony targets in your Makefile? We can use that to have it run Valgrind for us.</p> <p>For example, using Jae's Makefile template from lecture note 1, you can add a stanza at the end:</p> <pre><code>.PHONY: valgrind\nvalgrind: main\n    valgrind --leak-check=full ./main\n</code></pre> <p>Then instead of running <code>make</code> followed by <code>./main</code> you can just run <code>make valgrind</code> and it will compile your code and run it under valgrind.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#invalid-write","title":"Invalid Write","text":"<p>This is pretty easy to do but hard to catch in your code. Like many memory errors its usually caused by an off-by-one error. Imagine this:</p> <pre><code>int *p = (int *)malloc(sizeof(int));\n// checking that malloc worked\nif (p == NULL) {\n  perror(\"malloc failed\");\n  exit(1);\n}\n</code></pre> <p>You'll have a pointer, <code>p</code>, to one integer worth of space. Now imagine we move our pointer ahead one integer</p> <pre><code>p++;\n</code></pre> <p><code>p</code> will now point past the space it was allocated. We know nothing about this space. It could be accessible, it could be protected. It could be someone else's variable that we're about to change. This is terrible. But let's mess around with it.</p> <pre><code>*p = 5;\n</code></pre> <p>What happens? You've got an invalid write. What about</p> <pre><code>int x = *p\n</code></pre> <p>Now you've got an invalid read. Valgrind will tell you about these and where they're happening. So long as you know what you're looking for you should be able to find it.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#memory-leaks","title":"Memory leaks","text":"<p>Calling malloc without free-ing the memory you've allocated is awful. You're taking away memory from other running processes.  To correct for this, when you're finished, just call <code>free()</code> on the pointer to the memory that was malloced.</p> <pre><code>free(--p);\n</code></pre> <p>Now aside from those invalid read/writes, our program will run through valgrind pretty happily. The trick to memory leaks isn't just in free-ing that integer though. Imagine you've malloced space for an array of arrays, each of which was also malloc'ed. You'll have to go back through, freeing each individual array, and then when you're finished with that, free the higher order array.</p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#uninitialized-values","title":"Uninitialized values","text":"<p>Valgrind will also inform you when the visible behavior of the program is affected by usage of uninitialized values. For example, let's say you want to increment a variable, but forget to initialize it:</p> <pre><code>int *d = (int *)malloc(sizeof(int));\n++*d;\nprintf(\"%d\\n\", *d);\n</code></pre> <p>Valgrind will inform you that the visible behavior of your program depends on an uninitialized, hence unpredictable, values. Always be sure to initialize your variables before using them! </p>"},{"location":"resources/cs3157recitations/E-Memory-Pointers/memory-pointers/#lab-2","title":"Lab 2","text":"<p>Tips:   - Test all your code with valgrind. Just do it.   - Watch out for fence post errors when it comes to invalid read/writes. You're     probably just one outside of your bounds   - Watch out for being just inside your bounds on freeing. If you have a leak,     its probably because you forgot to free one last element.   - Don't forget that in C, strings are characters arrays followed by a null     character. Without the null character, C has no idea where your string ends!   - ALWAYS check the return value of malloc to make sure you were actually given     allocated memory.   - Name your executables properly. For part1, <code>isort</code> and for part2, <code>twecho</code>.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/","title":"Function pointers","text":"<p>This note aims to cover topics useful for lab 3, material from Jae's lecture  note 9, and information that's useful for completing the practice midterm.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#function-pointers-kr-511","title":"Function Pointers (K&amp;R 5.11)","text":"<p>When writing a program, you'll often want your program to offer different  possible behaviors, but it's difficult to anticipate what behaviors users might  desire. For example, when writing a sort function, you could include a parameter that allows users them choose between sorting ascending and descending. However, what if a user wanted to sort characters by unicode value instead of lexicographically? For this, the user has to supply their own functionality. This is an example of where function pointers are useful, as they allow you to pass in different functions for different jobs. Some higher level (read: lambda-programming languages) support this is in a more 'native' way, but C does a pretty good job, too.</p> <p>In short, function pointers make it possible to swap out functions.  Making parts of your code easy to swap out makes your code more modular and  extensible. These are characteristics of good code.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#accepting-functions-as-a-parameter-to-your-function","title":"Accepting functions as a parameter to your function","text":"<p>Function pointers allow you to accept functions as a parameter to another  function. Here's an example of that functionality:</p> <pre><code>void notifier(int (*fn)()); // method declaration; could be in separate .h file\n\nvoid notifier(int (*fn)()) {\n  printf(\"Starting\\n\");\n  fn();                   // calling function passed in as a parameter\n  printf(\"Finished\\n\");\n}\n</code></pre> <p>Let's examine this more closely. We have a function called <code>notifier</code> whose only parameter is another function. When we include a function pointer in a method declaration, we specify what type of function it accepts. </p> <p>The layout for a function pointer type is: <pre><code>  returntype (*functionName)(parameter1type, parameter2type, ...)\n</code></pre> The type of our function pointer is denoted by its return type and the  types of its parameters. The name of the function being preecded with an asterisk tells us its a pointer.  The function is surrounded by parentheses so that the compiler doesn't think  we've got a variable <code>returntype *functionName</code>. The parentheses following the  declaration are necessary as well, even if the function we want to accept  doesn't have any arguments. </p> <p>Notice that the parameters do not have names. Only their types are declared so  that the compiler can check these.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#passing-a-function-as-a-parameter","title":"Passing a function as a parameter","text":"<pre><code>int wasteTime() {\n  int i = 0;\n  while(i &lt; 1000000)\n    i++;\n  return i;\n}\n\nint main(int argc, char **argv) {\n  wasteTime();\n  notifier(wasteTime);\n  return 0;\n}\n</code></pre> <p>Notice the function called <code>wasteTime</code>.When we follow <code>wasteTime</code> with parentheses, the function is called. When we don't include parentheses, <code>wasteTime</code> is automatically a function pointer. Why is this?</p> <p>Everything in a process is stored in memory, even the functions, which means even they have an address. So <code>wasteTime</code> has an address in memory. When you follow <code>wasteTime</code> with parentheses (<code>wasteTime()</code>), C goes to the address and executes the function. If you think of <code>wasteTime</code> as storing a pointer to a function, then you can think of <code>wasteTime()</code> as dereferencing the pointer. Therefore, when we call <code>notifier</code> and pass it <code>wasteTime</code> without parentheses, it passes the address to <code>wasteTime</code> to the <code>notifier</code> function.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#calling-functions-from-pointers","title":"Calling functions from pointers","text":"<p>While we can't declare a function from the body of a method, we can declare and initialize function pointers. Let's expand on the code we've written so far:</p> <pre><code>int main(int argc, char **argv) {\n  int (*f1)();                        // declare function pointer\n  char *(*f2)(char *, const char *);\n  char arr[5] = \"bann\";               // initialize string\n\n  f1 = wasteTime;                     // assign already defined function to function pointer\n  f2 = strcpy;\n\n  notifier(f1);                       // pass function as a parameter\n  f2(arr, \"hihi\");                    // invoke function using a pointer to it, rather than its actual name, strcpy\n  printf(\"%s\\n\", arr);\n}\n</code></pre> <p>As you can see from the above code, you can declare variables of type \"function pointer\" and assign functions to their values. Then you can call those functions simply by adding parentheses to the end of the variable name. Make sure to check out Jae's notes (lecture 7) for more complicated examples of this. Notice that we did the same thing when calling <code>fn()</code> in our <code>notifier</code> function.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#functions-vs-pointers-to-functions","title":"Functions vs Pointers to Functions","text":"<p>Functions aren't quite like regular variables, so function pointers aren't quite like regular pointers either. Think about this small program:</p> <pre><code>void myFunc(int x) {\n  x++; \n}\n\nint functionAcceptor(void (*f)(int), void (*g)(int)) {\n  return f == g;\n}\n\nint main() {\n  char *s = functionAcceptor(myFunc, &amp;myFunc) ? \"They're the same thing.\" :\n    \"They're totally different.\";\n  printf(\"%s\", s);\n}\n</code></pre> <p>What will this program print? Notice the line where we're comparing  <code>myFunc</code> and <code>&amp;myFunc</code>.</p> <pre><code>They're the same thing.\n</code></pre> <p>Why? Because referencing a pointer to a function just gets you the same pointer back. It has no effect. How boring.</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#bonus-functions-with-variable-arguments","title":"Bonus: Functions with Variable Arguments","text":"<p>This will come up again later on in the semester, but know that C (like Java) can have functions with a varible number of functions. If you think about it, <code>printf()</code> is a good example: you could have <code>printf(\"%d\\n\", x)</code> or  <code>printf(\"%d and %d\\n\", x, y)</code>. Once you've enumerated all the required arguments, you can specify that you would like to also accept variable arguments with an ellipsis (<code>...</code>):</p> <pre><code>int myFWithVarArgs(int a, int b, ...);\n</code></pre> <p>To reiterate, this will be brought up again later in the semester, but it's  good to get acclimated to this syntax.  Bonus: the e;lipsis works in Java function declarations too!</p>"},{"location":"resources/cs3157recitations/F-Function-Pointers/function-pointers/#some-notes-about-lab-4","title":"Some Notes About Lab 4","text":"<p>If you plan on doing the pair option and would like to  procure a private GitHub repo, please request one  ASAP, because it takes a few days to process. Additionally, if you're new to  GitHub/BitBucket, you may find the Git Documentation,  the GitHub Help page, and the  BitBucket Documentation handy.</p> <p>Whether you choose to do the pair option or the solo option, you may wish to  review each of the I/O functions we've learned in lecture note 9. Be sure that  you understand the differences between them and note that there are certain situations when some are more appropriate than others, and vice versa (ex., <code>fgets()</code> vs. <code>fread()</code>).</p>"},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/","title":"Structs unions","text":""},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#structs-kr-6","title":"Structs (K&amp;R 6)","text":"<p>Structs are kind of like Java's objects but for C. Fundamentally, they allow you to declare a collection of one or more variables grouped under a single type. A struct cannot, however, contain functions/methods. A struct can only contain other datatypes such as pointers, <code>int</code>, <code>char</code>, <code>float</code> or even other structs. An example struct:</p> <pre><code>struct point {\n  int x;\n  int y;\n};\n</code></pre> <p>and usage</p> <pre><code>struct point pt = {50, 100};\npt.x == 50; // 1\npt.y = 3;\npt.y == 100; // 0\n</code></pre> <p>Notice that values within a struct can be accessed and modified using the <code>.</code> operator in the form <code>structure-name.member</code>. We can declare another structure that uses the one we already have.</p> <pre><code>struct rect {\n  struct point p1;\n  struct point p2;\n};\n// Usage:\nstruct point leftTop = {50, 40};\nstruct point rightBottom = {100, 0};\nstruct rect myRect = {leftTop, rightBottom};\nmyRect.p1.x += 5; //now 55\n</code></pre> <p>Structs, like everything in C, are passed by value. This means if you pass a structure as a parameter to a function, the function will receive a copy of the struct, with all its values copied by value. This means if your struct contains a pointer, the value of the pointer will be copied (and it will point to the same location in memory). If you want to pass a pointer to a struct, you can dereference it with the <code>&amp;</code> operator as you can with all data types. Pointers to structure are frequently used, so there is a shorthand for accessing their members:</p> <pre><code>struct point pt = {50, 50};\nstruct point *ppt = &amp;pt;\nppt-&gt;x = 25;\nppt-&gt;x == (*ppt).x; // 1\n</code></pre> <p>The shorthand just saves you the hassle of writing out line 4 of the code above. Also, if you don't want to write out the keyword <code>struct</code> every time, you can just declare your struct as follows:</p> <pre><code>typedef struct {\n  int x;\n  int y;\n} Point;\n\nPoint pt = {50, 50};\n</code></pre> <p>Make sure to read the K&amp;R on this to learn some interesting use cases for structures. Note that a struct can contain a pointer to its own type (but not directly a member of its own type). This is particular useful for data structures like trees.</p> <pre><code>typedef struct Node_t {\n  void *value;\n  struct Node_t *parent;\n} Node;\n\nNode root, child1, child2, child3, child4;\nchild4.parent = &amp;child2;\nchild3.parent = &amp;child2;\nchild2.parent = &amp;root;\nchild1.parent = &amp;root;\n</code></pre> <p>Bad:</p> <pre><code>/* this won't work */\ntypedef struct {\n  void *value;\n  Node *parent;\n} Node;\n\n/* neither will this */\nstruct {\n    void *value;\n    Node parent;\n} Node;\n</code></pre>"},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#union-optional","title":"Union (optional)","text":"<p>A union is really nifty. It's like a structure, but, wait for it, all of its members are stored at the same location in memory. This means when you allocate a union, enough space is allocated for the largest member's type. This means if you were to declare a type as follows, you could use it to store any one of the three types.</p> <pre><code>union u_tag {\n  int integer_value;\n  float float_value;\n  char *string_value;\n}\n\nunion u_tag u;\nu.integer_value = 5;\nint x = u.integer_value;\nu.float_value = 3.14f;\nfloat f = u.float_value;\n</code></pre> <p>Union's are nifty for situations where you don't know just yet what kind of data you need to store but want to be smart about the space you allocate. Just be careful that you don't store something as one type and then read it out as another. While possible, the behavior is compiler dependent.</p>"},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#odds-and-ends","title":"Odds and Ends","text":""},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#string-operations-in-c-library","title":"String Operations in C Library","text":"<p>Jae has some functions listed in the notes from the Standard C Library for string operations. I'm not going to explain them all here, but I will point out some nasty little things to be aware of.</p> <ul> <li><code>strlen</code> runs in O(n) because you can't know the length of a string without     traversing it to find the null character.</li> <li><code>strcpy</code> and <code>strncpy</code> require that there is enough space in your     destination memory location for the source string. Also watch out when using     <code>strncpy</code> that all your strings are null terminated.</li> <li><code>strcat</code> runs in O(n) too. So if you're running lots of strcats, watch out     because you could end up with tons of passes over a single string.     Exponential even.</li> <li><code>memcpy</code> is great for cleaning things up. Just sayin'.</li> </ul>"},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#const","title":"Const","text":"<p><code>const</code> is a keyword for types in C that prevents them from being modified. It's important to understand that this means once the variable is declared, the memory it is referring to cannot be modified. Some examples:</p> <pre><code>int x = 1;\nint y = 2;\n\nconst int *const_val = &amp;x;\n*const_val = 3; //invalid: value in memory is constant\nconst_val = &amp;y; //valid: value of pointer, ie. memory location, is not constant\n\nint *const const_ptr = &amp;x;\nconst_ptr = &amp;y; //invalid: value of pointer, is constant\n*const_ptr = 4; //valid: value in memory is not constant\n\nconst char *const why = \"You'll never change anything about me. Ever\";\n</code></pre>"},{"location":"resources/cs3157recitations/G-Structs-Unions/structs-unions/#struct-padding","title":"Struct padding","text":"<p>For performance and for compatibility between different types of machines, C compilers will sometimes add padding to structs. For example:</p> <pre><code>struct test {\n    char c;\n    int n;\n};\n</code></pre> <p>The int takes up 4 bytes and the char takes up one byte. However, <code>sizeof(struct test)</code> on CLAC is <code>8</code>. Although it's useful to know that padding can happen, it isn't covered in this class, and for all intents and purposes you can assume that structs have no padding if you're ever asked about them.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/","title":"GDB, Valgrind, and Debugging","text":"<p>There are three commonly used debugging methods in this class. </p> <ol> <li><code>printf</code></li> <li>valgrind</li> <li>gdb</li> </ol>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#printf","title":"printf","text":"<p>First, <code>printf</code>, which you probably use all the time.</p> <p>Imagine this program fragment, which is currently crashing.</p> <pre><code>foo();\nprintf(\"foo complete\");\nbar();\n</code></pre> <p>We added the printf line to the program to determine if the program was crashing during <code>foo()</code> or during <code>bar()</code>. If we see \"foo complete\", we can determine that foo definitely completed.</p> <p>However, if we do not see \"foo complete,\" we cannot determine anything! The C standard library may have buffered our standard output for us, so we need to make the debugging print statement <code>printf(\"foo complete\\n\");</code>. The newline encourages the C standard library to send the text to the display immediately.</p> <p>It would be even better to print debugging information to stderr. This is a bit advanced for right now, but you use a slightly different function, <code>fprintf</code>, which lets us specify the destination. It's fairly simple: <code>fprintf(stderr, \"foo complete\\n\");</code>.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#valgrind","title":"valgrind","text":"<p>After compiler warnings, valgrind is the first tool you should turn to whenever you're dealing with possible memory problems. It analyzes your program as it runs for memory errors and leaks. </p> <p>Valgrind is very easy to use. All you do is call the program normally, but prepend <code>valgrind --leak-check=full</code> to the beginning.</p> <pre><code>$ ./twecho hello world # Without valgrind\n$ valgrind --leak-check=full ./twecho hello world # With valgrind\n</code></pre> <p>Your program runs completely normally, including letting you type in as you wish. At the end, whether your program crashed or exited normally, it prints out a status report, which reports two problems:</p> <p>Memory Errors. These are illegal memory accesses, which may result in weird behavior, and crashes. If your program is crashing or acting up, identifying and fixing these are your second priority (number 1 is fixing compiler warnings).</p> <p>What are examples of this? The simplest one is to imagine you have an array, <code>int arr[10];</code>, and you try to set <code>arr[11] = 11;</code>. The compiler won't warn you about it in any non-trivial case. However this is a memory error, and may cause your problem to crash or act weird. Luckily valgrind will report it, and even tell you which line of code it's happening on.</p> <p>Lost Memory. You need to know about malloc and heap memory for this to make sense, but suffice it to say that you don't want to leak memory because the more memory you leak, the less memory other running programs will have to use.</p> <p>Let's try it on a sample program, <code>leaky.c</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char **argv) {\n    int *pint = (int *)malloc(sizeof(int));\n    if (pint == NULL) {\n        perror(\"malloc returned NULL\"); /* Jae often defines a die() to do this */\n        exit(1);\n    }\n    *pint = 4;\n\n    printf(\"The value pointed to by pint is %d \\n\", *pint);\n\n    return 0;\n}\n</code></pre> <p>Notice that it says you definitely lost 1 block of 4 bytes. The 1 block is from the call to malloc on line 5. You can tell it's that file and line number because it says <code>(leaky.c:5)</code>. </p> <p>To fix this program we need to free the memory block we malloc'd. Immediately before the return, add <code>free(pint);</code>.</p> <p>If you need valgrind to give you even more debugging information, you can add two more flags:</p> <ul> <li><code>--show-reachable=yes</code> gives more information about memory</li> <li><code>--track-origins=yes</code> gives more information about uninitialized values.</li> </ul> <p>Thus, a more verbose valgrind command is: <code>valgrind --leak-check=full --show-reachable=yes --track-origins=yes ./leaky</code></p> <p>Note: You should ignore all suppressed errors. They're known problems with the standard library functions, and they're suppressed because there's nothing you can do about them.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#aside-why-use-g-when-compiling","title":"Aside: why use <code>-g</code> when compiling?","text":"<p>This is the perfect time to discuss something we glossed over in the first CLAC recitation. We told you to always compile your code with <code>gcc -g</code>. Why are you using <code>-g</code> though?</p> <p><code>-g</code> embeds debugging information into the object files, and then into the executable file. Debugging information includes which lines of source code are being executed, what variables are called, and all sorts of good stuff like that. Try recompiling leaky.c above, but without the <code>-g</code> flag. When you run valgrind it will only report file names, not line numbers, for your errors.</p> <p>Note: Valgrind is well-supported on Linux only. On OS X, clang's Address Sanitizer offers something similar. On Windows, there are many Visual Studio plugins for memory checking.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#gdb","title":"gdb","text":"<p>gdb is a debugger. It lets you stop time, look around your program, and maybe even change things. It's incredibly powerful, but can be a little intimidating. Don't worry, the basics aren't so bad.</p> <p>gdb has very concise help, at any time just run <code>help foo</code> to get help about foo, or just type <code>help</code> alone to list all commands.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#loading-a-program","title":"Loading a program","text":"<p>To get started we just need to compile our program (using <code>-g</code> of course). You can go into our <code>code</code> directory, and simply call make. Then, run <code>gdb -tui [program name]</code></p> <p>In our case, </p> <pre><code>$ gdb -tui main\n</code></pre> <p>That opens gdb with a Text User Interface, TUI in short, which is a terminal interface which uses the curses library to show the source file, the assembly output, the program registers and GDB commands in separate text windows.</p> <p>You need to give gdb instructions now, which is where it gets scary.</p> <p>However it's really easy! Once you hit the enter key, you will see the source code of the main.c file. </p> <p>Type <code>run</code> and it will start (include any arguments after run if your program needs them, ie <code>run hello world</code>). You'll notice that the program just runs straight through, but I promised you could stop time!</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#breakpoints","title":"Breakpoints","text":"<p>The main way of stopping time is a breakpoint. Breakpoints are points in the source code at which gdb will pause running your program. Setting breakpoints is the first, most important, step in debugging.</p> <p>There are three main types of breakpoints:</p> <ol> <li><code>break 10</code> to break on line 10 of the current source file</li> <li><code>break mymath.c:14</code> to break on line 14 of mymath.c</li> <li><code>break multiply</code> to break at the very beginning of the function <code>multiply</code></li> </ol> <pre><code>(gdb) break 10\nBreakpoint 1 at 0x6de: file main.c, line 10.\n(gdb) break mymath.c:14\nBreakpoint 2 at 0x78d: file mymath.c, line 14.\n(gdb) break multiply\nNote: breakpoint 2 also set at pc 0x78d.\nBreakpoint 3 at 0x78d: file mymath.c, line 15.\n</code></pre> <p>Type <code>run</code> and it will start again and stop at the break point. If you want to go to the next break point, all you need to do is type <code>continue</code>. While you're at each break point, you can print the value of a specific variable by <code>print [variable name]</code></p> <p></p> <p>You can take your breakpoints to the next level with conditional breakpoints. You set these up just like normal breakpoints, but add <code>if expression</code> to only break if a certain thing is true. For example, if you have a loop that counts down from 100, but you only want to break near the end, you could do <code>break 10 if i &lt;= 2</code> to avoid breaking on the first 97 iterations. </p> <p>Deleting breakpoints is easy. Typically, you can do <code>clear</code> and then the line you used to create the breakpoint. You can also do <code>info breakpoints</code> to get a list of your current breakpoints, and then <code>delete i</code> to get rid of the ith one.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#watchpoints","title":"Watchpoints","text":"<p>You can also set a watchpoint on a variable. For example, <code>watch x</code> stops the program whenever the value of <code>x</code> changes. However you can only setup a watchpoint after the variable has been declared, so you'll first need to set a breakpoint.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#examining-the-program","title":"Examining the program","text":"<p>Once you're stopped, you need to see what's going on. There are a few commands that can let you examine the program.</p> <p>First, let's figure out what function you're in, and how you got here.</p> <p><code>backtrace</code> (or <code>bt</code>), prints the call stack, including arguments. This can be especially useful in recursive programs.</p> <p><code>frame [n]</code> moves you to the nth call shown in the output of <code>backtrace</code>. This can be helpful in determining how function arguments are generated.</p> <p><code>print expression</code> will print out an expression. For example <code>print x</code> prints out x, or <code>print *x</code> prints out the pointer x after dereferencing it. We can specify a format parameter with a slash, ie <code>p/t x</code> will print out x formatted as binary. The parameters are:</p> <ul> <li><code>d</code> for signed decimal</li> <li><code>u</code> for unsigned decimal</li> <li><code>x</code> for hexadecimal</li> <li><code>o</code> for octal</li> <li><code>t</code> for binary</li> <li><code>a</code> for address</li> <li><code>c</code> for character</li> <li><code>f</code> for floating point</li> </ul> <p>There is also a <code>x</code> command to print memory addresses and specify more complex formatting and print multiple values. For example, if we had <code>long y = -1;</code> in our program, and we were stopped in gdb, we could do <code>x/tl &amp;y</code> to print out the value of y in binary. We could also do <code>x/2xi &amp;y</code> to print out the value of y in hex, </p> <p><code>info locals</code> will print out all the locally defined variables. It doesn't include everything you might think: in particular, it doesn't include function parameters, so you'll have to use <code>print argumentName</code> to see those.</p> <p><code>ptype variable</code> prints the type of a variable! This can be nice with multiple pointers and such. For example, <code>ptype x</code> will say x is an int. This has a more powerful analog <code>whatis expression</code>, which lets you specify any arbitrary expression, for example <code>whatis &amp;x</code>, which will say <code>int *</code>.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#setting-values","title":"Setting values","text":"<p>Aaaarg, that's so close, except x should be 3, not 2, at the points! Fear not! With gdb you can set values! Just run</p> <p><code>set variable = expression</code>, for example <code>set x = 4</code>, and it will change it for you. (Unfortunately, it's not possible to change code.)</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#resuming","title":"Resuming","text":"<p>Once you've stopped, after you're doing examining the code, you need to resume execution. There are basically 3 amounts that you can resume by. In order from smallest to largest they are:</p> <p><code>step</code> runs the code line by line, and steps into functions. That means if your code calls <code>foo()</code> on the next line, you'll continue going line by line through the code of foo. </p> <p><code>next</code> also runs the code line by line, but it goes over functions. So if you call <code>bar()</code>, it will skip over the call and continue within this block of code. Generally, for example, you want to use <code>next</code> over library functions.</p> <p>You can combine step and next with a number, eg, <code>step 4</code> to step 4 times at once.</p> <p><code>continue</code> resumes executing your program until you get to another breakpoint.</p> <p>There are a few more esoteric ones, such as <code>finish</code> to wait for the return,  Control-C to send sigint, and kill to end it. </p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#summary-essential-commands","title":"Summary: Essential Commands","text":"<ul> <li><code>break</code> <code>line</code> / <code>file:line</code> / <code>function</code></li> <li><code>run</code></li> <li><code>backtrace</code></li> <li><code>print</code> <code>variable/expression</code></li> <li><code>step</code></li> <li><code>next</code></li> <li><code>continue</code></li> </ul>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#tips","title":"Tips","text":"<p>Almost all gdb commands can be abbreviated to a single letter. Instead of typing <code>break</code> you can just type <code>b</code>, instead of <code>continue</code>, <code>c</code>, etc. If you want to list all the breakpoints, you could type <code>info breakpoints</code>, but you could also just type <code>i b</code>.</p> <p>Pressing enter will repeat the most recent command.  No longer do you need to mash <code>s</code> or <code>n</code>!</p> <p>Control-L is a common keyboard shortcut to clean up the screen. It can be helpful if your program outputs some weird stuff and it all looks janky. Also works in bash.</p> <p>You can jump to arbitrary points in execution, but don't you already have enough rope to hang yourself?</p> <p><code>-tui</code> shows the source code in the top half. Use the arrow keys to navigate.</p> <p>You can quit with <code>quit</code>, <code>q</code>, and Control-D typically.</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#core-dumps-and-gdb","title":"Core Dumps and gdb","text":"<p>Sometimes your program will encounter a segmentation fault. You'll see \"Segmentation Fault (core dumped)\" printed to the terminal. By default, this \"core dumped\" message doesn't do anything. This is because by default core dump files are limited to size 0. However, we can change this quite easily by running <code>ulimit -c unlimited</code>. Now when we segfault, we'll get a file called \"core\" in the working directory.</p> <p>This \"core\" file provides a picture of the memory at the time the segfault was encountered. Luckily all of these fancy UNIX tools work great together so we can used gdb to help us do some detective work! By running <code>gdb ./my_program core</code>, we're instructing <code>gdb</code> to load the memory picture at the time of the seg fault. We can then navigate around using the gdb commands we just learned (like <code>bt</code> and <code>info locals</code>) to figure out exactly what caused the segfault!</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#example","title":"Example","text":"<p>It helps to have a concrete example in hand while doing this. Let's calculate  2^4, but let's do it the old fashioned way, where exponentiation is repeated multiplication, and multiplication is repeated addition. </p> <p>We're going to define our general math functions in a file called <code>mymath.c</code>, which of course has its associated <code>mymath.h</code>.</p> <p>Then we'll start our program in main.c. To make things a little more interesting, we're going to use some basic pointers. First we setup two basic integers, <code>a</code> and <code>b</code>. Then we take the memory address of <code>a</code>, and store it in the pointer-to-int <code>x</code> (and likewise with b and y).</p> <p>Then we pass the pointers into our exponentiation function. It performs the appropriate number of multiplications, each of which requires an appropriate number of additions, and then return the value to main.</p> <p>Main prints out <code>2^-1 = 16</code>. What's going on? That's crazy!</p> <p>Let's debug to find out!</p> <p>Spoiler: in the exponentiation, we do <code>(*y)--</code>, which permanently changes y!</p>"},{"location":"resources/cs3157recitations/I-Debugging-GDB/gdb/#external-resources","title":"External Resources","text":"<ul> <li>Dense, incredibly helpful gdb reference card</li> <li>Slightly slimmer gdb cheat sheet</li> <li>Look at Jae's emails \"ANN: Doing lab 2\", and \"ANN: Debugging Tips\"</li> <li>Official GDB guide</li> <li>Handy walkthrough pdf that covers unix basics, gcc, gdb, make, and basic shell</li> </ul>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/","title":"Fork exec","text":""},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#nix-systems","title":"*nix Systems","text":""},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#the-stack","title":"The Stack","text":"<ol> <li>Hardware: These are the physical components, i.e. the processor, disk, keyboard, etc...</li> <li>OS Kernel: The kernel is the core of an operating system that loads first, controls resources, and performs fundamental tasks.</li> <li>System Calls: These are calls/requests for kernel operations. Some examples are <code>open()</code>, <code>signal()</code>, <code>fork()</code> and <code>exec()</code>. We'll see <code>fork</code> and <code>exec</code> in detail in this document.  </li> <li>Library Functions: These are inbuilt functions that come with programming language and perform specific functions, e.g. <code>printf()</code>, <code>malloc()</code></li> <li>Applications: These are the end-user programs like emacs, gcc, and executables you build in class. </li> </ol>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#users-and-permissions","title":"Users and Permissions","text":"<p>Unix systems have three different ways to allocate permissions: owner (a user), group, and everyone else. The owner can always assign owner permissions to another user. The root user has all permissions by default. </p> <p>There are three UNIX file permissions. Read, write, and execute. Always think of them in this order. Permissions are conventionally represented as combinations of 3 binary digits. Each digit represents one of read, write and execute. So for example, 110 is the ability to write and read and is a value of 6. (100-&gt; read-&gt; value of 4. 111 -&gt; read, write, execute -&gt; value of 7). Conventionally, you could combine these in the order owner-group-other in a string like \"644\" which would mean the owner can write/read, and the group and others can only read. <code>chmod ### path</code> can be used to set permissions for a path. Note that you can view permissions  (among other things) of files in your current directory by entering <code>ls -al</code>. See the <code>ls</code> man page for more information. </p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#processes","title":"Processes","text":"<p>A program is a packaged set of instructions, whereas a process is an instance of a program. A program can have many processes associated with it. For example, we can run multiple instances of an executable independently, thereby initiating multiple processes that run that  program. We can create more processes associated with the executable by splitting a process with the <code>fork</code> system call, as we'll soon see.</p> <p>Each process has a unique, non-negative numeric identifier known as the process ID. You can use <code>getpid()</code> to get the process ID of the current process.</p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#creating-new-processes-with-forkexec","title":"Creating New Processes with fork/exec","text":"<p>We can create new processes using the <code>fork</code> system call from an existing process. <code>fork()</code> creates a new process by duplicating the current process, and each process executes from the point of the <code>fork()</code> call. Fork duplicates the entire virtual address space when creating the new process. This means it duplicates the stack, the heap, the tasks, etc. The caller of fork is known as  the parent process and the process getting created is known as the child process. <code>fork()</code> returns 0 in the child process, and the process ID of the new (child) process in the parent process. One of the most common uses of forking--which is what you'll be using forking for in lab 5--is to run other programs via an existing process. That is, you'll have a running process that will fork itself and, while the parent continues executing the original program instructions, the child will transform into another process. How do we transform the child?</p> <p>You can use the <code>exec()</code> family of functions to turn your current process into an instance of another program. The new program is specified in the arguments to the <code>exec()</code> call. Once the call to <code>exec()</code> has been made, the process running <code>exec()</code> will cease to execute the code of its original program and begin executing the code of the new program. Your process has no memory (ha-ha) of the previously  running program, i.e., its program code, data, heap, and stack are replaced with  those of the new program. If the program reaches its end, the process will exit  and will never return to the code of your old program. This means that any code  following a call to <code>exec()</code> will only be executed if the call to <code>exec()</code> fails. For lab 5, you'll be dealing with the <code>execl()</code> function. </p> <p>Fork and executing is how the entire operating system works. The kernel starts an <code>init</code> process and everything is fork/exec'ed from there.</p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#dealing-with-terminated-processes","title":"Dealing with Terminated Processes","text":"<p>So what happens when the child process terminates before the parent process? The parent is responsible for ensuring that the child process is \"reaped\", so to speak. In other words, the system resources associated with the child  process need to be released. Otherwise, the child will become a \"zombie\" process. Ah, CS humor. We can release these resources using the <code>wait()</code> family of functions. In lab 5, you'll be using <code>waitpid()</code>, which can wait for a process with a specific ID, as well as other categories of processes. Check out its man page for more info. If a parent terminates before its child, the child  becomes an \"orphaned\" process. If you're interested in orphan and zombie processes,  you can check out the optional part 2 of lab 5. </p> <p>For a fun fork/exec example, check out the <code>jsh</code> program in the  recitation-J-code directory. </p> <p>Now, let's go through Jae's shell.c program from lecture and see these system calls in action. You can find the complete code in /home/jae/cs3157-pub/sample-code/fork-exec. </p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#jaes-shellc-program","title":"Jae's shell.c Program","text":""},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#variables","title":"Variables ###","text":"<p><pre><code>    char  buf[100];\n    pid_t pid;\n    int   status;\n</code></pre> Aside from the buffer, we declare a variable <code>pid</code> of type <code>pid_t</code>. <code>pid_t</code> is a signed integer data type that represents proccess IDs. We also declare an integer variable, <code>status</code>, to store process status information. We'll see how later, during the <code>waitpid()</code> function call. </p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#system-calls","title":"System Calls ###","text":"<pre><code>  pid = fork();\n</code></pre> <p><code>fork()</code> will duplicate your current (parent) process, creating a new (child) process. Each will execute from the point of the fork. <code>fork()</code> is called once in the parent, but returns  twice: once in the parent and once in the child. The return value of <code>fork()</code>  depends on if it's executing within the child process or parent process. <code>fork()</code>  will return the process id of the child if it's executing within the parent, and  it will return 0 of it's executing within the child process. <code>fork()</code> returns -1 if it fails. This means you can  identify which process you are in simply by checking the return of <code>fork()</code>. Note that the process ID of the child process is NOT equal to 0. Also note that the order of execution of the child and parent processeses relative to each other is unpredictable (which <code>waitpid</code> can remedy).  </p> <pre><code>else if (pid == 0) {  \n            // child process\n            execl(buf, buf, (char *)0);\n            die(\"execl failed\");\n        }\n</code></pre> <p>The above block of code is only executed in the child process (where <code>pid == 0</code>). <code>execl()</code> completely replaces the child process image with the new one - an instance of the program passed through <code>buf</code>. The first argument of <code>exec()</code> family of functions is the path of the file to be executed. The second argument, by convention, is the filename of the file to be executed (hence <code>buf</code> being passed in twice). Subsequent arguments are arguments to pass into the file to be executed. The list of parameters must always be ended by <code>NULL</code> pointer cast to <code>char *</code> to show the end of the argument list. The above block calls <code>execl()</code> with just the file to be run and no arguments. Once <code>execl()</code> is called and succeeds, the process is turned into an instance of the program pointed to by <code>buf</code> - nothing beyond the <code>execl()</code> call in the original program is executed unless <code>execl()</code> fails. </p> <pre><code>else {\n            // parent process\n            if (waitpid(pid, &amp;status, 0) != pid)\n                die(\"waitpid failed\");\n        }\n</code></pre> <p>The above block of code is only executed in the parent process (where <code>p &gt; 0</code>). <code>waitpid()</code> is used to wait or check for state changes in child processes. <code>waitpid()</code> takes in three arguments. The first is a number of type <code>pid_t</code>. This can be a specific process ID of a child process, or an integer representing other categories of process. In the case above, it passes in the process ID of its child to <code>waitpid()</code>. In lab 5, you'll see a case where <code>waitpid()</code> is called with -1. The second argument is a pointer to <code>status</code>, telling <code>waitpid()</code> to save state information in that variable. State information could be signals set in the process, exits and terminations or errors. (There's an optional section at the bottom of this argument on Signals if you'd like to know more. This is also a good resource for Unix Signals.) If <code>NULL</code> is passed instead of a pointer to variable, then state information is not saved. <code>status</code> can be used with a variety of functions to inspect/get information about child process. The third argument is an option parameter. <code>0</code> tells <code>waitpid()</code> to put off returning until child process or processes have changed state or terminated. In lab5, we'll see the <code>WNOHANG</code> option that tells <code>waitpid()</code> to not wait for child processes to terminate and return immediately if children are still running. In the above block, <code>waitpid()</code> returns the process ID of the child it waited for. For different return values with different options and arguments, check out the <code>waitpid</code> man page.</p> <pre><code>printf(\"AP&gt; \");\n</code></pre> <p>The <code>printf()</code> statement above is executed only by the parent process, once the child process has terminated. Remember, the child process never gets to this point because it was replaced by a different instance, and the parent has to wait for the child before it continues through the loop. After printing, the while loop will star over, going through everything again until the parent process is terminated. </p>"},{"location":"resources/cs3157recitations/J-Fork-Exec/fork-exec/#signals-optional","title":"Signals (Optional) ###","text":"<p>Signals are an OS's way of communicating with a process outside of the I/O streams. They can be sent at any time and a process has three options upon receiving them:</p> <ol> <li>Let the default action take place</li> <li>Explicitly ignore the signal (not necessarily possible)</li> <li>Catch the signal and do something special (not necessarily possible)</li> </ol> <p>There are tons of signals and each one has a number associated with it. Ctrl-C for example is a signal, SIGINT for signal interrupt. You can use the <code>signal()</code> function to set your program up to handle these signals. <code>signal()</code> takes two arguments: the signal you want to handle, and a function pointer to a function of what to do if that signal is received. Not all signals can always be caught with this method, so it is convention to wrap the call to signal as follows:</p> <pre><code>if(signal(SIGINT, &amp;myHandler) == SIG_ERR) {\n  perror(\"call to signal() failed\");\n  exit(1);\n}\n</code></pre> <p>In this way, if the call to signal is not accepted by the operating system you will be aware and can respond appropriately. In this case we simply exit the program with an error code but this might not be the best behavior. Note that to use these constants and functions you must <code>#include &lt;signal.h&gt;</code>. Also be aware that you can only catch the first reception of the signal. The call to signal will set the action to be taken to \"myHandler\" but afterwards it will be reset to the default action for that signal. Page 255 in the K&amp;R has a little bit more information on this.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/","title":"File io","text":""},{"location":"resources/cs3157recitations/K-File-IO/file-io/#file-io","title":"File I/O","text":""},{"location":"resources/cs3157recitations/K-File-IO/file-io/#3-channels","title":"3 channels","text":"<p>By convention, every C program is given 3 channels for input/output operations, often called I/O. I/O refers to anything that involves data coming into the  program from outside (such as getting user input with <code>scanf</code>) and writing data  to the outside (such as printing data to the console with <code>printf</code>). </p> <p>The 3 basic channels (often called \"streams\") as well as their corresponding integer representations are: - (0) stdin (standard input)   This stream is for incoming data, which often comes from the keyboard but can    also be from other sources. - (1) stdout (standard output)   This stream is for outgoing data, and normally goes to the terminal   screen but does not necessarily have to. (see below) This stream is buffered   which means it is not sent to the terminal until a new line character is sent.   This means if you use <code>printf(\"hello\")</code> you likely will not see it until the   end of your program is reached. - (2) stderr (standard error)   This stream is for error messages and is not buffered, meaning any characters   written to it will immediately be flushed to their destination. This   destination is often the terminal screen, but can be other locations as   well.</p> <p>If you wish to interact with these buffers you will need to <code>#include &lt;stdio.h&gt;</code>. This library defines standard functions such as <code>printf()</code> <code>scanf()</code> and others  which you may or may not have already used.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#redirecting-io","title":"Redirecting I/O","text":"<p>Lots of input and output to/from programs is visible in the shell (your terminal  screen). That being said, it's possible to redirect the source of stdin or the  destination of stderr and stdout. </p> <p>There are several kinds of redirection possible from the console: - <code>&gt;</code> redirects the standard output of the left argument to the right argument.   For example <code>echo \"hello world\" &gt; hi.txt</code> will write the words 'hello world'   to a file called <code>hi.txt</code>. - <code>2&gt;</code> is similar, except that it takes the standard error and redirects it,   rather than the standard output. - <code>&lt;</code> does 'input redirection', meaning that the contents of the file on the    right of the operator serves as the standard input of the left argument. For    example, after running the example above, <code>cat &lt; hi.txt</code> will print \"hello   world\" to the console.  - <code>2&gt;&amp;1</code> will redirect stderr to the same location as stdout.   - <code>&gt;&gt;</code> will append the output to a file instead of overwriting the file. </p> <p>Here are some examples to try out from your UNIX console: <pre><code>     [1] $ cat myfile.c \n     [2] $ cat &lt; myfile.c \n     [3] $ cat myfile.c &gt; cat\n     [4] $ cat myfile.c &gt; myfilecopy.c\n     [5] $ cat myfile.c &gt;&gt; myfilecopy.c\n     [6] $ valgrind ./myprogram 2&gt; myerrors\n     [7] $ valgrind ./myprogram &gt; myoutput\n     [8] $ valgrind ./anotherprogram 2&gt;&gt; myerrors\n     [9] $ valgrind ./anotherprogram &gt;&gt; myoutput\n    [10] $ valgrind ./myprogram &gt; ALLthethings 2&gt;&amp;1\n    [11] $ valgrind ./anotherprogram &gt;&gt; ALLthethings 2&gt;&amp;1\n</code></pre></p> <p>Each of the above expressions build on each other. If you can tell what the effect of each expression above is, then you're set. If not, try them out and see what happens.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#formatting","title":"Formatting","text":"<p>printf and scanf both use format strings to specify what how to format their output. They also both accept variable arguments. All arguments to scanf must be pointers whereas arguments to printf should be values (in the case of numbers) or <code>char *</code> in the case of strings. Pages 153-154 in the K&amp;R explain how to format your format strings for <code>printf()</code> and 157-158 explain formatting for <code>scanf()</code>. Make sure you can identify the following two format strings:</p> <pre><code>printf(\"%-15.10s\", \"hello, world\");\nsscanf(\"25 Dec 1988\", \"%d %s %d\", &amp;day, month, &amp;year);\n</code></pre>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#optional-topic-functions-with-variable-arguments","title":"Optional Topic: Functions with Variable Arguments","text":"<p><code>printf()</code> and <code>scanf()</code> family of functions accept a variable number of arguments. You can do this too! Once you've enumerated all the required arguments, you can specify that you would like to also accept variable arguments with <code>...</code>:</p> <pre><code>int myFWithVarArgs(int a, int b, ...);\n</code></pre> <p>The declaration means that the number and types of all arguments after the integer b can vary. If you want to be able to actually access these arguments you'll need to <code>#include &lt;stdarg.h&gt;</code> whose implementation is system dependent, but interface is the same. To access the values, you will have to do the following:</p> <ol> <li>Declare a variable of type <code>va_list</code> that will point to each argument. <pre><code>va_list my_arg;\n</code></pre></li> <li>Call <code>va_start()</code> with the last named argument, and your variable that will      point to each argument. <pre><code>va_start(my_arg, b);\n</code></pre></li> <li>Call <code>va_arg()</code> with the variable that will point to the argument as well      as the type of the argument (you'll need some way to figure out the type of      this argument from your other arguments). Assign the return value to a      variable. Repeat this step for each argument you want to read. <pre><code>int myvarInt = va_arg(my_arg, int);\n</code></pre></li> <li>Clean up by calling <code>va_end()</code> with the variable list of args variable. <pre><code>va_end(my_arg);\n</code></pre></li> </ol>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#size_t","title":"size_t","text":"<p><code>size_t</code> shows up all over the place in memory operations. <code>malloc</code> expects its parameters to be of this form, and certain file operation functions will return the number of bytes read in this formed. What you need to know about <code>size_t</code> is that it's an unsigned integer type. This means it works like an integer but cannot represent negative values. So, while the following is okay:</p> <pre><code>size_t x = 5;\nsize_t y = 3;\nsize_t z = x + y;\n</code></pre> <p>The following is not (and wouldn't be a good idea even if the value was positive):</p> <pre><code>size_t x = 5;\nsize_t y = 3;\nsize_t z = y - x;\n</code></pre> <p>Other than that you can treat <code>size_t</code> as any other integer type.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#file-io_1","title":"File I/O","text":"<p>When writing your C programs, you will often be interacting with files in various forms.  The standard library provides a simplified interface for interacting with those files through the <code>stdio</code> header and the FILE pointer.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#file","title":"FILE *","text":"<p><code>FILE</code> is a typedef'ed structure in <code>stdio.h</code>. Whenever you use it, you'll use a <code>FILE *</code> though because you'll always be getting a value back from/passing it to common file operating functions. Why a pointer? Because these functions will modify the internal values of the <code>FILE</code> value. So while you could copy them because it's a struct and C would be fine with passing it by value, things like your place in the file would not be maintained.  A <code>FILE *</code> is given as an opaque type, meaning you should never be accessing it's internals directly.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#file-descriptors","title":"File Descriptors","text":"<p>Among other things, a FILE wraps a file descriptor, an integer used by the operating system to keep track of open files.  As you'll see below, a FILE provides a nicer interface than a file descriptor for interacting with files. You can use function like <code>fopen</code> and <code>fclose</code> instead of the more low-level <code>open</code> and <code>close</code>.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#fopen-and-fclose","title":"fopen and fclose","text":"<p><code>fopen()</code> is how you'll open files. It takes two arguments, both strings. The first is a string representing the path to the file you want to open, and the second is the mode with which you will open it. The mode tells whether or not you are going to be reading, writing, or appending to the file and also how you want to read the file in. The list of different modes and their uses are listed below. If <code>fopen()</code> fails it will return a NULL pointer. This can happen because a file doesn't exist (in the case of r's) or because you don't have permissions to access the file. If you fopen a non-existent file with the 'a' or 'w' option, the file will, however, be created. <code>fclose()</code> will close the file when you're done.</p> <pre><code>FILE *fopen(char *name, char *mode);\nint fclose(FILE *fp);\n</code></pre> <p>The above structure should look a tiny bit familiar. Knowing what we know about <code>FILE *</code>s you might see the likeness here to:</p> <pre><code>void *malloc(size_t size);\nint free(void *p);\n</code></pre> <p>That's because fopen and fclose create a new <code>FILE</code> structure on the heap so that the status of the open file can be maintained. This means that if you don't <code>fclose</code> your <code>FILE *</code>s, you'll have memory leaks. Be careful about this.</p> <p>Modes * <code>\"r\"</code> read only (file must already exist)  * <code>\"w\"</code> write only. Creates new text file and discards previous contents if file already exists * <code>\"a\"</code> append only; opens text file or creates file, all writes go to end of the file * <code>\"r+\"</code> read and write. Opens file for update (file must already exist) * <code>\"w+\"</code> read and write. Creates new text file and discards previous contents if file already exists * <code>\"a+\"</code> append; can read and append. Adds to end in the same behavior as <code>\"a\"</code> regardless of file position * <code>\"rb\"</code>, <code>\"wb\"</code>, <code>\"ab\"</code>, <code>\"rb+\"</code>, <code>\"wb+\"</code>, <code>\"ab+\"</code>  indicates binary file. If using Windows OS, these modes suppresse the Windows addition of <code>\"\\r\"</code> to <code>\"\\n\"</code>. The order of \"b\" and \"+\" does not matter (i.e.<code>\"rb+\"</code> and <code>\"r+b\"</code> are equivalent).</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#fgets-and-fputs","title":"fgets and fputs","text":"<p>THESE FUNCTIONS ARE FOR LINE INPUT AND LINE OUTPUT</p> <p>What's that you ask? It means they're really good at reading in strings, but bad for everything else. Only use these functions if lines are a logical way to delimit chunks of the file you're reading.</p> <pre><code>char *fgets(char *line, int maxline, FILE *fp);\nint fputs(char *line, FILE *fp);\n</code></pre> <p><code>fgets</code> reads the next line from the input file in <code>fp</code> into the memory location pointed to by <code>line</code>. If all is successful, it reads at most <code>maxline-1</code> characters out of the file, and returns <code>line</code> as well. If something goes wrong (on end of file, or error) it returns <code>NULL</code>. It will keep the newline character it reads if it gets to one before it reaches <code>maxline-1</code> characters. It also ALWAYS appends the null character to the end of the string. <code>fgets</code> will advance the file position after each read by the space read into <code>line</code>.</p> <p><code>fputs</code> returns EOF if there's an error and 0 otherwise. This will not append a newline to the file, nor does your string need to contain a newline character.</p> <p>Watch out! <code>gets</code> and <code>puts</code> work very similarly for <code>stdin</code> and <code>stdout</code> but <code>gets</code> will not give you the newline character.  But you shouldn't have to worry about that because you should NEVER use <code>gets</code>.  It does not perform any bounds checking on the input, so you're just asking for memory errors.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#fread-and-fwrite","title":"fread and fwrite","text":"<pre><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n</code></pre> <p>Each of these functions accept pointers of type <code>void</code>. So if you want each item to be read into the right size memory space, you'll need to tell it the <code>size</code> of each item, and the number of items <code>nmemb</code> to read/write from/to the <code>stream</code>. <code>fwrite</code> promises not to modify the data that <code>ptr</code> references as well. These return the number of items succesfully read/written. If it's anything less than what you expected, you should check what happened using <code>ferror</code> or <code>feof</code>. <code>fread</code> and <code>fwrite</code> advances the position of the file to the end of the space read or written. </p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#fseek","title":"fseek","text":"<pre><code>int fseek(FILE *stream, long offset, int origin);\n</code></pre> <p>This handy dandy function lets you hop through a file without doing anything other than changing the position in the <code>FILE</code> structure. You can use any <code>stream</code> of your choosing, but pay attention to whether or not it's a binary stream. If it's a binary stream, <code>offset</code> can be any number of bytes/characters from <code>origin</code> which should be set to either <code>SEEK_SET</code> (a constant representing the beginning of the file), <code>SEEK_CUR</code> (a constant representing the current position), or <code>SEEK_END</code> (the end of the file).</p> <p>If you're reading a text stream, <code>offset</code> must either be zero or the current position as returned by a call to <code>ftell</code> (see below). In this case, always set origin to <code>SEEK_SET</code>.</p> <pre><code>FILE *text = fopen(\"myfile\", \"r\");\nFILE *binary = fopen(\"myfile\", \"rb\");\n\nfseek(text, ftell(text), SEEK_SET);\nfseek(binary, -100, SEEK_END);\n</code></pre>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#feof-and-ferror","title":"feof and ferror","text":"<pre><code>int feof(FILE *stream);\nint ferror(FILE *stream);\n</code></pre> <p>So you didn't get what you were expecting from one of the above functions. What do you do? You call <code>feof</code> or <code>ferror</code>. These two functions let you know what happened. <code>feof</code> returns true if the end of the <code>stream</code> has been reached, and <code>ferror</code> returns true if there was an error reading the <code>stream</code>.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#fprintf-and-fscanf","title":"fprintf and fscanf","text":"<p>These functions work just like their counterparts <code>printf</code> and <code>scanf</code>, respectively, except you specify which FILE to write to, rather than defaulting to <code>stdout</code> and <code>stdin</code>, respectively.</p>"},{"location":"resources/cs3157recitations/K-File-IO/file-io/#whats-buffering","title":"What's Buffering?","text":"<p>Buffering determines how often the contents of a stream are sent to their destination. There's some low level stuff going on at this point, but just understand that its not very efficient to send data one character at a time, so buffering happens. Unbuffered streams are constantly flushed to their destination. Line-buffered streams are only flushed to its destination after a newline character is written. Block-buffered streams are flushed when they reach a certain size. You can use <code>fflush(fp)</code> to manually flush the buffer for any file pointer.</p> <ul> <li>stderr is unbuffered (why?)</li> <li>stdout is line-buffered when it's connected to terminal</li> <li>everything else is block-buffered</li> </ul>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/","title":"File I/O Practice","text":"<p><code>fread()</code> / <code>fwrite()</code> and <code>fgets()</code> / <code>fputs()</code> have many subtleties to be aware of!</p> <p>In general,  - <code>fread()</code> / <code>fwrite()</code> is used to read/write arbitrary  amounts of data (for instance, binary files).  For example, this can be used to fill a buffer from a network socket, or write mdbRec structs to a database file. - <code>fgets()</code> / <code>fputs()</code> to read/write a single line of text (for instance, text files).  For example, this can be used to read a single line of input from stdin.</p> <p>However, there are still a few details that are not expressed in the above two generalizations. Let's go through them together!</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#test-1","title":"Test 1","text":"<p><code>man fgets</code></p> <p><code>char *fgets(char *s, int size, FILE *stream);</code></p> <pre><code>DESCRIPTION\nfgets() reads in at most one less than size characters from stream and \nstores them into the buffer pointed to by s.\n    Reading stops after an EOF or a newline. \n    If a newline is read, it is stored into the  buffer. \n    A terminating  null byte ('\\0') is stored after the last character in the buffer.\n\nRETURN VALUE\ngets() and fgets() return s on success, and NULL on error or \nwhen end of file occurs while no characters have been read.\n</code></pre> <p>Why does <code>fgets()</code> read in at most one less than size of characters from <code>stream</code>? This is to provide space for <code>'\\0'</code> that is always stored after the last character in the buffer.</p> <p><code>man fputs</code></p> <p><code>int fputs(const char *s, FILE *stream);</code></p> <pre><code>DESCRIPTION\nfputs() writes the string s to stream, without its terminating null byte ('\\0').\n\nRETURN VALUE\nputs() and fputs() return a nonnegative number on success, or EOF on error.\n</code></pre> <p>Note that <code>fputs()</code> does not append a <code>'\\n'</code> or <code>'\\0'</code>.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#lets-test-it-out","title":"Let's test it out!","text":"<p>Now that we know all about <code>fgets()</code> / <code>fputs()</code>, let's test it out!</p> <p>In our <code>test</code> file, we have:</p> <p><code>hello\\nhello\\n</code></p> <p>Note that there aren't <code>'\\0'</code> being written to <code>test</code>. (Why is this? hint: review <code>fputs()</code>)</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-1","title":"Case 1","text":"<p>File currently contains <code>hello\\nhello\\n</code></p> <p><code>fgets(buffer, 100, fp);</code></p> <p>Test: Reading stops after an EOF or a newline. If a newline is read, it is stored into the  buffer. A terminating  null byte ('\\0') is stored after the last character in the buffer.</p> <p>Buffer before:     <code>\\0</code></p> <p>Buffer now contains:     <code>hello\\n\\0</code></p> <p>Verify this by opening the <code>test1_case1</code> file</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-2","title":"Case 2","text":"<p>File currently contains <code>hello\\nhello\\n</code></p> <p><code>fgets(buffer, 3, fp);</code></p> <p>Test: Reads in at most one less than size characters from stream and stores them into the buffer pointed to by s. A terminating  null byte ('\\0') is stored after the last character in the buffer.</p> <p>Buffer now contains:     <code>he\\0lo\\n\\0</code></p> <p>Why are there extra characters? Because we never cleared the buffer!</p> <p>Verify this by opening the <code>test1_case2</code> file</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#test-2","title":"Test 2","text":"<p><code>man fread</code></p> <p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code> <code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></p> <pre><code>DESCRIPTION\nThe function fread() reads nmemb elements of data, each size bytes long, from the stream pointed to by stream, \nstoring them at the location given by ptr.\n\nThe function fwrite() writes nmemb elements of data, each size bytes long, to the stream pointed to by stream, \nobtaining them from the location given by ptr.\n\nRETURN VALUE\nfread() and fwrite()  return the number of items successfully read \nor written (i.e., not the number of characters).\n\nIf an error occurs, or the end-of-file is reached, the return value is a short item count (or zero).\n\nfread() does not distinguish between end-of-file and error, and callers must use feof(3) and ferror(3) to \ndetermine which occurred.\n</code></pre> <p><code>fread()</code> / <code>fwrite()</code> don't care about the contents of the file.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#lets-test-it-out_1","title":"Let's test it out!","text":"<p>Now that we know all about <code>fgets()</code> / <code>fputs()</code>, let's test it out!</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-1_1","title":"Case 1","text":"<p>File currently contains <code>hello\\n\\0\\0world</code></p> <p><code>fread_val = fread(buffer, strlen(s1) + 1, 1, fp);</code></p> <p>Test: Read 1 element of 7 bytes.</p> <p>Buffer before:     <code>\\0</code></p> <p>Buffer now contains:     <code>hello\\n\\0</code></p> <p>Verify this by opening the <code>test2_case1</code> file.</p> <p><code>fread_val = 1</code> because we successfully read 1 element. <code>feof(fp))</code> is 0.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-2_1","title":"Case 2","text":"<p>File currently contains <code>hello\\n\\0\\0world</code></p> <p><code>fread_val = fread(buffer, 100, 1, fp);</code></p> <p>Test: Read 1 element of 100 bytes.</p> <p>Buffer before:     <code>\\0</code></p> <p>Buffer now contains:     <code>hello\\n\\0\\0world</code></p> <p>Verify this by opening the <code>test2_case2</code> file.</p> <p><code>fread_val = 0</code> because we reached EOF. <code>feof(fp))</code> is 1.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#test-3","title":"Test 3","text":"<p><code>fread()</code> vs. <code>fgets()</code>, <code>fwrite()</code> vs. <code>fputs()</code></p> <p>Recall Lab 4, and think about which function we used for <code>loadmdb()</code> vs <code>mdb-lookup.c</code>.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-1_2","title":"Case 1","text":"<p>File currently contains <code>world\\0\\0\\0\\0\\0hello\\n</code></p> <p><code>fread(buffer, 15, 1, fp);</code></p> <p>Test: Read 1 element of 15 bytes.</p> <p>Buffer before:     <code>\\0</code></p> <p>Buffer now contains:     <code>world\\0\\0\\0\\0\\0hello\\n</code></p> <p>Verify this by opening the <code>test3_fwrite</code> file.</p> <p>Why does <code>'world'</code> get printed out to <code>stdout</code>? What happened to the rest of the buffer? Think about what <code>printf(\"%s\", buffer);</code> does for formatting.</p>"},{"location":"resources/cs3157recitations/K-File-IO/code/practice/#case-2_2","title":"Case 2","text":"<p>File currently contains <code>hello\\n\\0\\0world</code></p> <p><code>fputs(buffer, fp2);</code></p> <p>Test: Writes <code>buffer</code> to <code>fp2</code> up to but not including <code>'\\0'</code></p> <p>Buffer contains:     <code>world\\0\\0\\0\\0\\0hello\\n</code></p> <p>What will get written to the output file?</p> <p>Verify this by opening the <code>test3_fputs</code> file.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/","title":"Ipc tcpip","text":""},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#interprocess-communication-pipes-fifos-and-sockets","title":"Interprocess Communication: pipes, FIFOs, and sockets","text":"<p>How do processes running on the same system talk to each other? What about processes on different systems?</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#pipes","title":"Pipes","text":"<p>Sometimes, we want two or more processes to be able to communicate with each  other. The most commonly used means of interprocess communication are pipes. Pipes allow one-way data flow and can connect processes having a common  ancestor. We can use a pipe to connect the stdout of one process to the stdin of another. For example, we can \"pipe\" the output of <code>program1</code> to <code>program2</code> like this:</p> <pre><code>./program1 | ./program2\n</code></pre> <p>Notice that data flows left to right. The idea is that this should feels intuitive, since we read left to right. Also, recall that this is different from redirection with the <code>&lt;</code> and <code>&gt;</code> characters. Redirection passes output to a file or a stream, while a pipe passes output between running processes. (A discussion on the motivation behind this distinction is available here.)</p> <p>The way pipes are implemented is operating system-dependent, but in general, the processes that make up a pipeline are started at the same time. The operating system then handles connecting streams and giving processes large buffers to avoid data loss.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#named-pipe-aka-fifo","title":"Named Pipe (a.k.a. FIFO)","text":"<p>A named pipe or FIFO (First In First Out)is a type of file used for interprocess communication. We can refer to FIFOs by name after they are created using the <code>mkfifo</code> command.</p> <p>Since <code>mkfifo</code> produces a file, we send output to FIFOs using the <code>&gt;</code> and <code>&lt;</code> characters, rather than the <code>|</code> character used above.</p> <p>This example from Advanced Programming in the Unix Environment by W. Richard Stevens and Steven A. Rago illustrates how a script uses a FIFO called  <code>myfifo</code> to execute a complex operation involving redirecting input and output to and from the named pipe:</p> <pre><code>mkfifo myfifo\n./program3 &lt; myfifo &amp;\n./program1 &lt; input.txt | tee myfifo | ./program2\n</code></pre> <p>Note that we need to run <code>./program3 &lt; myfifo</code> in the background (using <code>&amp;</code>)  because opening a FIFO for reading normally blocks until another process opens the FIFO for writing and vice versa. <code>input.txt</code> is passed as input to <code>program1</code>, and <code>program1</code>'s output is piped to the <code>tee</code> command. The <code>tee</code> command transmits its stdin both to stdout and to the file(s) specified in the argument, in this case, <code>myfifo</code>. Since we pass <code>myfifo</code> as an input to <code>program3</code>, <code>program3</code>  is able to receive <code>program1</code>'s output. The stdout of <code>tee</code> is piped to <code>program2</code>,  allowing <code>program2</code> to receive <code>program1</code>'s output as well. Nifty!</p> <p>If you'd like to run this example, programs 1, 2, 3, and <code>input.txt</code> can be found in the recitation-L-code directory.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#sockets","title":"Sockets","text":"<p>Pipes and FIFOs are fine for local, one-way data flow, but oftentimes we want our interprocess communication to be even more flexible. That's when we can use sockets.</p> <p>A socket is a more general form of a pipe that can do two additional important things:</p> <ol> <li>Sockets can communicate across a network, meaning that they can connect two machines (e.g. your laptop with a server hosting <code>facebook.com</code>).</li> <li>Sockets allow for two-way interprocess communication, unlike pipes.</li> </ol> <p>We'll be discussing sockets in conjunction with the TCP/IP protocol: the standard for communication over the Internet. You'll use sockets in labs 6 and 7, but we won't go over example code here.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#tcpip","title":"TCP/IP","text":"<p>TCP/IP is the protocol that makes the world go 'round. The Internet is powered by IP, and almost all the traffic is TCP (some is UDP, mostly games and video/voice calls where a small amount of data loss is acceptable).</p> <p>TCP/IP is another name for the Internet protocol suite, which describes the protocols used to make the Internet and other networks function.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#how-does-tcpip-make-the-internet-happen","title":"How does TCP/IP make the Internet happen?","text":"<p>There are four protocol layers of TCP/IP, where each successive layer is a higher level of abstraction:</p> <ol> <li>Application (highest level of abstraction)</li> <li>Transport, TCP (and UDP)</li> <li>Internet, IP</li> <li>Link (we won't talk about this one much)</li> </ol> <p>Here is a quick pass over the 4 layers: at the bottom are simply bits on physical wires aggregated into frames, in the physical and data layer. Above that, IP deals with packets and routing packets to the correct IP address. Above that, TCP and UDP use IP packets to manage sending meaningful amounts of data, for example connecting to a specific port on a server. Finally on top of TCP you use specific protocols like HTTP, FTP, IMAP, DNS, and SSH. </p> <p>The IP protocol handles finding where on the planet a machine with a particular IP address is. The TCP protocol handles finding which process on that machine to go to, once IP has brought it to the correct location.</p> <p>If it helps, you can consider  Beej's analogy:  an IP address is like a hotel address and a port number is like a room number in  that hotel. Port numbers range from 0 to 65535, but we can only use ports 1024  and above.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#but-why-dont-i-ever-use-ip-addresses-on-the-internet","title":"But why don't I ever use IP addresses on the Internet?","text":"<p>Good catch. We just said that IP sends packets toward IP addresses. But instead of typing <code>160.39.63.50</code>, you use a hostname, like <code>clac.cs.columbia.edu</code> or <code>google.com</code>.</p> <p>DNS, Domain Name Service, is a protocol and server setup that translates hostnames into IP addresses. Every time your laptop joins a network, it gets its own IP address, the IP address of 1-3 DNS servers, and the IP address of a router that can forward packets on to the rest of the world. Your laptop translates hostnames to IP addresses by talking to the DNS servers, and communicates with the Internet by speaking to the forwarding router.</p> <p>Want to find out your IP address and DNS info? From a Linux or OS X machine, run <code>ifconfig</code> in a terminal (on Windows, use <code>ipconfig</code>). You should see something like this:</p> <pre><code>en1: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500\n    ether 58:b0:35:7d:33:7e\n    inet 192.168.1.183 netmask 0xffffff00 broadcast 192.168.1.255\n    media: autoselect\n    status: active\n</code></pre> <p>In this case <code>192.168.1.183</code> is my IP address on the <code>en1</code> network interface.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#and-why-dont-i-ever-use-port-numbers-on-the-internet","title":"And why don't I ever use port numbers on the Internet?","text":"<p>As for port numbers on the Internet, the Internet's application protocol, HTTP, specifies that we should use port 80. For HTTPS, we use port 443. Since these ports are established by convention, we can omit them when we navigate to a webpage.</p>"},{"location":"resources/cs3157recitations/L-IPC-TCP-IP/ipc-tcpip/#how-do-sockets-relate-to-the-tcpip-stack","title":"How do sockets relate to the TCP/IP stack?","text":"<p>The sockets API sits between the transport and application layers. All the code we write in this class sits at the application layer. Your browser and netcat also sit at the application layer. How the IP and TCP protocols work is outside the scope of this class.</p> <p>We'll go more in depth about the sockets API later on, but our journey into  network programming will begin with the <code>netcat</code> tool, which deals with all the  socket connection stuff under the hood. To quote the man page description: \"The  nc (or netcat) utility is used for just about anything under the sun involving  TCP or UDP.  It can open TCP connections, send UDP packets, listen on arbitrary  TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6.\" One of  the many uses for netcat is building a basic client/server model. The server will  listen on a particular port number, passively waiting. The client will connect to  the host on which the server is running, using that host's IP address, on the  port on which the server is listening.</p> <p>We can achieve this using the following shell commands:</p> <p>Server:</p> <p><code>nc -l &lt;port&gt;</code></p> <p>Client:</p> <p><code>nc &lt;hostname or IP address&gt; &lt;port&gt;</code></p> <p>Note that <code>&lt;port&gt;</code> and <code>&lt;hostname or IP address&gt;</code> need to be replaced with the appropriate values.</p> <p>In this example, <code>netcat</code> takes whatever it receives from stdin and sends it out to whomever is connected to it. It also reads whatever it gets from whomever is connected to it and outputs it to stdout. So, effectively, the <code>stdin</code> of the  client is sent to the <code>stdout</code> of the server, and the stdin of the server is sent to the stdout of the client. </p> <p>Now that we've learned about <code>netcat</code> and FIFOs, we have all the tools we need to turn <code>mdb-lookup-cs3157</code> into a network server. Yippee!</p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/","title":"Cpp","text":""},{"location":"resources/cs3157recitations/M-cpp/cpp/#introducing-c","title":"Introducing C++","text":""},{"location":"resources/cs3157recitations/M-cpp/cpp/#strings-in-c","title":"Strings in C","text":"<p>At this point, you're all quite familiar with C's quirks and kinks. Perhaps one of the most notable ones is the absence of a String datatype!</p> <p>Recall that strings in C are just special cases of arrays. C strings are arrays of characters with a null terminating character at the end. </p> <p><pre><code>char buf[50]; //stack allocation\nstrcpy(buf, \"hello\");\n\nchar *s = (char *) malloc(50); //heap allocation\nstrcpy(s, \"hello\");\n\n//don't forget to free s when you're done!\n</code></pre> But finally, after months of dealing with those pesky invalid reads, memory leaks, and so on, we can transition into a new language that permits a much friendlier way to handle strings: C++!</p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#classesstructs-in-c","title":"Classes/Structs in C++","text":"<p>Before we go into strings in C++, let's talk about the basics of <code>class</code>es and <code>struct</code>s first. Although we can define a <code>struct</code> in C++ the same way we do in C, <code>structs</code> tend to get much more complicated in C++ than their C predecessors. But let's start with the C++ version of the <code>struct Pt</code> example from Jae's lecture notes:</p> <pre><code>struct Pt \n{\n    double x;\n    double y;\n}\n</code></pre>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#stack-allocation-in-c","title":"Stack Allocation in C++","text":"<p>Here's how you allocate space for a struct Pt in C++:</p> <p><pre><code>struct Pt myPt;\n\n//in C++, you can omit the 'struct' part:\nPt myPt2;\n</code></pre> It looks exactly like how we allocated it in C! Boooring. But is it really doing the same thing?</p> <p>Classes/structs in C++ have constructors whose purpose is to initialize all data members and base classes. When we declared our <code>struct Pt</code>, <code>myPt</code>, the default <code>Pt</code> constructor was called under the covers. If we don't define any constructors for a class/struct, the C++ compiler implicitly defines a default constructor for us. The synthesized default constructor will call the default constructors of all members of class type and leave members of built-in type undefined. </p> <p>What if we attempted to call the default constructor like this?</p> <pre><code>Pt myPt3();\n</code></pre> <p>Oftentimes, the synthesized default constructor is not what we want, so we define our own constructors. Let's say we want the user to be able to specify values for <code>Pt</code> members <code>x</code> and <code>y</code>. We could do so as follows:</p> <p><pre><code>struct Pt\n{\n    double x;\n    double y;\n\n    Pt(double myX, double myY);\n};\n\n//we could have also made this inline\nPt::Pt(double myX, double myY)\n{\n    x = myX;\n    y = myY;\n}\n</code></pre> And we can call it like this:</p> <pre><code>Pt myPt2(4, 4);\n</code></pre> <p>When we define member functions for our classes, we can choose to define them within the class definition (the part enclosed by the curly braces of <code>struct Pt</code>), or just declare them within the class definition and define them elsewhere. Member functions defined within a class definition are implicitly inline. Inline functions are kind of like macros in that calls to them are replaced with the body of the function. Inline functions should be short.  Note that functions declared <code>inline</code> are not guaranteed to be inlined; it is only a suggestion to the compiler!  If we don't define functions inside the class definition, we need to use the scope resolution operator, <code>::</code>, to indicate that it's a member of the class. </p> <p>A word of caution, though: if we define any constructors ourselves, we can no longer rely on the synthesized default constructor. Now that we've defined a constructor for <code>Pt</code> that takes two <code>double</code>s, we lose our synthesized default constructor. A declaration like this would be illegal now: <pre><code>struct Pt myPt; //error!\n</code></pre> So if we want our class to have a default constructor, we'd better make sure to define it along with our other constructors, lest the compiler complain.</p> <p>A convenient way to account for two constructors in one definition is to use default arguments. If no arguments are supplied to the constructor (as is what occurs when we call the default constructor), default values are assigned to the arguments, as if we had passed these values ourselves:</p> <pre><code>/*this constructor deals with calls to the default \nconstructor and calls to the constructor taking\ntwo doubles*/\nPt::Pt(double myX = 0, double myY = 0)\n{\n    //if no arguments are passed, myX == 0\n    //and myY == 0\n    x = myX;\n    y = myY;\n\n    //note that we'd have to update our function\n    //prototype to Pt(double myX = 0, double myY = 0);\n}\n</code></pre> <p>Hand-in-hand with constructors are destructors. The purpose of the destructor is to deallocate all data members. If our constructor allocated space on the heap for its data members, our destructor should free up that space. If we don't explicitly define a destructor, the compiler will synthesize one for us, which just calls the destructors of all class type members and does nothing for the built-in type members. A stack-allocated variable's destructor is called when the variable falls out of scope, after which the stack shrinks accordingly. </p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#heap-allocation-in-c","title":"Heap Allocation in C++","text":"<p>Although you can still use <code>malloc</code> to allocate space on the heap, using <code>malloc</code> doesn't allow you to call the constructor of a class type object. A preferred way to do heap allocation in C++ is via the <code>new</code> operator:</p> <p><pre><code>Pt *myPt = new Pt; //myPt is a pointer to sizeof(Pt) allocated bytes\nPt *myPt2 = new Pt(4, 4);\n\n//heap-allocated array of Pt's:\nPt *myPtArray = new Pt[10];\n</code></pre> The <code>new</code> operator not only allocates space for <code>myPt</code> on the heap, but it also calls <code>Pt</code>'s constructor, in this case, the default constructor. Like with <code>malloc</code>, we must remember to free up the heap space we allocated with <code>new</code>:</p> <p><pre><code>delete myPt;\ndelete myPt2;\ndelete [] myPtArray; //deleting a heap-allocated array\n</code></pre> <code>delete</code> calls the Pt destructor of myPt and frees up the heap space it was using. <code>new</code> goes hand-in-hand with <code>delete</code>, and <code>malloc</code> goes hand-in-hand with <code>free</code>. But don't try to mix the four, i.e., calling <code>new</code> and freeing the memory with <code>free</code>. </p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#classes-vs-structs","title":"classes vs. structs","text":"<p>There is a subtle, yet important difference between <code>class</code>es and <code>struct</code>s in C++. In a struct, the members defined prior to the first access specifier (e.g., <code>public</code>, <code>private</code>, etc.) are <code>public</code>. In a <code>class</code>, they are <code>private</code>. We want our members to be <code>private</code>, so we'll be writing <code>class</code>es in our labs. </p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#the-basic-4-and-jaes-mystring-class","title":"The \"Basic 4\" and Jae's MyString Class","text":"<p>There are four elements of a C++ class that you should always consider:</p> <ol> <li>Constructor</li> <li>Destructor</li> <li>Copy Constructor</li> <li>Operator=()</li> </ol>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#the-copy-constructor","title":"The Copy Constructor","text":"<p>We've already discussed constructors and destructors, but what about the other two? The copy constructor specifies how to construct a class type variable using an argument of that class type, i.e.: </p> <p><pre><code>string myString(\"hello\");\nstring myStringCopy(myString); //invoking the copy constructor explicitly\n</code></pre> The copy constructor is called implicitly in a couple other scenarios: passing by value and returning by value.</p> <pre><code>string call_copy(string myString) //copy constructor is called to create temporary copy of myString local to call_copy\n{\n    return myString; //copy constructor is called to return myString by value\n}\n</code></pre> <p>If you don't explicitly define a copy constructor, the compiler implicitly defines one for you, which just sets all data members of the newly constructed object equal to all data members of the argument object. This may or may not be what you want. Consider this segment of the <code>MyString</code> class from Jae's lecture notes:</p> <p><pre><code>class MyString\n{\n    char *data;\n    int len;\n\n    MyString(char *p);\n    ...\n\n}\n\n...\n\nMyString::MyString(char *p)\n{\n    if (p)\n    {\n        len = strlen(p);\n        data = new char[len+1];\n        strcpy(data, p);\n    }\n\n    else \n    {\n        data = new char[1];\n        data[0] = '\\0';\n        len = 0;\n    }\n\n}\n\nMyString::~MyString()\n{\n    delete[] data;\n}\n</code></pre> If we didn't define a copy constructor for <code>MyString</code>, initializing a new <code>MyString</code> from another <code>MyString</code> would make the new <code>MyString</code>'s data pointer point to the same heap-allocated space as the old <code>MyString</code>'s data pointer. Upon destruction of either <code>MyString</code>, the other <code>MyString</code> would have a data pointer pointing to a freed piece of memory: hello, memory errors!</p> <p>As a rule of thumb, if your class necessitates explicit definition of a destructor, as <code>MyString</code> does, chances are that your class necessitates explicit definition of a copy constructor. </p> <p>So how do we define a copy constructor? We know that the copy constructor is called when we try to pass an object by value, so we can't pass a <code>MyString</code> object as a parameter to our copy constructor; how can we define a copy constructor while relying on the existence of a copy constructor? We need a C++ construct known as a reference. You can think of a reference as a dereferenced pointer to something. For example:</p> <p><pre><code>int x = 5;\nint&amp; y = x; //y is a reference to x\n\nx = 6; //y is now 6\ny = 7; //x is now 7\n</code></pre> The reference construct allows us to pass an argument by reference, without the need for all that pointer business we've seen before. For example, this function will increment the integer passed as an argument, since the variable it's working with isn't a temporary copy of the argument--it's an alias for the argument itself!</p> <p><pre><code>//note that to use iostreams this way, we need to have:\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid increment(int&amp; x)\n{\n    x++;\n}\n\n...\nint y = 5;\nincrement(y);\ncout &lt;&lt; y &lt;&lt; endl; //prints 6\n</code></pre> Using this new reference construct, we are ready to define our copy constructor:</p> <pre><code>MyString::MyString(const MyString&amp; s) \n/*note that the const indicates that we will not modify\n the contents of s within this constructor*/\n{\n    len = s.len;\n\n    data = new char[len+1];\n    strcpy(data, s.data);\n}\n</code></pre> <p>Note that the copy constructor takes a constant reference (<code>const MyString&amp;</code>). It's generally better to take constant references for a couple of reasons:</p> <ol> <li>By taking <code>const</code>, you increase the range of things you can take (both <code>const</code> and not <code>const</code> arguments).</li> <li>By taking a reference, you avoid the overhead associated with making a copy of the argument, so the code will be a little faster.</li> </ol>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#the-assignment-operator","title":"The Assignment Operator","text":"<p>If your class necessitates the definition of a copy constructor, your class necessitates the definition of an assignment operator for the same reasons. We can write our assignment operator almost entirely the same way we wrote our copy constructor, except now we also have to deal with the existing data of the lvalue. We can examine the contents of the lvalue via the C++ <code>this</code> pointer. <code>this</code> is a pointer to the object on which we're currently operating.</p> <p>(You probably guessed it. In C++, the <code>this</code> pointer is the same thing as the <code>this</code> reference in Java. What you know as object references in Java are indeed none other than pointers hiding behind a more palatable syntax.)</p> <p>Now that we have <code>this</code> at our disposal, we can write our assignment operator:</p> <p><pre><code>MyString&amp; MyString::operator=(const MyString&amp; rhs)\n{\n    if (this == &amp;rhs) {\n    return *this;\n    }\n\n    // first, deallocate memory that 'this' used to hold\n\n    delete[] data;\n\n    // now copy from rhs\n\n    len = rhs.len;\n\n    data = new char[len+1];\n    strcpy(data, rhs.data);\n\n    return *this; //returns the MyString on which we are calling the assignment operator\n}\n</code></pre> Note that our assignment operator should return a <code>MyString&amp;</code> so that we can chain calls to it:</p> <p><pre><code>MyString MS(\"hello\");\nMyString MS2(\"world\");\nMyString MS3(\"yay\");\n\n(MS = MS2) = MS3; //MS is now \"yay\"\n</code></pre> Make sure you understand the importance of the Basic 4 and always consider whether they're necessary for your program. Hint: they're almost always necessary. </p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#other-nifty-c-features","title":"Other Nifty C++ Features","text":""},{"location":"resources/cs3157recitations/M-cpp/cpp/#implicit-conversions","title":"Implicit Conversions","text":"<p>Recall from your lovely memories with C that there are some automatic type conversions that occur when intermixing types, for example:</p> <p><pre><code>int y = 5;\ndouble z = y; //y is coerced into double type\n</code></pre> Automatic type conversions can occur for class type variables in C++. For our <code>MyString</code> class, we can do something like this:</p> <pre><code>MyString s(\"hello\");\ns += \"world\"; \n/*compiler uses the MyString constructor that \ntakes a char* to create a temporary MyString whose \nvalue is \"world\", which allows us to call our \n+= operator on two MyString objects*/\n\n//note that the lifetime of our temporary MyString is the expression in which it was created\n</code></pre> <p>If we want automatic type conversion to occur, we need to make sure that the compiler is able to make the connection between the first type and the other, via our constructors (i.e., we can construct a <code>MyString</code> from a <code>char*</code>, but not from an <code>int</code>.)</p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#operators","title":"Operators","text":"<p>C++ allows us to define our own operators for the classes we write. This means that we can do things like:</p> <p><pre><code>MyString MS(\"hi\");\nMyString MS2(\"dude\");\nMS = MS + MS2; //MS reads \"hidude\"\n</code></pre> You can find a list of all overloadable operators in C++ on page 553 of Lippman, 5th ed. For our <code>MyString</code> class, we'll be overloading <code>+</code>, <code>=</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>[]</code> (plus the ones you'll overload in lab 9). </p> <p>You may find yourself running into the question of member versus nonmember implementation of your operators. Symmetric operators, operators that should allow implicit conversion of either operand, should be nonmember functions. Two examples of these are the <code>+</code> and <code>-</code> operators. Operators whose left-hand operand isn't of the class type shouldn't be members of the class, for example, the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators of our <code>MyString</code> class. Operators that change the state of their object should be members. The assignment (<code>=</code>), subscript (<code>[]</code>), call (<code>()</code>), and member access arrow (<code>-&gt;</code>) operators must be members. </p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#friend-declarations","title":"Friend Declarations","text":"<p>If we want to have nonmember operators that access our non<code>public</code> data members, we need to declare them as friends, as we do in <code>mystring.h</code>. </p> <p><pre><code>    // operator+\n    friend MyString operator+(const MyString&amp; s1, const MyString&amp; s2);\n\n    // put-to operator\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const MyString&amp; s);\n\n    // get-from operator\n    friend istream&amp; operator&gt;&gt;(istream&amp; is, MyString&amp; s);\n</code></pre> Remember this joke: \"Only you and your friends can touch your private parts.\"</p>"},{"location":"resources/cs3157recitations/M-cpp/cpp/#const-member-functions","title":"Const Member Functions","text":"<p>Note that the <code>const</code> version of the subscript operator in <code>MyString</code> has <code>const</code> at the end of its prototype. What's that about? A const member function is a member function that promises not to modify the object on which the function is being called. As such, the <code>const</code> version of the <code>MyString</code> subscript operator promises to not modify the contents of the <code>MyString</code> that it's subscripting. Note that we can cast away the <code>const</code>ness of <code>*this</code> so that we can reuse our non<code>const</code> subscript operator:</p> <pre><code>// operator[] const - in real life this should be inline\n\nconst char&amp; MyString::operator[](int i) const\n{\n    // illustration of casting away constness\n    return ((MyString&amp;)*this)[i];\n}\n</code></pre>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/","title":"C++ templates and containers","text":"<p>So far, we know how to write classes in C++ from our experience with <code>MyString</code>. Since you already know about object orientation (inheritance and things like that) from previous courses, we'll talk about generics instead.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#what-is-generic-programming","title":"What is generic programming?","text":"<p>Generic programming is when a single algorithm is written to work on many data types. As programmers, we only have to write the algorithm once: the compiler takes care of generating the code for each data type, reducing the need to write duplicate code.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#void-drawbacks-of-generic-programming-in-c","title":"<code>void *</code>: Drawbacks of generic programming in C","text":"<p>In the mylist lab, we created a linked list library that could handle many data types by using <code>void *</code>. However, this approach has some problems: it doesn't provide any type safety. Type safety is the ability of a compiler to ensure that types match. For example, this means it will print an error if an <code>int</code> variable is used when a <code>std::string</code> is expected.</p> <p>Remember how we retrieved items from the linked list? We had to cast the <code>void *</code> to the type of the item we put into the list. For example, if we added a <code>double *</code>, the linked list would give us a <code>void *</code>, and we would cast it back with <code>(double *)</code>.</p> <p>If we accidentally wrote the wrong type, the program might crash or produce the wrong output. The compiler couldn't provide type safety to our linked list library because once the pointer is cast to <code>void *</code>, it loses the original type information.</p> <p>In summary, the C compiler is helpless once data is cast to <code>void *</code> \u2014 it can't catch type errors at compile time.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#using-templates-with-classes","title":"Using templates with classes","text":"<p>C++ implements generic programming using templates. Templates let us write code so that the compiler can \"fill in the blanks\" with the requested type when we use the code. So for a list library, the compiler would use the template to generate a different copy of the list code for each type we want to store in it (<code>double</code>, <code>MdbRec</code>, etc).</p> <p>Here's an example of using a templated class in C++. <code>vector</code> is an expandable array in C++, like <code>ArrayList</code> in Java or <code>list</code> in Python. (We'll see later how to write templated classes.)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvector&lt;int&gt; ivec; // This vector holds items of type int\nvector&lt;MdbRec&gt; mdbvec; // This vector holds items of type MdbRec\nvector&lt;vector&lt;MyString&gt;&gt; msvecvec; // vector holds vectors of MyString\n</code></pre> <p>The type of <code>ivec</code> is <code>vector&lt;int&gt;</code>. This not the same type as <code>mdbvec</code>, which has type <code>vector&lt;MdbRec&gt;</code>. The type of the templated object includes the types we want the compiler to fill into the template.</p> <p>Now let's see how to write a templated class. We use the <code>template</code> keyword before the class definition:</p> <pre><code>template &lt;typename T&gt; // \"T\" is the type to be \"filled in\"\nclass vector {\n  public:\n    void push_back(const T&amp; x);\n    T&amp; at(size_t index);\n\n  private:\n    T *a;\n    size_t size;\n    size_t capacity;\n    void grow();\n};\n</code></pre> <p>When we ask the compiler for a <code>vector&lt;int&gt;</code>, it \"fills in\" <code>int</code> whenever it finds <code>T</code>, and compiles the resulting class. This happens every time we use <code>vector</code> with a new type.</p> <p>If we have a <code>vector&lt;int&gt;</code>, the compiler knows that we'll always get an <code>int&amp;</code> back when we call the <code>at()</code> method. If we try to store the result into, for example, an <code>MdbRec</code>, the compiler will give us an error.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#using-templates-with-functions","title":"Using templates with functions","text":"<p>Just like with classes, we can also use templates to write generic functions. Let's say we want to write a comparison function that works for many types. We could write it out by hand:</p> <pre><code>// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller\nint compare(const string &amp;v1, const string &amp;v2)\n{\n  cout &lt;&lt; \"Now comparing: \" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \"\\n\";\n  if (v1 &lt; v2)\n    return -1;\n  if (v2 &lt; v1)\n    return 1;\n  return 0;\n} \nint compare(const double &amp;v1, const double &amp;v2)\n{\n  cout &lt;&lt; \"Now comparing: \" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \"\\n\";\n  if (v2 &lt; v1)\n    return 1;\n  if (v1 &lt; v2)\n    return -1;\n  return 0;\n}\n</code></pre> <p>These functions are identical, which is bad because we've copied and pasted code. We'd have to copy and paste a third time if we wanted to compare a new type, such as <code>int</code>. Furthermore, every time we want to change the algorithm, we would have to modify each copy, increasing the likelihood of bugs.</p> <p>Since <code>string</code>, <code>double</code>, and <code>int</code> all have <code>operator&lt;</code> defined and can all be printed with <code>cout</code>, we can condense the functions above into a template:</p> <pre><code>template &lt;typename T&gt;\nint compare(const T &amp;v1, const T &amp;v2)\n{\n  cout &lt;&lt; \"Now comparing: \" &lt;&lt; v1 &lt;&lt; \" and \" &lt;&lt; v2 &lt;&lt; \"\\n\";\n  if (v2 &lt; v1)\n    return 1;\n  if (v1 &lt; v2)\n    return -1;\n  return 0;\n}\n</code></pre>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#templates-under-the-hood","title":"Templates under the hood","text":"<p>Templates aren't like any other language feature we've seen so far, so they complicate the compilation process. But understanding this complexity enables us to write concise, high-performance programs that are impossible in many other languages.</p> <p>Read through this section if you're curious about how the C++ compiler achieves this. It may also help you debug weird template-related error messages.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#the-compilation-process-so-far","title":"The compilation process, so far","text":"<p>If you go back to the beginning of the course, we discussed compilation as the following steps:</p> <ol> <li>Preprocessing (<code>#include</code>, <code>#define</code>, other <code>#</code> directives)</li> <li>Compiling (turning .c files into .o object files)<ul> <li>Recall, we could also create a library <code>.a</code> file from our <code>.o</code> files,   if we wanted. This would be an extra step after compiling, before linking</li> </ul> </li> <li>Linking (combining multiple .o files into a single executable)</li> </ol> <p>In this compilation process, we can throw away the source code after 2, and as long as we have the .o or .a files we can link successfully. Also, the compiler does not need to see the body of a function when compiling code that calls it \u2014 it only needs the header, which tells the argument and return types of the functions.</p> <p>The same is not true of C++ templates. When we use a template, the compiler must have access to the original source code to \"fill in\" the types \u2014 it is generating entirely new classes and functions. So, we cannot put templates into .cpp files and turn them into .o files to be used later. There is no such thing as <code>vector.o</code>. Instead, we put the templates in header files, and include them wherever they are used.</p> <p>What if multiple .cpp files are using the same instantiation of a template? For example, let's say we have <code>foo.cpp</code> and <code>bar.cpp</code>, which both use <code>vector&lt;int&gt;</code>. After compiling <code>foo.o</code> and <code>bar.o</code>, we'll have one copy of <code>vector&lt;int&gt;</code> in each file. The duplicates are removed when we link <code>foo.o</code> and <code>bar.o</code> together into an executable. This is known as the Borland model. It's inefficient because the compiler duplicates work, but is simpler to implement.</p> <p>One consequence is that the C model of separating interfaces (.h files) and implementations (.c files) no longer holds in C++. According to Jae, this is one of the things in C++ that is fundamentally incompatible with C, and no matter what you do you'll end up with a kludge.</p> <p>Further reading: - GCC manual section 7.5, \"Where's the Template?\" - The end of Lippman 5th ed 16.1.1, \"Template Compilation\"</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#note-why-go-through-this-trouble-templates-are-fast","title":"Note: Why go through this trouble? Templates are fast!","text":"<p>Although templates take a long time to compile, they're incredibly fast when running. Unlike other languages' implementations of generics, there is literally no overhead during execution for a templated class, because they're just turned into the code that you would have written by hand. This is an example of a zero-overhead abstraction: templating makes programming easier, but don't make our programs slower when they run.</p> <p>There's a really cool Bayesian statistics project at Columbia run by Andrew Gelman's group called Stan. Stan runs complicated statistical models very quickly: under a second for moderate sizes, where competitors would take several minutes. One reason for the speed is extensive use of C++ templates.</p> <p>However, this comes at the cost of taking 30--60 seconds to compile models (even just a tiny tweak). Remember when we said that a new class gets generated every time you use a template with a new type? With templates, it's very easy to make the compiler generate a lot of classes with a small amount of code.</p> <p>But it's worth it: the code is tricker to write and takes longer to compile, but the end result is execution times that are as fast as hand written code, with significantly more flexibility for the end user. This lets them have end users write whatever models they want at no performance cost.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#whats-with-that-weird-double-template-stuff-for-ostream","title":"What's with that weird double template stuff for ostream?","text":"<p>Check out this discussion about overloading <code>operator&lt;&lt;</code> in a templated class. Here's what's going on:</p> <p>Sometimes you need to define function templates in association with a class template. This is a friend function that depends on the specific type of the class. If we look at Jae's stack example from lecture note 22, he declares </p> <pre><code>template &lt;typename T&gt;\nostream&amp; operator&lt;&lt;(ostream&amp; os, const Stack&lt;T&gt;&amp; rhs)\n</code></pre> <p>There's one function for each type used, ie there's a operator&lt;&lt;_for_stack_of_int, and operator&lt;&lt;_for_stack_of_strings. Those are different functions, and each needs to be created as separate function templates. However they're friends, they aren't member functions, hence they need to be declared as separate templates with respect to the class.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#containers","title":"Containers","text":"<p>The C standard library, STL, provides containers. Containers are a standard set of library classes for containing a bunch of objects of some type. They're implemented with templates, and are pretty much the canonical example of templates in the language.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#value-semantics","title":"Value Semantics","text":"<p>One key feature of containers is that they provide value semantics. That is, containers at least appear to make copies of the things you store into them, and manage the lifetime of those copies. They guarantee that even if you destruct the original, the copy it stored is safe. And once you destruct the vector, the copies it made are destructed as well.</p> <p>Understanding value semantics is key for lab 10, and helps explain why they're so handy. Something about STL containers could easily be a final question. </p> <p>Note that Jae's lecture note 22 does a good job of explaining containers and iterators.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#what-can-you-do-with-containers","title":"What can you do with containers?","text":"<p>Iterators, of course, but also: things like sorting, inserting, swapping, splicing, merging, etc, etc. You can pass them into functions that will sort, or print, or whatever you could want.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#vector","title":"Vector","text":"<p>Vector is the prototypical container in this class. It's a sequential container, supporting O(1) random access to elements, and O(1) amortized appends (<code>push_back()</code>). Under the hood it's an array with some blank spaces on the right;  whenever it runs out of blanks it creates a new (larger) array, and copies the data from the old to new. It manages that underlying array internally.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#list","title":"List","text":"<p>List is a linked list, like we did in lab 3 but fancier. In particular the list class is doubly linked, so every node points not just to next, but also to previous (i.e., the node that points to it). It also maintains a tail pointer in addition to head, so it can append in O(1) constant time.</p> <p>This means that list does NOT define <code>operator[]</code> or anything similar - it has no random access, and it must do some pretty fancy stuff in its iterator.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#deque","title":"Deque","text":"<p>Also known as deque, and pronounced \"deck\", it's a doubly ended queue: like a vector with space on both the left and the right. (Deque is actually implemented differently, but it's a good mental model.)</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#derived-containers","title":"Derived Containers","text":"<p>Based on vector, list, and deque, there are several derived containers that use one of those as the underlying container. They include queue (uses either list or deque), priority queue (using vector or deque), and stack (using any).</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#set","title":"Set","text":"<p>Sets provide very efficient lookup to see if an element is in the set, along with mathematical set operations like union, intersection, etc. They keep the elements sorted using the operator&lt; function. (Unimportant detail: internally they use some type of self balancing binary search tree.)</p> <p>There's also an unordered set (unimportant detail: that uses a hash table). </p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#pair-and-map","title":"Pair and Map","text":"<p>We discuss pair and map because it's useful to understand the flexibility and total genericness of the STL containers. Absolute understanding of how they work isn't important for 3157.</p> <p>A pair is a class that lets you group two objects together, potentially of different types. A simple implementation is just:</p> <pre><code>    template &lt;class T1, class T2&gt;\n    struct pair {\n        T1 first;\n        T2 second;\n    };\n\n    pair&lt;string,int&gt;  prez(\"obama\", 1961);\n    pair&lt;string,int&gt;  veep(\"biden\", 1942);\n</code></pre> <p>Pairs are useful because they're often a natural extension of generic containers. We want to store an int plus some value instead of just an int. Pairs provide a convenient way to do that. </p> <p>One use is in map, which maps keys to values. It will return pairs when it wants to return (key, value) tuples.</p> <pre><code>  map&lt;string,int&gt;  word_count;\n  string word;\n  while (cin &gt;&gt; word)\n      word_count[word]++;\n\n  map&lt;string,int&gt;::iterator it;\n  for (it = word_count.begin(); it != word_count.end(); ++it) {\n      cout &lt;&lt; it-&gt;first &lt;&lt; \" occurs \";          //recall that it-&gt;first is (*it).first\n      cout &lt;&lt; it-&gt;second &lt;&lt; \" times.\" &lt;&lt; endl;\n  }\n</code></pre>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#iterators","title":"Iterators","text":"<p>Iterators are the key feature that makes containers so useful as a group. Every container specifies an iterator type, providing a consistent way to access every element stored in the container. Compare the same iterator code, one written for a vector, and the other for a dequeue: </p> <pre><code>for (vector&lt;string&gt;::iterator it = v.begin(); it != v.end(); ++it)\n    *it = \"\";\n\nfor (dequeue&lt;string&gt;::iterator it = v.begin(); it != v.end(); ++it)\n    *it = \"\";\n</code></pre> <p><code>iterator</code> is a type member, which is a typedef defined inside a class.</p> <p><code>iterator</code>s act like pointers: they must provide the basics that pointers provide (some do provide other features). In particular you must be able to get the beginning, <code>v.begin()</code> and one past the end with <code>v.end()</code>. Both of these functions return <code>iterator</code>s. However it's only valid to dereference the returned value of <code>begin()</code>, because <code>end()</code> points past the end of the container.</p> <p>The iterator has to define three functions to be useful: <code>*</code>, <code>++</code> and <code>!=</code>. With only those three we can do our entire iteration with any container, even ones like trees that aren't strictly sequential.</p> <ul> <li> <p><code>operator*</code> returns a reference to the object to which the iterator is currently pointing. In a <code>vector</code> the iterator is actually a pointer, so it works without any code. In another class, say a linked list, the code has to do more work to figure out what the object being stored is, and return that.</p> </li> <li> <p><code>operator++</code> advances the iterator to the next element. Again, how it actually happens depends entirely on what the container holds.</p> </li> <li> <p><code>operator!=</code> is important, because for some container types the idea of <code>operator&lt;</code> doesn't really make sense. Hashmaps, for example, are entirely unordered, so we can only really test whether two iterators are not equal, not whether one is less than the other.</p> </li> </ul> <p>There is also a <code>const_iterator</code>, which gives you const references, and behaves exactly the same way conceptually.</p>"},{"location":"resources/cs3157recitations/N-Templates-Containers/templates-containers/#clang","title":"Clang","text":"<p>Clang is a newer alternative to gcc. It was designed primarily by Apple to be a drop in replacement to gcc, but with a license apple prefers, and to support better debugging and static analysis. Apple uses it for XCode, and it's available on CLAC as well. So if you're getting crazy error messages you don't understand, you can try changing <code>g++</code> to <code>clang++</code> in your Makefile, and seeing if you get more easily interpreted error messages.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/","title":"Smart Pointers","text":""},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#or-if-c-is-so-smart-why-do-i-have-to-remember-to-delete","title":"Or, If C++ is so smart, why do I have to remember to delete?","text":"<p>C is bare bones, so the fact that we have to manually <code>malloc</code>/<code>free</code> makes sense. But if everyone makes fun of C++ for including every language construct ever, why do I still have to call <code>delete</code>?</p> <p>Well, good news! With SmartPtr you don't have to!</p> <p>What is it?  A C++ class that behaves like a pointer. That is, it points to a chunk of memory on the heap, and can be dereferenced to get to it. It will let us pass around pointers to objects, instead of the objects themselves.</p> <p>Why?</p> <ul> <li>We want automatic life-time management of heap-allocated objects.</li> <li>We want value semantics without having to copy large objects.</li> <li>In short, we want behavior that mimics Java references!</li> </ul> <p>SmartPtr: * Is a light-weight handle for heap-allocated objects. * Manages the object life-time using reference counting. * Provides value semantics for the pointer, thus can be put into standard   containers.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#reference-counting","title":"Reference Counting","text":"<p>Reference Counting is a way to automatically manage the lifetime of heap allocated objects.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#key-behaviors","title":"Key Behaviors","text":"<p>The key behaviors that SmartPtr must provide are fairly simple: * It stores a real memory address of some type * It can be dereferenced to return that memory address when asked * When everybody is done with the object this smart pointer is pointing to, it   will be deleted.</p> <p>That last one is the key that drives the definition. </p> <p>It means that a group of smart pointers all pointing to the same object need to coordinate their efforts. </p> <p>As a result, let's think about the private data members that a SmartPtr must have. Obviously first is the underlying pointer we're wrapping - <code>T *ptr;</code>. </p> <p>But there's a second component to a SmartPtr, the current count of references to that pointer. We need to keep this in sync across our entire program. </p> <p>Note: See 24-smartptr.pdf for the actual definition. </p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#diagram-smartptr","title":"Diagram SmartPtr","text":"<p>Let's first attempt to keep track of count in the simplest way possible: an <code>int</code> inside the class.  We should examine [what happens] (/O-Smart-Pointer/code/stack.gif) when two SmartPtrs are created and then the first goes out of scope.</p> <p>As we can see, this will not properly synchronize the value and can even lead to deleting the object too soon!</p> <p>Let's [try again] (/O-Smart-Pointer/code/heap.gif) while holding a pointer to an <code>int</code> inside the class.</p> <p>It works!  We're properly keeping track of the count!  This means we can delete the object properly.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#smartptr-definition","title":"SmartPtr definition","text":"<pre><code>template &lt;class T&gt;\nclass SmartPtr {\n\n    private:\n    T *ptr;  // the underlying pointer\n\n    int *count;  // the reference count\n\n    public:\n\n    // constructor\n    //\n    // - p is assumed to point to an object created by \"new T(...)\"\n    // - we hold the pointer and initialize ref count to 1.\n    //\n    //   note: explicit keyword\n    //   note: default argument\n    //\n    explicit SmartPtr(T *p = 0) \n    {\n        ptr = p;\n        count = new int(1);\n    }\n\n    // copy constructor\n    //\n    // - copy the data members and increment the reference count \n    //\n    //   note: member initialization syntax\n    //\n    SmartPtr(const SmartPtr&lt;T&gt;&amp; sp)\n        : ptr(sp.ptr), count(sp.count)\n    {\n        ++*count;\n    }\n\n    // destructor\n    //\n    // - delete the underlying object if this was the last owner\n    //\n    ~SmartPtr()\n    {\n        if (--*count == 0) {\n        delete count;\n        delete ptr;\n        }\n    }\n\n    // assignment operator\n    //\n    // - detach this SmartPtr from the underlying object and\n    //   attach to the object that sp is pointing to.\n    //\n    SmartPtr&lt;T&gt;&amp; operator=(const SmartPtr&lt;T&gt;&amp; sp)\n    {\n        if (this != &amp;sp) {\n        // first, detach.\n        if (--*count == 0) {\n            delete count;\n            delete ptr;\n        }\n        // attach to the new object.\n        ptr = sp.ptr;\n        count = sp.count;\n        ++*count;\n        }\n        return *this;\n    }\n\n    // operator*() and operator-&gt;() make SmartPtr class behave\n    // just like a regular pointer.\n\n    T&amp; operator*() const { return *ptr; }\n\n    T* operator-&gt;() const { return ptr; }\n\n    // access to the underlying pointer for those cases when you\n    // need it.\n\n    T* getPtr() const { return ptr; }\n\n    // operator void*() makes \"if (sp) ...\" possible.\n\n    operator void*() const { return ptr; }\n\n};\n</code></pre>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#reference-cycles","title":"Reference Cycles","text":"<p>Imagine you have a doubly linked list. Each node points to the next node, but also to the previous node. You also have a List object, that points to the head and tail nodes.</p> <p>Because SmartPtrs are awesome, you use SmartPtrs for all of the above head/next.</p> <p>Unfortunately, there's a problem! When the list is destructed, it destructs its pointers to head and tail. That reduces their counts by 1. What we want to happen is that the head node is destructed, causing the node it's pointing to to be destructed.</p> <p>However, the count of references to head node doesn't become 0, because there is still a reference to it -- the next node's previous pointer. So we have an orphaned cycle. One thing is pointing to the other, which is pointing back to the first. Thus neither will go to zero, and therefore won't be destructed.</p> <p>This is called a reference cycle, which is the big problem with simple reference counting.</p> <p>shared_ptr solves this with weak_ptr. Another option is to use some sort of garbage collection very occasionally to try to identify these objects (mark and sweep being a common basic one). Regardless, it needs to be addressed.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#warnings","title":"Warnings","text":"<p>SmartPtrs can't point to objects on the stack. Think about what would happen if you tried to make that happen?</p> <p>An object managed by a SmartPtr must be managed exclusively by SmartPtr. If you mix a SmartPtr and a regular pointer, the world will end. Okay, the world won't really end, but bad things can happen - think about what might happen if  the SmartPtr <code>delete</code>s the object before the regular pointer is done with it.</p> <p>Don't forget the above discussion on Reference Cycles.</p>"},{"location":"resources/cs3157recitations/O-Smart-Pointer/smart-pointers/#shared_ptr","title":"shared_ptr","text":"<p>The C++11 standard includes a smart pointer template class (finally!) called \"shared_ptr\":</p> <ul> <li>Works basically the same way as our SmartPtr, but more powerful.</li> <li>Atomic reference counting for thread safety.</li> <li>Can attach \"weak_ptr\", which does not participate in ref counting. These are   used to break the cycles mentioned above.</li> <li>Delete operation customizable.</li> </ul>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/","title":"Unix 2","text":"<p>Now that we're a little more familiar with Unix, let's go over some things we glossed over in the first Unix recitation. We'll also learn tips and tricks to improve productivity on Unix-like computers.</p>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#shells-let-users-access-a-computers-resources","title":"Shells let users access a computer's resources","text":"<p>A shell is a program used to access files and programs on a computer. They can be graphical or text-based -- in this class, we'll only worry about text shells. Examples include <code>bash</code> (the default on CLAC), <code>zsh</code>, and Windows PowerShell. The original shell program was the Thompson shell, <code>sh</code>.</p> <p>The shell is only special in that it's automatically run when we open a new terminal window. Apart from that, it's just like any other program. In fact, in <code>isort</code> and <code>mdb-lookup</code>, we saw how easy it is to write a shell-like program that takes user input and prints out a response.</p> <p>Similarly, we can run a shell as a program by typing its name. Let's say we're using <code>bash</code> on CLAC, and want to try out <code>csh</code>:</p> <pre><code>yourUNI@vienna:~$ csh\nvienna:~% echo 'Hello World'\nHello World\nvienna:~% exit\nexit\nyourUNI@vienna:~$\n</code></pre> <p>Once we're done playing with csh, just type <code>exit</code>. This tells <code>csh</code> that we want it to exit, leaving us with <code>bash</code>, the outer shell that launched it.</p>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#the-path-variable-shows-where-to-find-programs","title":"The <code>PATH</code> variable shows where to find programs","text":"<p>Shells also allow us to set variables. The <code>PATH</code> variable is a list of colon-separated paths to directories that the shell looks inside to find programs. For example, if you wanted to be able to run your <code>twecho</code> executable from any directory on CLAC, you could put the absolute path to <code>twecho</code> in your README.</p> <p>To see our account's <code>PATH</code> variable:</p> <pre><code>yourUNI@vienna:~$ echo $PATH\n/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\n</code></pre> <p>When we type a command, our shell opens directories in the order listed until it finds a program matching what we typed. So for <code>gcc</code>, it would search for <code>/sbin/gcc</code>, <code>/usr/local/sbin/gcc</code>, <code>/usr/local/bin/gcc</code>, etc.</p> <p>With this knowledge, prepending to <code>PATH</code> is a clever way to use our own programs instead of the ones provided by the CLAC administrators -- it'll force the shell to search our directory before looking anywhere else. For example, if we keep our programs in <code>/home/yourUNI/bin</code>, adding this to the end of <code>.bashrc</code> will do the trick:</p> <pre><code>export PATH=\"/home/yourUNI/bin:$PATH\"\n</code></pre> <p>(More on how this code works at the end of this recitation.)</p>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#the-bin-directories-each-have-a-different-purpose","title":"The <code>bin</code> directories each have a different purpose","text":"<p>Programs are installed in different directories depending on their origin and importance.</p> <ul> <li>If the path begins with <code>/usr</code>, this directory is for non-essential programs.   The system can still retain basic functionality if we lose access to these.</li> <li>If the directory is called <code>sbin</code>, it holds system or administrator programs.   Directories called <code>bin</code> are meant for everyone to use.</li> <li>If the path begins with <code>/usr/local</code>, it's for programs that aren't part of   the operating system, such as programs that we wrote ourselves.</li> </ul> <p>Some examples:</p> <ul> <li><code>/bin</code> = essential, for all users (such as <code>ls</code> and <code>mv</code>)</li> <li><code>/sbin</code> = essential, for system and administrators (such as <code>fsck</code>, which   scans the filesystem for errors)</li> <li><code>/usr/bin</code> = non-essential, for all users (such as <code>gcc</code> and <code>valgrind</code>)</li> <li><code>/usr/local/bin</code> = non-essential, for all users, not part of OS (such as   MATLAB)</li> </ul>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#other-unix-filesystem-conventions","title":"Other Unix filesystem conventions","text":"<p>The tilde <code>~</code> refers to the current user's home directory. Every user has a directory under <code>/home/yourUNI</code> for storing their files. For example, <code>~/cs3157</code> expands to <code>/home/yourUNI/cs3157</code>.</p> <p>What's up with that slash <code>/</code> at the beginning? It represents the topmost or root directory (not to be confused with the root user).</p> <p>Unlike Windows, Unix-like systems do not have separate root directories for each drive. Instead, drives are represented as separate directories under <code>/media</code> (removable drives) and <code>/mnt</code> (non-removable). When we <code>cd</code> into these directories, we are automatically looking at a different drive.</p> <p>Mounting is the process of installing a drive at some directory in the filesystem.</p> <p>An aside: now we can appreciate why the designers of Unix decided to separate binaries into essential (<code>/bin</code>, <code>/sbin</code>) and non-essential (<code>/usr</code>). In the early days of computers, hard drives were not very big, so computers usually had two. They would boot from the first drive <code>/</code>, which contained enough programs to mount the second hard drive at <code>/usr</code> (and perform basic debugging if that failed).</p> <p>If you're interested in the filesystem and its design, check out these articles:</p> <ul> <li>Unix filesystem</li> <li>Linux Foundation's Filesystem Hierarchy Standard</li> </ul>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#permissions-restrict-what-others-can-do-with-your-files","title":"Permissions restrict what others can do with your files","text":"<p>On Unix-style filesystems, each file has a set of permissions associated with it. Each permission has both a character and a number associated with it. These are:</p> <ul> <li><code>r</code> = 4 for read (this file can be opened)</li> <li><code>w</code> = 2 for write (this file can be modified)</li> <li><code>x</code> = 1 for execute (this file can be run as a program)</li> </ul> <p>If someone is allowed to both read and write to a file, the permission would be 4 + 2 = 6. Notice that for each set of enabled permissions, the sum is unique. That is, you can only get 6 by having <code>r</code> and <code>w</code> permissions. This allows the computer to store the permission flags more efficiently.</p> <p>Additionally, there are three permissions per file:</p> <ul> <li>User: Applies to what the owner of the file is allowed to do</li> <li>Group: Applies to other users in the same group</li> <li>World: Applies to all users on the computer</li> </ul> <p>To see the permissions, we can use the <code>ls -l</code> flag.</p> <p>To change the permissions, we use the <code>chmod</code> command. The three numbers represent user, group, and world permissions:</p> <pre><code>yourUNI@vienna:~$ chmod 740\n</code></pre>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#shells-are-also-scripting-languages","title":"Shells are also scripting languages","text":"<p>In 1977, Stephen Bourne introduced the Bourne shell -- the first shell to support the style of scripting we use today. It let users write scripts as text files with lists of commands, plus the usual programming language stuff like variables and control flow. (Confusingly, the Bourne shell and the Thompson shell it replaced are both called <code>sh</code>.)</p>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#working-with-variables","title":"Working with variables","text":"<p>We can define variables like this. In shell scripts, most of the variables will be string type.</p> <p>Type stuff in the format <code>name=value</code> into the terminal to make some variables:</p> <pre><code>yourUNI@vienna:~$ greeting=\"Hello world\"\nyourUNI@vienna:~$ mynumber=42\n</code></pre> <p>To print the variables, we need to put them into a string. bash supports string interpolation to insert the value of a variable into a string:</p> <pre><code>yourUNI@vienna:~$ message=\"$greeting -- my favorite number is $mynumber\"\nyourUNI@vienna:~$ echo \"$message\"\nHello world -- my favorite number is 42\n</code></pre> <p>We can also delete variables with the <code>unset</code> keyword.</p> <pre><code>yourUNI@vienna:~$ temp=\"get rid of me\"\nyourUNI@vienna:~$ echo \"$temp\"\nget rid of me\nyourUNI@vienna:~$ unset temp\nyourUNI@vienna:~$ echo \"$temp\" # prints an empty line\n\nyourUNI@vienna:~$\n</code></pre> <p>The <code>export</code> keyword ensures the variable is available in bash instances launched from this instance.</p> <pre><code>yourUNI@vienna:~$ export myvar=\"look, ma, it's inherited\"\nyourUNI@vienna:~$ bash # enter child shell\nyourUNI@vienna:~$ echo \"$myvar\"\nlook, ma, it's inherited\n</code></pre> <p>Finally, we can grab the stdout of any command with <code>$()</code>:</p> <pre><code>yourUNI@vienna:~$ all_my_files=$(ls -a)\nyourUNI@vienna:~$ echo all_my_files # prints stored output of previous run of ls -a\n</code></pre>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#saving-commands-into-a-file","title":"Saving commands into a file","text":"<p>To put it all together, here's an example of a bash script file:</p> <pre><code>#!/bin/bash\necho \"Here are your files:\" # Print this string\nls # List current directory files\n\n# Make some variables\nnumber=42\nanimal=\"dogs\"\n# Print with string interpolation\necho \"I have $number $animal\"\n</code></pre> <p>The <code>#!/bin/bash</code> at the top gives the path of the interpreter. The shell will use the program specified here to run the script. We can also specify non-shell interpreters -- for example, <code>#!/usr/bin/python</code> for a Python script.</p> <p>The shell will run each line of this file as if we typed it at the prompt.</p> <p>Save it into a file ending with <code>.sh</code>, and add the execute permission:</p> <pre><code>yourUNI@vienna:~$ vim dogs.sh\nyourUNI@vienna:~$ chmod 700 dogs.sh\n</code></pre> <p>Now, if we use <code>ls -al</code>, we'll see that our script has the <code>x</code> column set. This means we can run the script, like we would any program:</p> <pre><code>yourUNI@vienna:~$ ./dogs.sh\nI have 42 dogs\n</code></pre>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#loops","title":"Loops","text":"<p>In shell scripts, for loops have:</p> <ul> <li>String of newline-separated things to iterate through.</li> <li>Variable name that will be set before each iteration.</li> </ul> <pre><code>#!/bin/bash\n\n# seq command gives a range of numbers\nfor number in $(seq 1 10); do\n    echo \"number $number\"\ndone\n\n# a fake version of ls\nfor file in $(ls -a); do\n    echo \"file: $file\"\ndone\n</code></pre>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#conditionals","title":"Conditionals","text":"<p>The comparison operators are kind of weird:</p> <p>Integers:</p> <ul> <li><code>-eq</code> equal</li> <li><code>-ne</code> not equal</li> <li><code>-gt</code> greater than</li> <li><code>-ge</code> greater than or equal to</li> <li><code>-lt</code> less than</li> <li><code>-le</code> less than or equal to</li> </ul> <p>Strings:</p> <ul> <li><code>==</code> equal</li> <li><code>!=</code> not equal</li> <li><code>-z</code> check for empty string</li> </ul> <p>Full list of comparison operators</p> <pre><code>n=$(cat dogs.sh | wc -l)\nif [ $n -eq 9 ]; then\n    echo \"Same number of lines\"\nelse\n    echo \"Somebody changed the file\"\nfi\n\nread -p \"Enter a string: \" str\nif [ -z $str ]; then\n    echo \"You didn't enter anything\"\n    exit 1\nfi\nif [ $str == \"hi\" ]; then\n    echo \"Greetings\"\nfi\n</code></pre>"},{"location":"resources/cs3157recitations/Z-Unix-2/unix-2/#ssh-launches-shells-on-computers-over-the-network","title":"SSH launches shells on computers over the network","text":"<p>Just a note about how SSH works. When we type  <code>ssh yourUNI@clac.cs.columbia.edu</code>, the SSH program makes a connection to a CLAC server. The remote server launches a shell program, and connects its input and output to the SSH connection, so that we can control the computer remotely.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/","title":"Midsemester 1 Review Practice Problems","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/#students-should","title":"Students should:","text":"<ol> <li>Go to each folder and read the README for instructions.</li> <li>Try to solve the problem on their own.</li> <li>Look at the solutions.txt to compare with what they got.</li> </ol>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/#how-to-test-these-programs-on-your-own","title":"How to test these programs on your own.","text":"<p>Clone the recitation repository with this command: <pre><code>git clone https://github.com/cs3157/recitations.git\n</code></pre> Go into the midsemester-review-1-practice folder. <pre><code>cd midsemester-review-1-practice/\n</code></pre> Copy Jae's solution for mylist.c into the memory folder. <pre><code>cp ~location-of-mylist.c~ memory/\n</code></pre> Go into each respective directory (bits, classify-pointer, git, makefile, memory) and test the program. Note that classify-pointer does not have a Makefile, which means it is not set up to be tested.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/bits/","title":"Index","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/bits/#complete-the-problems-labeled-1-2-and-3-in-bitc","title":"Complete the problems labeled (1), (2), and (3) in bit.c.","text":"<p>For (2), don't get hung up on what the value of z actually is and see how it is used in the problem.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/classify-pointer/","title":"Index","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/classify-pointer/#lets-assume-the-following-function-exists","title":"Let's assume the following function exists:","text":"<p>It prints \"STACK\" if p contains an address on the stack; it prints \"HEAP\" if p contains an address on the heap; it prints \"NEITHER\" if p contains an address neither on the stack nor on the heap. <pre><code>void classify_pointer(void *p);\n</code></pre></p>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/classify-pointer/#go-through-classifyc-and-think-about-what-1-2-3-4-5-6-and-7-prints-if-something-prints-neither-think-about-where-the-address-lives","title":"Go through classify.c and think about what (1), (2), (3), (4), (5), (6), and (7) prints.  If something prints NEITHER, think about where the address lives.","text":"<p>Note, this will not actually compile if you use the method \"classify_pointer\", since it is not actually defined anywhere.</p>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/git/","title":"Index","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/git/#perform-these-steps","title":"Perform these steps:","text":"<ol> <li>echo a &gt; a</li> <li>echo b &gt; b</li> <li>echo c &gt; c</li> <li>echo d &gt; d</li> <li>git init</li> <li>git add a d</li> <li>git commit -m \"adding\"</li> <li>git rm d</li> <li>git add b</li> <li>echo aaa &gt; a</li> <li>git status</li> </ol>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/git/#ignore-how-readme-and-solutionstxt-interact-with-the-questions-below","title":"Ignore how README and solutions.txt interact with the questions below.","text":"<ol> <li>Which files are listed under \"Changes to be committed\"?</li> <li>Which files are listed under \"Changes not staged for commit\"?</li> <li>Which files are listed under \"Untracked files\"?</li> </ol>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/git/#to-restart-this-process","title":"To restart this process:","text":"<ol> <li>rm -rf .git</li> <li>rm a b c d</li> </ol>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/makefile/","title":"Index","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/makefile/#perform-these-steps-and-write-the-output-of-commands-when-asked-to","title":"Perform these steps and write the output of commands when asked to:","text":"<ol> <li>make</li> <li>touch main</li> <li>make</li> <li>(1) output?</li> <li>touch foo.h</li> <li>make</li> <li>(2) output?</li> <li>touch foo.o</li> <li>make</li> <li>(3) output?</li> <li>touch main.c</li> <li>make</li> <li>(4) output?</li> <li>touch foo.c</li> <li>make main.o</li> <li>(5) output?</li> </ol>"},{"location":"resources/cs3157recitations/midsemester-review-1-practice/makefile/#note-it-is-not-important-to-get-the-output-verbatim-rather-it-is-important-to-know-what-steps-will-take-place-with-each-make","title":"Note: It is not important to get the output verbatim, rather it is important to know what steps will take place with each 'make'.","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/memory/","title":"Index","text":""},{"location":"resources/cs3157recitations/midsemester-review-1-practice/memory/#memory-practice","title":"Memory practice","text":"<p>Does memory.c leak? If so, how many bytes?</p> <p>Does the call to <code>free()</code> at the end cause a crash?</p>"},{"location":"resources/cs4118recitations/","title":"cs4118 Recitations","text":"<p>This repository contains the recitation notes for Columbia's Operating Systems I class, COMSW4118, as taught by Jae Woo Lee and Kostis Kaffes. For information about the class, visit the course homepage.</p> <p>Issues, patches, and comments, especially by current and former students, are welcome.</p>"},{"location":"resources/cs4118recitations/#contents","title":"Contents","text":"<ul> <li>Note A: VM/kernel workflow setup, Linux source code   navigators  </li> <li>Note B.1: Sockets/TCP programming, server testing   strategies</li> <li>Note B.2 Diagram: Code visualization for <code>connect2.c</code></li> <li>Note C: Kernel configuration,   compilation, and style</li> <li>Note D.1: Linux wait queue (hw5)</li> <li>Note D.2 Diagram: Diagram of a possible fridge infrastructure</li> <li>Note E.1: Linux scheduler data structures, implementing   a scheduler (hw6)</li> <li>Note E.2: What does each <code>sched_class</code> function do?</li> <li>Note E.3: How are <code>sched_class</code> functions invoked in response to an event (task is preempted, task voluntarily yields, task finishes execution)?</li> </ul>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/","title":"VM/Kernel Workflow","text":"<p>Before we get into the heavier assignments in this course, you should invest sometime into setting up a workflow and develop good coding habits.</p>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#why-use-a-vm","title":"Why Use a VM?","text":"<ul> <li>Hypervisor: Software responsible for managing VMs (e.g. creation, deletion,   resource allocation). In this class, we use VMware.</li> <li>Host machine: The hardware running the hypervisor (e.g. your personal laptop)</li> <li>Virtual machine (VM): A computer system created by the hypervisor that shares   resources with the host machine. In this class, we virtualize Debian 11 (a   flavor of Linux). VMs adhere to sandbox properties:</li> <li>Isolate the work you'll be doing from the rest of the system</li> <li>Be able to take snapshots of your development environment so that if it does     get corrupted, you can revert to a clean state</li> </ul> <p>Working on a VM can be preferable to working on your host machine (i.e.   \"bare-metal\"). You can virtualize other operating systems to test your   applications. You can work on potentially buggy/dangerous code without   compromising your host machine.</p> <ul> <li>Snapshot: A feature most hypervisors support. Capture the current running   state of the VM, stores it, and then allows you to revert to that state   sometime later. You should snapshot your VM before executing something that   can compromise the system.</li> </ul> <p>In this class, we will often be \"hacking\" the Linux kernel and attempting to boot into those hacked kernels. We need to use VMs since not all of us have a Linux host machine. Even if we did, we wouldn't want to ruin our host machines with our potentially buggy kernels.</p>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#vm-setupworkflow","title":"VM Setup/Workflow","text":"<p>We've already written a series of guides for working on your VM.</p> <p>First and foremost, you should have a Debian VM installed already (see Debian VM Setup for a guide on how to do this).</p>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#working-on-your-vm","title":"Working on your VM","text":"<p>You have more options than simply working on the VM's graphical interface, which often feels clunky.</p> <p>The most common workflow involves SSHing into your VM, which we've written a guide for. This is a good option if you want to conserve processing power on your host machine and disable the VM's graphical interface. </p> <p>Alternatively, you can setup an IDE to SSH into your VM. One option is using Visual Studio Code, which we've written up some notes (below) on how to use. This is a nice alternative to command-line editors like vim/emacs if you're not familiar with them.</p>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#additional-tools","title":"Additional Tools","text":"<p>If you do decide to work in a command-line environment, here are some tools we've used to streamline our workflow:</p> <ul> <li><code>bat</code>: A better version of <code>cat</code> (installation)</li> <li><code>grep</code>: Pattern-match files (learn how to effectively use regexs to improve   search results). Even better, <code>ripgrep</code>.</li> <li>Reverse-i search: Efficiently search through bash history instead of retyping   long commands.</li> <li><code>tmux</code>: Terminal multiplexer. (e.g. open 2 panes for vim, 1 for <code>dmesg</code>, 1 for   running commands).</li> </ul>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#kernel-workflow","title":"Kernel Workflow","text":""},{"location":"resources/cs4118recitations/A-Workflow/workflow/#editor-enhancements","title":"Editor enhancements","text":"<p>Before getting into hw4/supermom, please read through one of our kernel developer workflow guides. These explain how to set up either <code>vim</code> or VSCode for kernel development.</p> <ul> <li>Vim workflow: Here,   we offer a bunch of cool <code>vim</code> additions/tricks to help you develop more   efficiently while working on the kernel assignments. Note that this guide is   only relevant if you intend to work on the command-line using <code>vim</code>. One notable   mention here is <code>cscope</code>. This is a kernel-source navigator that works directly   in your terminal/vim session. This is far more powerful than using <code>grep</code> to   look for a symbol definition/use in the source-tree.</li> <li>VSCode workflow:   In this guide, we explain how to configure autocomplete, formatting, and   various other features for working on the kernel while using VSCode. VSCode   is a very powerful editor, and being able to take advantage of its functionality   will make your life much easier.</li> </ul>"},{"location":"resources/cs4118recitations/A-Workflow/workflow/#web-tools","title":"Web Tools","text":"<p>If you don't want to use <code>cscope</code>, there's an popular online kernel-source navigator: bootlin. Note that kernel version matters when you're navigating code \u2013 be sure you select the correct version.</p> <p>Like bootlin, you can look for symbols in the kernel-source and look for instances of where they are defined and used. However, bootlin doesn't index all symbols, so you might have better luck searching with <code>cscope</code>.</p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/","title":"Sockets and Server Testing","text":""},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-and-http","title":"Sockets and HTTP","text":""},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#what-is-a-socket","title":"What is a socket?","text":"<p>A socket is a software construct used for many modes of communication between processes. The mode of communication that this recitation will focus on is network communication. In particular, stream sockets represent an endpoint for reliable, bidirectional connections such as TCP connections. This allows for two processes, on separate computers, to communicate over a TCP/IP network connection.</p> <p>Sockets have: - an IP address, to (typically) identify the computer that the socket endpoint   belongs to - a port number, to identify which process running on the computer the socket   endpoint belongs to - a protocol, such as TCP (reliable) or UDP (unreliable). Stream sockets use TCP</p> <p>An IP address and port number are both required in order for a computer to communicate with a specific process on a remote computer. </p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#the-client-server-model","title":"The client-server model","text":"<p>The two endpoints in a socket connection serve different roles. One end acts as a server:  - It tells the operating system that it should receive incoming connections on a   port number - It waits for incoming connections - When it receives a connection, it creates a new socket for each client,   which will then be used to communicate with that client</p> <p>The other end is a client: - It \"connects\" to the server using the server\u2019s IP address and the port number</p> <p>After a client connects to a server, there is bidirectional communication between the two processes, often with I/O system calls such as <code>read()</code> and <code>write()</code>, or their socket-specific variants <code>recv()</code> and <code>send()</code>. </p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-with-netcat","title":"Sockets with netcat","text":"<p>A simple way to demonstrate the bidirectional and network-based communcation of sockets is with <code>netcat</code>. <code>netcat</code> is a bare-bones program to send streams of binary data over the network.</p> <p>Imagine we have two computers that can communicate over the internet, with the IP addresses <code>clac.cs.columbia.edu</code> and <code>clorp.cs.nyu.edu</code>.</p> <p>Because of the client-server model, connecting two socket endpoints to each other is not a symmetrical process. One socket needs to act as the server, while the other needs to act as a client. You tell <code>netcat</code> to act as a server with the <code>-l</code> flag:</p> <pre><code>joy@clac.cs.columbia.edu:~$ nc -l 10000\n</code></pre> <p>The <code>netcat</code> program on <code>clac.cs.columbia.edu</code> will create a socket and wait for connections on port 10000. To tell <code>netcat</code> to act as a client, you supply the IP address of the server and the port number of the socket listening on that server:</p> <pre><code>jeremy@clorp.cs.nyu.edu:~$ nc clac.cs.columbia.edu 10000\n</code></pre> <p>Notice the differences between these two commands. The first command only requires a port number, and doesn't require the IP address of the other computer. The second command requires knowledge of both the IP address (what computer to connect to) and the port number (which process to connect to on that computer). This asymmetry is the client-server model.</p> <p>After the client connects to the server, the server <code>netcat</code> process creates a new socket for bidirectional communicaiton. After the two processes connect there is no functional difference between client and server. What you type on one end should be visible on the other -- a full duplex stream of data. </p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#sockets-api-summary","title":"Sockets API Summary","text":"<p><code>socket()</code> - Called by both the client and the server - On the server-side, a listening socket is created; a connected socket will be   created later by <code>accept()</code></p> <p><code>bind()</code> - Usually called only by the server - Binds the listening socket to a specific port that should be known to the   client</p> <p><code>listen()</code> - Called only by the server - Sets up the listening socket to accept connections</p> <p><code>accept()</code> - Called only by the server - By default blocks until a connection request arrives - Creates and returns a new socket for each client</p> <p><code>connect()</code> - Called only by the client - Requires an IP address and port number to connect to - Attempt to establish connection by reaching out to server</p> <p><code>send()</code> and <code>recv()</code> - Called by both the client and server - Reads and writes to the other side - Message boundaries may not be preserved - nearly the same as <code>write()</code> and <code>read()</code>, but with socket-specific options</p> <p>A TCP client may use these functions as such: <pre><code>int fd = socket(...);\nconnect(fd, ... /* server address */);\n\n// Communicate with the server by send()ing from and recv()ing to fd.\n\nclose(fd);\n</code></pre></p> <p>And a TCP server:</p> <pre><code>int serv_fd = socket(...);\nbind(serv_fd, ... /* server address */);\nlisten(serv_fd, ... /* max pending connections */);\n\n// use an infinite loop, to continue accepting new incoming clients\nfor (;;) {\n    int clnt_fd = accept(serv_fd, ...);\n\n    // Communicate with the client by send()ing from and recv()ing to\n    // clnt_fd, NOT serv_fd.\n\n    close(clnt_fd);\n}\n</code></pre>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#listening-socket-vs-connected-socket","title":"Listening socket vs connected socket","text":"<p>To form a bidirectional channel between client and server, three sockets are used: - The server uses two sockets   - The listening socket, to accept incoming connections from a client   - The client socket, which is created when an incoming connection has been     <code>accept()</code>ed.  - The client uses one socket   - The <code>connect()</code>ing socket, which reaches out to the server. Once the   connection has been made, communication can be done between the server's client   socket and the client's connecting socket.</p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#http-10","title":"HTTP 1.0","text":"<p>HTTP 1.0 is a protocol between a client, typically a web browser, and a server, typically a web server hosting files such as HTML. It is an outdated version of the HTTP protocol and simpler than newer versions.</p> <p>When visiting a website, a URL is specified in the following format:</p> <pre><code>http://example.com:80/index.html\n^^^^   ^^^^^^^^^^^ ^^^^^^^^^^^^^\n|      |           | |\n|      |           | URI = /index.html\n|      |           port number = 80\n|      domain name = example.com\nprotocol = HTTP\n</code></pre> <p>Based on the information provided by the user in the URL, a web client will establish a socket connection with the IP address of the domain name. After establishing the connection, the two computers exchange text in the form of HTTP requests:</p> <ul> <li>The client sends an HTTP request for a resource on the server</li> <li>The server sends an HTTP response</li> </ul> <p>HTTP request - First line: method, request URI, version     - Ex: \"GET /index.html HTTP/1.0\\r\\n\" - Followed by 0 or more headers     - Ex: \"Host: www.google.com\\r\\n\" - Followed by an empty line     - \"\\r\\n\"</p> <p>HTTP response - First line: response status     - Success: \"HTTP/1.0 200 OK\\r\\n\"     - Failure: \"HTTP/1.0 404 Not Found\\r\\n\" - Followed by 0 or more response headers - Followed by an empty line     - \"\\r\\n\" - Followed by the content of the response     - Ex: image file or HTML file</p> <p>We can see the contents of real HTTP requests using <code>netcat</code> by pretending to be either a web client or server. Our client and server won't actually work, since they simply recieve the incoming request but do nothing to process the request or reply. </p> <p>Let's first act as a web server. We tell <code>netcat</code> to open a server connection with <code>nc -l 10000</code>, and then in a web browser navigate to the URL with the domain name of this server. We can use the domain name <code>localhost</code> to specify the local computer rather than connecting to a remote computer over the internet. In Chrome, we'll navigate to the URL <code>http://localhost:10000/index.html</code>. <code>netcat</code> outputs this:</p> <pre><code>$ nc -l 10000\nGET /index.html HTTP/1.1   # GET == method; /index.html == request URI; HTTP/1.1 == version\nHost: localhost:10000      # header\nConnection: keep-alive     # more headers...\n-removed for brevity-\n                           # blank newline to indicate end of headers/request\n</code></pre> <p>To act as a client, we can type our HTTP request manually into netcat rather than doing it through the web browser. Here, we try to send an HTTP request to the domain name <code>example.com</code> on port <code>80</code> (the default for HTTP web servers) for the URI <code>/index.html</code>. Note that we specify the <code>-C</code> with <code>netcat</code> so that newlines are <code>\\r\\n</code> rather than <code>\\n</code> -- a requirement of the HTTP protocol. This flag may vary depending on <code>netcat</code> version -- check <code>man nc</code>.</p> <pre><code>$ nc -C example.com 80\nGET /index.html HTTP/1.0    # GET == method; /index.html == request URI; HTTP/1.1 == version\n                            # blank line to specify end of request\nHTTP/1.0 200 OK             # start of HTTP response. HTTP/1.0 == version; 200 OK == response status\nAccept-Ranges: bytes        # header\nContent-Type: text/html     # more headers...\n-removed for brevity-\n                            # blank newline to indicate end of headers and start of file contents\n&lt;!doctype html&gt;             # HTML contents\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Example Domain&lt;/title&gt;\n-removed for brevity-\n</code></pre>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#testing-your-multi-server","title":"Testing your multi-server","text":""},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#siege","title":"Siege","text":"<p>Siege is a command-line tool that allows you to benchmark your webserver using load testing. Given a few parameters, Siege gives you information about the number of successful transactions to your website, percent availability, the latency/throughput of your server, and more.</p> <p>To install siege, run the following command:</p> <pre><code>sudo apt install siege\n</code></pre> <p>To use siege with your webserver in HW3, run your server and test with the following command:</p> <pre><code>siege http://&lt;hostname&gt;:&lt;port&gt;/&lt;url&gt;\n</code></pre> <p>This will run for an infinite amount of time. When you Ctrl-C out of the command, a list of statistics will be outputted on your terminal.</p> <p>A better way to test with siege is using its options. The <code>-c</code> and <code>-r</code> options are particularly useful, as they allow you to specify the number of concurrent \"users\" and repetitions per user, respectively. For example, the following command will create 25 concurrent users that will each attempt to hit the server 50 times, resulting in 1250 hit attempts:</p> <pre><code>siege -c 25 -r 50 http://&lt;hostname&gt;:&lt;port&gt;/&lt;URI&gt;\n</code></pre> <p>There are many other options, specified in the siege man page. These include <code>-t</code>, which specifies how long each user should run (as opposed to how many times), and <code>-f</code>, which specifies a file path that contains a list of URLs to test. </p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#additional-guidance-on-testingbenchmarking","title":"Additional guidance on testing/benchmarking","text":"<p>When grading, we're going to test your implementation using a mix of manual connections (e.g. using tools like netcat) and stress testers like siege.</p> <p>You should use <code>netcat</code> to make sure that basic functionality works and that you can indeed have more than 1 connection to the server at any given time. <code>netcat</code> is nice because it allows you to establish a connection and then prompts you for the data to send. You should also use <code>netcat</code> to test that your cleanup logic is correct, as you can control exactly when connections start/terminate.</p> <p>Your server should be resilient to any client failure. <code>netcat</code> is a useful tool to test these kinds of failures, as you can simulate bad requests or disconnections at various points during the transaction. Your server should be able to gracefully handle these scenarios -- under no condition should your server crash because of a client failure.</p> <p>Once you've tested the basic functionality, use a stress tester to make sure that your server handles concurrent hoards of requests in a reasonable amount of time. Since we're all on VMs running on different host machines, we can't really say \"X requests must finish in Y seconds\". We're just looking to make sure that your server doesn't take years (e.g. because it is actually serializing requests).</p> <p>Our grading scripts make heavy use of siege url files. siege will basically make requests using the URLs specified in this file. Use this to make sure your server can concurrently handle all kinds of requests and correctly respond to all of them (2xx, 4xx, 5xx, multi-server never responds with 3xx).</p> <p>Regarding benchmarking, the assignment prompt occasionally instructs you to compare the performance of the implementation of one part with another. However, since you are testing multi-server in a virtual machine, the performance isn\u2019t guaranteed to be significantly better. As such, don\u2019t worry too much about the benchmarking instructions - it\u2019s not a hard and fast requirement.</p>"},{"location":"resources/cs4118recitations/B-Sockets-ServerTesting/sockets-servertesting/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Some examples were taken from John Hui's Advanced   Programming lecture notes. We recommend   reading them on top of these recitation notes.</li> <li>Lecture 13 - TCP/IP Networking</li> <li>Lecture 14 - HTTP</li> </ul>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/","title":"Linux Kernel Development","text":"<p>This document is meant to supplement our compilation guide, which goes over how to install a new kernel on your machine.</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-module-makefile","title":"Kernel Module Makefile","text":"<p>More info in our kernel module guide, but for the sake of comparison, here it is again:</p> <pre><code>obj-m += hello.o\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre> <p>This Makefile is separate from the top-level kernel source Makefile we're about to work with. Here, we're adding to the <code>obj-m</code> \"goal definition\" (build object as module) and using a specialized Makefile located at <code>/lib/modules/$(shell uname -r)/build</code> to link our module into the kernel.</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#top-level-kernel-makefile","title":"Top-level Kernel Makefile","text":"<p><code>linux/Makefile</code> is the only Makefile you'll be executing when developing with the kernel. At a high level, this Makefile is responsible for:</p> <ul> <li>recursively calling Makefiles in subdirectories</li> <li>generating kernel configurations</li> <li>building and installing kernel images</li> </ul> <p>Here's an overview of the common operations you'll be doing with this Makefile.</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#preparing-for-development","title":"Preparing for development","text":"<p>It's good practice to ensure you have a clean kernel source before beginning to development. Here's the cleaning options that this Makefile provides, as reported by <code>make help</code>:</p> <pre><code>Cleaning targets:\n  clean       - Remove most generated files but keep the config and\n                enough build support to build external modules\n  mrproper    - Remove all generated files + config + various backup files\n  distclean.  - mrproper + remove editor backup and patch files\n</code></pre> <p><code>make mrproper</code> is usually sufficient for our purposes. Be warned that you'll have to completely rebuild the kernel after running this!</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#configuration-and-compilation","title":"Configuration and compilation","text":"<p><code>linux/.config</code> is the kernel's configuration file. It lists a bunch of options that determine the properties of the kernel you're about to build. It also determines what code will be compiled and linked into the final kernel image. For example, if <code>CONFIG_SMP</code> is set, you're letting the kernel know that you have more than one processor so it can provide multi-processing functionality.</p> <p>There's a bunch of different ways to generate this configuration file. Here's the relevant options we have, as reported by <code>make help</code> in the top-level kernel directory:</p> <pre><code>Configuration targets:\n  config          - Update current config utilising a line-oriented program\n  menuconfig      - Update current config utilising a menu based program\n  oldconfig       - Update current config utilising a provided .config as base\n  localmodconfig  - Update current config disabling modules not loaded\n  defconfig       - New config with default from ARCH supplied defconfig\n  olddefconfig    - Same as oldconfig but sets new symbols to their\n                    default value without prompting\n</code></pre> <p>Summarizing from our compilation guide, we set up our kernel config in a couple of steps:</p> <pre><code>make olddefconfig # Use current kernel's .config + ARCH defaults\nmake menuconfig   # Manually edit some configs\n</code></pre> <p>If you want to significantly reduce your build time, you can also set your config to skip unloaded modules during compilation:</p> <pre><code>yes '' | make localmodconfig\n</code></pre> <p>As you're developing in the kernel, you might add additional source files that need to be compiled and linked in. Open up the directory's Makefile and add your desired object file to the <code>obj-y</code> goal definition, which is for \"built-in\" functionality (as opposed to kernel modules). For example, here's the relevant portion of <code>linux/kernel/Makefile</code>:</p> <pre><code>obj-y     = fork.o exec_domain.o panic.o \\\n        cpu.o exit.o softirq.o resource.o \\\n        sysctl.o sysctl_binary.o capability.o ptrace.o user.o \\\n        signal.o sys.o umh.o workqueue.o pid.o task_work.o \\\n        extable.o params.o \\\n        kthread.o sys_ni.o nsproxy.o \\\n        notifier.o ksysfs.o cred.o reboot.o \\\n        async.o range.o smpboot.o ucount.o\n</code></pre> <p>If you were adding a source file to <code>linux/kernel</code>, you'd add the object file target here.</p> <p>Once you're ready to compile your kernel, you run the following in the top-level source directory:</p> <pre><code>make -j $(nproc)\n</code></pre> <p>This will compile your kernel across all available CPUs, as reported by <code>nproc</code>. Note that this top-level Makefile will recursively build source code in subdirectories for you!</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-installation","title":"Kernel installation","text":"<p>Like in our compilation guide, you run the following command once the compilation finishes:</p> <pre><code>sudo make modules_install &amp;&amp; sudo make install\n</code></pre> <p>The first time you install a kernel, you must build <code>modules_install</code>. All subsequent times, <code>install</code> is sufficient.</p> <p>Finally, reboot and select the kernel version you just installed via the GRUB menu!</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#kernel-code-style","title":"Kernel Code Style","text":"<p>The kernel source comes with a linter written in Perl (located at <code>linux/scripts/checkpatch.pl</code>).</p> <p>checkpatch will let you know about any stylistic errors and warnings that it finds in the codebase. You should get into the habit of running checkpatch and fixing what it suggests before major checkpoints.</p> <p>If you want a general overview of kernel code style, here's one. You can also find this in <code>linux/Documentation/process/coding-style.rst</code>.</p>"},{"location":"resources/cs4118recitations/C-Linux-Kernel-Dev/linux-kernel-dev/#debugging-techniques","title":"Debugging Techniques","text":"<ul> <li>Take   snapshots   of your VM before installing software that may corrupt it.</li> <li>Use <code>printk/pr_info</code> to log messages to the kernel log buffer (viewable in   userspace with by running <code>sudo dmesg</code>)</li> <li>Set up a serial port to redirect log   buffer to your host machine (in case VM crashes before you can check it with   <code>dmesg</code>).</li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/","title":"Implementing a scheduling class","text":"<p>This guide describes the data structures used for implementing a scheduling class. To understand how these data structures are used, you can find more specific information here and here. The first guide goes through the <code>sched_class</code> functions one by one. The second guide shows how these functions are invoked from an event-driven perspective (e.g. what happens on a timer interrupt? what happens when a process is done executing?).</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#introduction","title":"Introduction","text":"<p>One of the reasons students struggle with this assignment boils down to a lack of understanding of how the scheduler works. In this guide, I hope to provide you with a clear understanding of how the Linux scheduler pieces fit together. I hope to paint a picture that you can use to implement the freezer scheduler.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#the-task_struct","title":"The <code>task_struct</code>","text":"<p>Recall from HW1 that in Linux, every process is defined by its <code>struct task_struct</code>. When you have multiple tasks forked off a common parent, they are linked together in a doubly linked-list <code>struct list_head sibling</code> embedded within the <code>task_struct</code>. For example, if you had four processes running on your system, each forked off one parent, it would look something like this (the parent is not shown):</p> <p>However, at this stage, none of these processes are actually running on a CPU. In order to get them onto a CPU, I need to introduce you to the <code>struct rq</code>.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#the-struct_rq","title":"The <code>struct_rq</code>","text":"<p>The <code>struct rq</code> is a per-cpu run queue data structure. I like to think of it as the virtual CPU. It contains a lot of information (most of which goes way over my head), but it also includes the list of tasks that will (eventually) run on that CPU.</p> <p>A naive implementation would be to embed a <code>struct list_head runqueue_head</code> (for example) into the <code>struct rq</code>, and embed a <code>struct list_head node</code> into every <code>task_struct</code>.</p>      This is a BAD implementation.  <p>The main problem with this implementation is that it does not extend well. At this point, you know Linux has more than one scheduling class. Linux comes built with a deadline class, a real-time class, and the primary CFS. Having a <code>list_head</code> embedded directly into the <code>struct rq</code> for each scheduling class is not feasible.</p> <p>The solution is to create a new structure containing the <code>list_head</code> and any bookkeeping variables. Then, we can include just the wrapper structure in the <code>struct rq</code>. Linux includes these structures in <code>linux/kernel/sched/sched.h</code>.</p> <p>By convention, Linux scheduler-specific wrapper structures are named <code>struct &lt;sched_class&gt;_rq</code>. For example, the CFS class defines a <code>struct cfs_rq</code> which is then declared inside of <code>struct rq</code> as <code>struct cfs_rq cfs</code>.</p> <p>The following snippet is taken from <code>linux/kernel/sched/sched.h</code>:</p> <pre><code>struct cfs_rq {\n    struct load_weight  load;\n    unsigned int        nr_running;\n    unsigned int        h_nr_running;\n    unsigned int        idle_h_nr_running;\n    /* code omitted */\n};\n\nstruct rq {\n    /* code omitted */\n    struct cfs_rq       cfs;\n    struct rt_rq        rt;\n    struct dl_rq        dl;\n    /* code omitted */\n};\n</code></pre>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#the-freezer_rq","title":"The <code>freezer_rq</code>","text":"<p>At this point, you've probably guessed that you will need to do the same thing for freezer. You are right. The <code>freezer_rq</code> should include the head of the freezer runqueue. Additionally, you may need to include some bookkeeping variables. Think of what you would actually need and don't add anything extra (it should be pretty simple).</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#the-sched_freezer_entity","title":"The <code>sched_freezer_entity</code>","text":"<p>Now that you have the <code>struct rq</code> setup, you need to have some mechanism to join your <code>task_struct</code>s into the queue. Here, too, you can't just include a <code>list_head node</code> to add a task onto the scheduler-specific runqueue because you'll need additional bookkeeping. As you have probably guessed, we are going to wrap the <code>list_head</code> and all the bookkeeping variables into their own struct.</p> <p>In Linux, we name these structs <code>sched_{class}_entity</code> (one exception is that CFS names this <code>sched_entity</code>). For example, the real-time scheduling class calls it <code>sched_rt_entity</code>. We will name ours <code>struct sched_freezer_entity</code>. Again, make sure you only include what you need in this struct.</p> <p>With all this setup, here is what the final picture looks like:</p> <p>In the picture above, the two structs on the far left represent a system with two CPUs. I colored these blue and green to distinguish them from each other, and to show that different <code>task_structs</code> linked on one <code>siblings</code> linked-list can run on separate CPUs.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer/#the-sched_class","title":"The <code>sched_class</code>","text":"<p>At this point, we have set up the data structures, but we are still not done. We now need to implement the freezer functionality to let the kernel use freezer as a scheduler.</p> <p>Think about this situation: Say we have a CFS task about to return from main(). The OS needs to call CFS <code>dequeue_task()</code> to remove it from the CFS queue. How can we ensure that the OS will call the CFS implementation of <code>dequeue_task()</code>? The answer is <code>struct sched_class</code>, defined in <code>linux/kernel/sched/sched.h</code>. Here is what the structure looks like:</p> <pre><code>struct sched_class {\n\n#ifdef CONFIG_UCLAMP_TASK\n    int uclamp_enabled;\n#endif\n\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task)   (struct rq *rq);\n    bool (*yield_to_task)(struct rq *rq, struct task_struct *p);\n\n    void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);\n\n    struct task_struct *(*pick_next_task)(struct rq *rq);\n\n    void (*put_prev_task)(struct rq *rq, struct task_struct *p);\n    void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);\n\n#ifdef CONFIG_SMP\n    int (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n    int  (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n    void (*migrate_task_rq)(struct task_struct *p, int new_cpu);\n\n    void (*task_woken)(struct rq *this_rq, struct task_struct *task);\n\n    void (*set_cpus_allowed)(struct task_struct *p,\n                 const struct cpumask *newmask);\n\n    void (*rq_online)(struct rq *rq);\n    void (*rq_offline)(struct rq *rq);\n#endif\n\n    void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork)(struct task_struct *p);\n    void (*task_dead)(struct task_struct *p);\n\n    /*\n     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we\n     * cannot assume the switched_from/switched_to pair is serliazed by\n     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.\n     */\n    void (*switched_from)(struct rq *this_rq, struct task_struct *task);\n    void (*switched_to)  (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task,\n                  int oldprio);\n\n    unsigned int (*get_rr_interval)(struct rq *rq,\n                    struct task_struct *task);\n\n    void (*update_curr)(struct rq *rq);\n\n#define TASK_SET_GROUP      0\n#define TASK_MOVE_GROUP     1\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    void (*task_change_group)(struct task_struct *p, int type);\n#endif\n} __aligned(STRUCT_ALIGNMENT); /* STRUCT_ALIGN(), vmlinux.lds.h */\n</code></pre> <p>As you can see, <code>struct sched_class</code> contains many function pointers. When we add a new scheduling class, we create an instance of <code>struct sched_class</code> and set the function pointers to point to our implementation of these functions. If we look in the file <code>linux/kernel/sched/fair.c</code>, we see how CFS does it:</p> <pre><code>const struct sched_class fair_sched_class\n    __section(\"__fair_sched_class\") = {\n    .enqueue_task       = enqueue_task_fair,\n    .dequeue_task       = dequeue_task_fair,\n    .yield_task     = yield_task_fair,\n    .yield_to_task      = yield_to_task_fair,\n\n    .check_preempt_curr = check_preempt_wakeup,\n\n    .pick_next_task     = __pick_next_task_fair,\n    .put_prev_task      = put_prev_task_fair,\n    .set_next_task          = set_next_task_fair,\n\n#ifdef CONFIG_SMP\n    .balance        = balance_fair,\n    .select_task_rq     = select_task_rq_fair,\n    .migrate_task_rq    = migrate_task_rq_fair,\n\n    .rq_online      = rq_online_fair,\n    .rq_offline     = rq_offline_fair,\n\n    .task_dead      = task_dead_fair,\n    .set_cpus_allowed   = set_cpus_allowed_common,\n#endif\n\n    .task_tick      = task_tick_fair,\n    .task_fork      = task_fork_fair,\n\n    .prio_changed       = prio_changed_fair,\n    .switched_from      = switched_from_fair,\n    .switched_to        = switched_to_fair,\n\n    .get_rr_interval    = get_rr_interval_fair,\n\n    .update_curr        = update_curr_fair,\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    .task_change_group  = task_change_group_fair,\n#endif\n\n#ifdef CONFIG_UCLAMP_TASK\n    .uclamp_enabled     = 1,\n#endif\n};\n</code></pre> <p>Note that the dot notation is a C99 feature that allows you to set specific fields of the struct by name in an initializer. This notation is also called designated initializers. Also, not every function needs to be implemented. You will need to figure out what is and is not necessary. To see an example of a bare minimum scheduler, see the idle_sched_class, which is the scheduling policy used when no other tasks are ready to be executed.</p> <p>As you can see, CFS initializes the <code>struct sched_class</code> function pointers to the CFS implementation. Two things of note here. First, the convention is to name the struct <code>&lt;class_name&gt;_sched_class</code>, so CFS names it <code>fair_sched_class</code>. Second, we name a particular class's functions as <code>&lt;function_name&gt;_&lt;class_name&gt;</code>. For example, the CFS implementation of <code>enqueue_task</code> as <code>enqueue_task_fair</code>. Now, every time the kernel needs to call a function, it can simply call <code>p-&gt;sched_class-&gt;&lt;function()&gt;</code>. Here, <code>p</code> is of the type <code>task_struct *</code>, <code>sched_class</code> is a pointer within the <code>task_struct</code> pointing to an instance of <code>struct sched_class</code>, and the <code>&lt;function()&gt;</code> points to the specific implementaion of the the function to be called.</p> <p>One final thing: you may have noticed the <code>__section(\"__fair_sched_class\")</code> macro in the declaration of<code>struct sched_class fair_sched_class</code>. When building the kernel, this allows the linker to align the <code>sched_class</code>'s contiguously in memory through the use of a linker script. A linker script describes how various sections in the input (source) files should be mapped into the output (binary/object) file, and to control the memory layout of the output file.</p> <p>We can see this in <code>linux/include/asm-generic/vmlinux.lds.h</code>:</p> <pre><code>/*\n * The order of the sched class addresses are important, as they are\n * used to determine the order of the priority of each sched class in\n * relation to each other.\n */\n#define SCHED_DATA              \\\n    STRUCT_ALIGN();             \\\n    __begin_sched_classes = .;      \\\n    *(__idle_sched_class)           \\\n    *(__fair_sched_class)           \\\n    *(__rt_sched_class)         \\\n    *(__dl_sched_class)         \\\n    *(__stop_sched_class)           \\\n    __end_sched_classes = .;\n</code></pre> <p>This effectively allows the kernel to treat the <code>sched_class</code> structs as part of an array of <code>sched_class</code>'s. The first class in the array is of lower priority than the second. In other words, <code>sched_class_dl</code> has a higher priority than <code>sched_class_rt</code>. Now, every time a new process needs to be scheduled, the kernel can simply go through the class array and check if there is a process of that class that needs to run. Let's take a look at this as implemented in <code>linux\\kernel\\sched\\core.c</code>.</p> <pre><code>static inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n    const struct sched_class *class;\n    struct task_struct *p;\n\n    /* code omitted */\n\n    for_each_class(class) {\n        p = class-&gt;pick_next_task(rq);\n        if (p)\n            return p;\n    }\n\n    /* The idle class should always have a runnable task: */\n    BUG();\n}\n</code></pre> <p>This makes use of the <code>for_each_class()</code> macro, which takes advantage of the array structure of the <code>sched_class</code>'s. We can see this implementation in <code>linux/kernel/sched/sched.h</code>:</p> <pre><code>/* Defined in include/asm-generic/vmlinux.lds.h */\nextern struct sched_class __begin_sched_classes[];\nextern struct sched_class __end_sched_classes[];\n\n#define sched_class_highest (__end_sched_classes - 1)\n#define sched_class_lowest  (__begin_sched_classes - 1)\n\n#define for_class_range(class, _from, _to) \\\n    for (class = (_from); class != (_to); class--)\n\n#define for_each_class(class) \\\n    for_class_range(class, sched_class_highest, sched_class_lowest)\n</code></pre> <p>Essentially, when a process wants to relinquish its time on a CPU, <code>schedule()</code> gets called. Following the chain of calls in the kernel, <code>pick_next_task()</code> eventually gets called, and the OS will loop through each scheduling class by calling <code>for_each_class(class)</code>. Here, we call the <code>pick_next_task()</code> function of a particular instance of <code>struct sched_class</code>. If <code>pick_next_task()</code> returns <code>NULL</code>, the kernel will simply move on to the next class. If the kernel reaches the lowest priority class on the list (i.e. <code>idle_sched_class</code>) then there are no tasks to run and the CPU will go into idle mode.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/","title":"Freezer runqueue","text":"<p>This guide was written by Ryan Wee in Spring 2024. The code snippets and links in this post correspond to Linux v5.10.205.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/#introduction","title":"Introduction","text":"<p>First of all, it is entirely possible (and probable) that there are mistakes in this guide. If so, feel free to contact the TA team.</p> <p>This guide is meant to complement Mitchell's guide -- it's a good idea to read both of them. Mitchell's guide explains what each of the <code>sched_class</code> functions do. The aim of this guide is to provide an event-driven perspective of how these functions are invoked. In particular, how is the freezer runqueue modified in response to different events?</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/#tldr","title":"TLDR","text":"<ul> <li>Freezer's <code>pick_next_task()</code> implementation does NOT modify the freezer   runqueue. It only picks the task at the front of the freezer runqueue.</li> <li>When a task is preempted because its timeslice is up, freezer's <code>task_tick()</code>   implementation is responsible for modifying the freezer runqueue.</li> <li>When a task voluntarily yields the CPU, there are two possibilities:<ul> <li>The task's state is <code>RUNNABLE</code>, i.e. it would like to stay on the     run queue: In this case, freezer's <code>yield_task()</code> and <code>task_tick()</code>     implementations are responsible for modifying the freezer runqueue.</li> <li>The task's state is NOT <code>RUNNABLE</code>, i.e. it would like to leave the     run queue: In this case, freezer's <code>dequeue_task()</code> implementation is responsible for modifying the freezer runqueue.</li> </ul> </li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/#when-a-tasks-timeslice-is-up","title":"When a task's timeslice is up","text":"<ul> <li>The timer interrupt code calls <code>scheduler_tick()</code>.</li> <li>This function invokes <code>curr-&gt;sched_class-&gt;task_tick()</code>.</li> <li>Freezer's <code>task_tick()</code> implementation should decrement the current task's   timeslice. (Note that the timeslice should therefore use jiffies as the unit.)</li> <li>If the current task's timeslice is down to 0:<ul> <li>Freezer's <code>task_tick()</code> implementation should move the current task to the   end of the runqueue. At this point, the task is still running on the CPU!   We've just modified its position on the runqueue.</li> <li>Freezer's <code>task_tick()</code> implementation should call <code>resched_curr()</code>, which   sets the <code>TIF_NEED_RESCHED</code> flag. Again, at this point, the task is still running on the CPU!</li> </ul> </li> <li>The kernel checks <code>TIF_NEED_RESCHED</code> on interrupt and userspace return paths.   When it's safe (e.g. the process isn't holding any spinlocks), the kernel   calls <code>schedule()</code>, which in turn invokes <code>__schedule()</code>.</li> <li>This huge <code>if</code> block is NOT executed.<ul> <li>In particular, recall that the <code>task_struct</code> has a <code>state</code> field. When a task is <code>RUNNABLE</code>, the state field is zero. When a task is not <code>RUNNABLE</code>, the state field is non-zero.</li> <li>In this case, the task is still <code>RUNNABLE</code>, i.e. <code>prev_state</code> is zero. So the <code>if</code> block is not executed.</li> </ul> </li> <li><code>schedule()</code> eventually calls <code>pick_next_task()</code> here, which calls Freezer's <code>pick_next_task()</code> implementation.</li> <li>Freezer's <code>pick_next_task()</code> implementation should return a new task from the   front of the feezer runqueue.</li> <li><code>__schedule()</code> also eventually calls <code>context_switch()</code> here, which is where the actual context switch happens.</li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/#when-a-task-voluntarily-yields-but-is-runnable","title":"When a task voluntarily yields, but is RUNNABLE","text":"<p>In this case, the task wants to be remain on the runqueue. It's just telling the kernel: \"Okay, you can shift me to the back of the runqueue because I'm nice. But feel free to select me again when you want to!\"</p> <ul> <li>The task calls the <code>sched_yield</code> syscall, which in turn invokes <code>do_sched_yield()</code>.</li> <li><code>do_sched_yield</code> calls <code>current-&gt;sched_class-&gt;yield_task()</code>.</li> <li>Freezer's <code>yield_task()</code> implementation should set the timeslice of the   task to 0.</li> <li>Now the next time we have a timer interrupt, the task is 'pre-empted' as described above by freezer's <code>task_tick()</code> implementation. (I put that in quotation marks because the task voluntarily decided to let itself be pre-empted.)</li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_runqueue/#when-a-task-voluntarily-yields-and-is-not-runnable","title":"When a task voluntarily yields, and is not RUNNABLE","text":"<p>In this case, the task wants to be taken off the runqueue. This could be because the task called <code>__wait_event_interruptible()</code>, or <code>sleep()</code>, or anything that basically indicates it wants to suspend its execution for the near future. Another common case would be when the task finishes its execution.</p> <ul> <li>The task starts by modifying its state so that it is no longer <code>RUNNABLE</code>. It then calls <code>__schedule()</code> with <code>false</code> as an argument.<ul> <li>In the case of a task finishing its execution:<ul> <li>The task calls the <code>exit()</code> syscall, which calls <code>do_exit()</code>.</li> <li>This in turn calls <code>do_task_dead()</code> here.</li> <li><code>do_task_dead()</code> modifies the task state here, and then calls <code>__schedule()</code> here.</li> </ul> </li> <li>In the case of a task calling <code>sleep()</code>:<ul> <li>The task calls the <code>nanosleep()</code> syscall, which calls <code>hrtimer_nanosleep()</code> and then <code>do_nanosleep()</code>.</li> <li><code>do_nanosleep()</code> modifies the task state here, and then calls <code>freezable_schedule()</code> here. This in turn calls <code>schedule()</code>.</li> </ul> </li> </ul> </li> <li>In all of these cases, when <code>__schedule()</code> is called, the <code>state</code> field of the <code>task_struct</code> is no longer <code>RUNNABLE</code>, i.e. it is non-zero. Since <code>state</code> is non-zero and since the <code>preempt</code> argument was <code>false</code> as mentioned above, we go into this <code>if</code> block.</li> <li>This in turn calls <code>deactivate_task()</code> here.</li> <li><code>deactivate_task()</code> calls <code>dequeue_task()</code>, which in turn calls the <code>dequeue_task()</code> implementation of the current scheduling class.</li> <li>Freezer's <code>dequeue_task()</code> implementation should remove the current task from the freezer runqueue.</li> <li>Recall that we're still within an earlier invocation of <code>__schedule()</code>. This invocation calls <code>pick_next_task()</code> and <code>context_switch()</code> as mentioned above. Since the current task has been removed from the freezer runqueue, this causes the next task in the runqueue to be run.</li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/","title":"Freezer sched_class","text":"<p>This guide is adapted from a blog series written by Mitchell Gouzenko, a former OS TA. The original posts can be found here.</p> <p>The code snippets and links in this post correspond to Linux v5.10.205 for 2024 Spring.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#introduction","title":"Introduction","text":"<p>I'm writing this series after TA-ing an operating systems class for two semesters. Each year, tears begin to flow by the time we get to the infamous Scheduler Assignment - where students are asked to implement a round-robin scheduler in the Linux kernel. The assignment is known to leave relatively competent programmers in shambles. I don't blame them; the seemingly simple task of writing a round robin scheduler is complicated by two confounding factors:</p> <ul> <li>The Linux scheduler is cryptic as hell and on top of that, very poorly   documented.</li> <li>Bugs in scheduler code will often trigger a kernel panic, freezing the system   without providing any logs or meaningful error messages.</li> </ul> <p>I hope to ease students' suffering by addressing the first bullet point. In this series, I will explain how the scheduler's infrastructure is set up, emphasizing how one may leverage its modularity to plug in their own scheduler.</p> <p>We'll begin by examining the basic role of the core scheduler and how the rest of the kernel interfaces with it. Then, we'll look at <code>sched_class</code>, the modular data structure that permits various scheduling algorithms to live and operate side-by-side in the kernel.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#a-top-down-approach","title":"A Top Down Approach","text":"<p>Initially, I'll treat the scheduler as a black box. I will make gross over-simplifications but note very clearly when I do so. Little by little, we will delve into the scheduler's internals, unfolding the truth behind these simplifications. By the end of this series, you should be able to start tackling the problem of writing your own working scheduler.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#disclaimer","title":"Disclaimer","text":"<p>I'm not an expert kernel hacker. I'm just a student who has spent a modest number of hours reading, screaming at, and sobbing over kernel code. If I make a mistake, please point it out in the comments section, and I'll do my best to correct it.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#what-is-the-linux-scheduler","title":"What is the Linux Scheduler?","text":"<p>Linux is a multi-tasking system. At any instant, there are many processes active at once, but a single CPU can only perform work on behalf of one process at a time. At a high level, Linux context switches from process to process, letting the CPU perform work on behalf of each one in turn. This switching occurs quickly enough to create the illusion that all processes are running simultaneously. The scheduler is in charge of coordinating all of this switching.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#where-does-the-scheduler-fit","title":"Where Does the Scheduler Fit?","text":"<p>You can find most scheduler-related code under <code>kernel/sched</code>. Now, the scheduler has a distinct and non-trivial job. The rest of the kernel doesn't know or care how the scheduler performs its magic, as long as it can be called upon to schedule tasks. So, to hide the complexity of the scheduler, it is invoked with a simple and well-defined API. The scheduler - from the perspective of the rest of the kernel - has two main responsibilities:</p> <ul> <li> <p>Responsibility I: Provide an interface to halt the currently running process and switch to a new one. To do so, the scheduler must pick the next process to run, which is a nontrivial problem.</p> </li> <li> <p>Responsibility II: Indicate to the rest of the OS when a new process should be run.</p> </li> </ul>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#responsibility-i-switching-to-the-next-process","title":"Responsibility I: Switching to the Next Process","text":"<p>To fulfill its first responsibility, the scheduler must somehow keep track of all the running processes.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#the-runqueue","title":"The Runqueue","text":"<p>Here's the first over-simplification: you can think of the scheduler as a system that maintains a simple queue of processes in the form of a linked list. The process at the head of the queue is allowed to run for some \"time slice\" - say, 10 milliseconds. After this time slice expires, the process is moved to the back of the queue, and the next process gets to run on the CPU for the same time slice. When a running process is forcibly stopped and taken off the CPU in this way, we say that it has been preempted. The linked list of processes waiting to have a go on the CPU is called the runqueue. Each CPU has its own runqueue, and a given process may appear on only one CPU's runqueue at a time. Processes CAN migrate between various CPUs' runqueues, but we'll save this discussion for later.</p>      Figure 1: An over-simplification of the runqueue  <p>The scheduler is not really this simple; the runqueue is defined in the kernel as <code>struct rq</code>, and you can take a peek at its definition here. Spoiler alert: it's not a linked list! To be fair, the explanation that I gave above more or less describes the very first Linux runqueue. But over the years, the scheduler evolved to incorporate multiple scheduling algorithms. These include:</p> <ul> <li>Completely Fair Scheduler (CFS)</li> <li>Real-Time Scheduler</li> <li>Deadline Scheduler</li> </ul> <p>The modern-day runqueue is no longer a linked list but actually a collection of algorithm-specific runqueues corresponding to the list above. Indeed, <code>struct rq</code> has the following members:</p> <pre><code>struct cfs_rq cfs;  // CFS scheduler runqueue\nstruct rt_rq rt;    // Real-time scheduler runqueue\nstruct dl_rq dl;    // Deadline scheduler runqueue\n</code></pre> <p>For example, CFS, which is the default scheduler in modern Linux kernels, uses a red-black tree data structure to keep track of processes, with each process assigned a \"virtual runtime\" that determines its priority in the scheduling queue. The scheduler then selects the process with the lowest virtual runtime to run next, ensuring that each process gets a fair share of CPU time over the long term.</p> <p>Keep these details in the back of your mind so that you don't get bogged down. Remember: the goal here is to understand how the scheduler interoperates with the rest of the kernel. The main takeaway is that a process is allowed to run for some time, and when that time expires, it gets preempted so that the next process can run.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#preemption-vs-yielding","title":"Preemption vs Yielding","text":"<p>Preemption is not always the reason a process is taken off the CPU. For example, a process might voluntarily go to sleep, waiting for an IO event or lock. To do this, the process puts itself on a \"wait queue\" and takes itself off the runqueue. In this case, the process has yielded the CPU. In summary:</p> <ul> <li> <p>\"preemption\" is when a process is forcibly kicked off the CPU.</p> </li> <li> <p>\"yielding\" is when a process voluntarily gives up the CPU.</p> </li> </ul> <p>In addition to an expired timeslice, there are several other reasons that preemption may occur. For example, when an interrupt occurs, the CPU may be preempted to handle the interrupt. Additionally, a real-time process may have a higher priority than some other process and may preempt lower-priority processes to ensure that it meets its deadline.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#schedule","title":"<code>schedule()</code>","text":"<p>With a conceptual understanding of the runqueue, we now have the background to understand how Responsibility I is carried out by the scheduler. The <code>schedule()</code> function is the crux of Responsibility I: it halts the currently running process and runs the next one on the CPU. This function is referred to by many texts as \"the entrypoint into the scheduler\". <code>schedule()</code> invokes <code>__schedule()</code> to do most of the real work. Here is the portion relevant to us:</p> <pre><code>static void __sched notrace __schedule(bool preempt)\n{\n    struct task_struct *prev, *next;\n    unsigned long *switch_count;\n    struct rq *rq;\n\n    /* CODE OMITTED */\n\n    next = pick_next_task(rq, prev, &amp;rf);\n    clear_tsk_need_resched(prev);\n    clear_preempt_need_resched();\n\n    if (likely(prev != next)) {\n        rq-&gt;nr_switches++;\n        RCU_INIT_POINTER(rq-&gt;curr, next);\n        ++*switch_count;\n\n        psi_sched_switch(prev, next, !task_on_rq_queued(prev));\n        trace_sched_switch(preempt, prev, next);\n        rq = context_switch(rq, prev, next, &amp;rf);\n    }\n\n    /* CODE OMITTED */\n}\n</code></pre> <p><code>pick_next_task()</code> looks at the runqueue <code>rq</code> and returns the <code>task_struct</code> associated with the process that should be run next. If we consider t=10 in Figure 1, <code>pick_next_task()</code> would return the <code>task_struct</code> for Process 2. Then, <code>context_switch()</code> switches the CPU's state to that of the returned <code>task_struct</code>. This fullfills Responsibility I.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#responsibility-ii-when-should-the-next-process-run","title":"Responsibility II: When Should the Next Process Run?","text":"<p>Great, so we've seen that <code>schedule()</code> is used to context switch to the next task. But when does this actually happen?</p> <p>As mentioned previously, a user-space program might voluntarily go to sleep waiting for an IO event or a lock. In this case, the kernel will call <code>schedule()</code> on behalf of the process that needs to sleep. But what if the user-space program never sleeps? Here's one such program:</p> <pre><code>int main()\n{\n    while(1);\n}\n</code></pre> <p>If <code>schedule()</code> were only called when a user-space program voluntarily sleeps, then programs like the one above would use up the processor indefinitely. Thus, we need a mechanism to preempt processes that have exhausted their time slice!</p> <p>This preemption is accomplished via the timer interrupt. The timer interrupt fires periodically, allowing control to jump to the timer interrupt handler in the kernel. This handler calls the function <code>update_process_times()</code>, shown below.</p> <pre><code>/*\n * Called from the timer interrupt handler to charge one tick to the current\n * process.  user_tick is 1 if the tick is user time, 0 for system.\n */\nvoid update_process_times(int user_tick)\n{\n    struct task_struct *p = current;\n\n    PRANDOM_ADD_NOISE(jiffies, user_tick, p, 0);\n\n    /* Note: this timer irq context must be accounted for as well. */\n    account_process_tick(p, user_tick);\n    run_local_timers();\n    rcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n    if (in_irq())\n        irq_work_tick();\n#endif\n    scheduler_tick();\n    if (IS_ENABLED(CONFIG_POSIX_TIMERS))\n        run_posix_cpu_timers();\n}\n</code></pre> <p>Notice how <code>update_process_times()</code> invokes <code>scheduler_tick()</code>. In <code>scheduler_tick()</code>, the scheduler checks to see if the running process's time has expired. If so, it sets a (over-simplification alert) per-CPU flag called <code>need_resched</code>. This indicates to the rest of the kernel that <code>schedule()</code> should be called. In our simplified example, <code>scheduler_tick()</code> would set this flag when the current process has been running for 10 milliseconds or more.</p> <p>But wait, why the heck can't <code>scheduler_tick()</code> just call <code>schedule()</code> by itself, from within the timer interrupt? After all, if the scheduler knows that a process's time has expired, shouldn't it just context switch right away?</p> <p>As it turns out, it is not always safe to call <code>schedule()</code>. In particular, if the currently running process is holding a spinlock in the kernel, it cannot be put to sleep from the interrupt handler. (Let me repeat that one more time because people always forget: you cannot sleep with a spinlock. Sleeping with a spinlock may cause the kernel to deadlock, and will bring you anguish for many hours when you can't figure out why your system has hung.)</p> <p>When the scheduler sets the <code>need_resched</code> flag, it's really saying, \"please dearest kernel, invoke <code>schedule()</code> at your earliest convenience.\" The kernel keeps a count of how many spinlocks the currently running process has acquired. When that count goes down to 0, the kernel knows that it's okay to put the process to sleep. The kernel checks the <code>need_resched</code> flag in two main places:</p> <ul> <li> <p>when returning from an interrupt handler</p> </li> <li> <p>when returning to user-space from a system call</p> </li> </ul> <p>If <code>need_resched</code> is <code>True</code> and the spinlock count is 0, then the kernel calls <code>schedule()</code>. With our simple linked-list runqueue, this delayed invocation of <code>schedule()</code> implies that a process can possibly run for a bit longer than its timeslice. We're cool with that because it's always safe to call <code>schedule()</code> when the kernel is about to return to user-space. That's because user-space programs are allowed to sleep. So, by the time the kernel is about to return to user-space, it cannot be holding any spinlocks. This means that there won't be a large delay between when <code>need_resched</code> is set, and when <code>schedule()</code> gets called.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#understanding-sched_class","title":"Understanding <code>sched_class</code>","text":"<p>In this section, I will analyze <code>struct sched_class</code> and talk briefly about what most of the functions do. I've reproduced <code>struct sched_class</code> below.</p> <pre><code>struct sched_class {\n\n#ifdef CONFIG_UCLAMP_TASK\n    int uclamp_enabled;\n#endif\n\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task)   (struct rq *rq);\n    bool (*yield_to_task)(struct rq *rq, struct task_struct *p);\n\n    void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);\n\n    struct task_struct *(*pick_next_task)(struct rq *rq);\n\n    void (*put_prev_task)(struct rq *rq, struct task_struct *p);\n    void (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);\n\n#ifdef CONFIG_SMP\n    int (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n    int  (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n    void (*migrate_task_rq)(struct task_struct *p, int new_cpu);\n\n    void (*task_woken)(struct rq *this_rq, struct task_struct *task);\n\n    void (*set_cpus_allowed)(struct task_struct *p,\n                 const struct cpumask *newmask);\n\n    void (*rq_online)(struct rq *rq);\n    void (*rq_offline)(struct rq *rq);\n#endif\n\n    void (*task_tick)(struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork)(struct task_struct *p);\n    void (*task_dead)(struct task_struct *p);\n\n    /*\n     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we\n     * cannot assume the switched_from/switched_to pair is serliazed by\n     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.\n     */\n    void (*switched_from)(struct rq *this_rq, struct task_struct *task);\n    void (*switched_to)  (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task,\n                  int oldprio);\n\n    unsigned int (*get_rr_interval)(struct rq *rq,\n                    struct task_struct *task);\n\n    void (*update_curr)(struct rq *rq);\n\n#define TASK_SET_GROUP      0\n#define TASK_MOVE_GROUP     1\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n    void (*task_change_group)(struct task_struct *p, int type);\n#endif\n} __aligned(STRUCT_ALIGNMENT); /* STRUCT_ALIGN(), vmlinux.lds.h */\n</code></pre>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#enqueue_task-and-dequeue_task","title":"<code>enqueue_task()</code> and <code>dequeue_task()</code>","text":"<pre><code>/* Called to enqueue task_struct p on runqueue rq. */\nvoid enqueue_task(struct rq *rq, struct task_struct *p, int flags);\n\n/* Called to dequeue task_struct p from runqueue rq. */\nvoid dequeue_task(struct rq *rq, struct task_struct *p, int flags);\n</code></pre> <p><code>enqueue_task()</code> and <code>dequeue_task()</code> are used to put a task on the runqueue and remove a task from the runqueue, respectively.</p> <p>These functions are called for a variety of reasons:</p> <ul> <li> <p>When a child process is first forked, <code>enqueue_task()</code> is called to put it on   a runqueue. When a process exits, <code>dequeue_task()</code> takes it off the runqueue.</p> </li> <li> <p>When a process goes to sleep, <code>dequeue_task()</code> takes it off the runqueue. For   example, this happens when the process needs to wait for a lock or IO event.   When the IO event occurs, or the lock becomes available, the process wakes up.   It must then be re-enqueued with <code>enqueue_task()</code>.</p> </li> <li> <p>Process migration - if a process must be migrated from one CPU's runqueue to   another, it's dequeued from its old runqueue and enqueued on a different one   using this function.</p> </li> <li> <p>When <code>set_cpus_allowed()</code> is called to change the task's processor affinity,   it may need to be enqueued on a different CPU's runqueue.</p> </li> <li> <p>When the priority of a process is boosted to avoid priority inversion. In this   case, the task used to have a low-priority <code>sched_class</code>, but is being   promoted to a <code>sched_class</code> with high priority. This action occurs in   <code>rt_mutex_setprio()</code>.</p> </li> <li> <p>From <code>__sched_setscheduler</code>. If a task's <code>sched_class</code> has changed, it's   dequeued using its old <code>sched_class</code> and enqueued with the new one.</p> </li> </ul> <p>Each of these functions are passed the task to be enqueued/dequeued, as well as the runqueue it should be added to/removed from. In addition, these functions are given a bit vector of flags that describe why enqueue or dequeue is being called. Here are the various flags, which are described in sched.h:</p> <pre><code>/*\n * {de,en}queue flags:\n *\n * DEQUEUE_SLEEP  - task is no longer runnable\n * ENQUEUE_WAKEUP - task just became runnable\n *\n * SAVE/RESTORE - an otherwise spurious dequeue/enqueue, done to ensure tasks\n *                are in a known state which allows modification. Such pairs\n *                should preserve as much state as possible.\n *\n * MOVE - paired with SAVE/RESTORE, explicitly does not preserve the location\n *        in the runqueue.\n *\n * ENQUEUE_HEAD      - place at front of runqueue (tail if not specified)\n * ENQUEUE_REPLENISH - CBS (replenish runtime and postpone deadline)\n * ENQUEUE_MIGRATED  - the task was migrated during wakeup\n *\n */\n</code></pre> <p>The <code>flags</code> argument can be tested using the bitwise <code>&amp;</code> operation. For example, if the task was just migrated from another CPU, <code>flags &amp; ENQUEUE_MIGRATED</code> evaluates to 1.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#pick_next_task","title":"<code>pick_next_task()</code>","text":"<pre><code>/* Pick the task that should be currently running. */\nstruct task_struct *pick_next_task(struct rq *rq);\n</code></pre> <p><code>pick_next_task()</code> is called by the core scheduler to determine which of <code>rq</code>'s tasks should be running. The name is a bit misleading: This function is not supposed to return the task that should run after the currently running task; instead, it's supposed to return the <code>task_struct</code> that should be running now, in this instant.</p> <p>The kernel will context switch from the currently running task to the task returned by <code>pick_next_task()</code>.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#put_prev_task","title":"<code>put_prev_task()</code>","text":"<pre><code>/* Called right before p is going to be taken off the CPU. */\nvoid put_prev_task(struct rq *rq, struct task_struct *p);\n</code></pre> <p><code>put_prev_task()</code> is called whenever a task is to be taken off the CPU. The behavior of this function is up to the specific <code>sched_class</code>. Some schedulers do very little in this function. For example, the realtime scheduler uses this function as an opportunity to perform simple bookkeeping. On the other hand, CFS's <code>put_prev_task_fair()</code> needs to do a bit more work. As an optimization, CFS keeps the currently running task out of its RB tree. It uses the <code>put_prev_task</code> hook as an opportunity to put the currently running task (that is, the task specified by <code>p</code>) back in the RB tree.</p> <p>The sched_class's <code>put_prev_task</code> is called by the function <code>put_prev_task()</code>, which is defined in <code>sched.h</code>. <code>put_prev_task()</code> gets called in the core scheduler's <code>pick_next_task()</code>, after the policy-specific <code>pick_next_task()</code> implementation is called, but before any context switch is performed. This gives us an opportunity to perform any operations we need to do to move on from the previously running task in our scheduler implementations.</p> <p>Note that this was not the case in older kernels: The <code>sched_class</code>'s <code>pick_next_task()</code> is expected to call <code>put_prev_task()</code> by itself! This is documented in the following comment in an earlier Linux version (4.9). Before that (3.11), <code>put_prev_task</code> actually used to be called by the core scheduler before it called <code>pick_next_task</code>.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#task_tick","title":"<code>task_tick()</code>","text":"<pre><code>/* Called from the timer interrupt handler. p is the currently running task\n * and rq is the runqueue that it's on.\n */\nvoid task_tick(struct rq *rq, struct task_struct *p, int queued);\n</code></pre> <p>This is one of the most important scheduler functions. It is called whenever a timer interrupt happens, and its job is to perform bookeeping and set the <code>need_resched</code> flag if the currently-running process needs to be preempted:</p> <p>The <code>need_resched</code> flag can be set by the function <code>resched_curr()</code>, found in core.c:</p> <pre><code>/* Mark rq's currently-running task 'to be rescheduled now'. */\nvoid resched_curr(struct rq *rq)\n</code></pre> <p>With SMP, there's a <code>need_resched</code> flag for every CPU. Thus, <code>resched_curr()</code> might involve sending an APIC inter-processor interrupt to another processor (you don't want to go here). The takeway is that you should just use <code>resched_curr()</code> to set <code>need_resched</code>, and don't try to do this yourself.</p> <p>Note: in prior kernel versions, <code>resched_curr()</code> used to be called <code>resched_task()</code>.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#select_task_rq","title":"<code>select_task_rq()</code>","text":"<pre><code>/* Returns an integer corresponding to the CPU that this task should run on */\nint select_task_rq(struct task_struct *p, int task_cpu, int sd_flag, int flags);\n</code></pre> <p>The core scheduler invokes this function to figure out which CPU to assign a task to. This is used for distributing processes accross multiple CPUs; the core scheduler will call <code>enqueue_task()</code>, passing the runqueue corresponding to the CPU that is returned by this function. CPU assignment obviously occurs when a process is first forked, but CPU reassignment can happen for a large variety of reasons. Here are some instances where <code>select_task_rq()</code> is called:</p> <ul> <li> <p>When a process is first forked.</p> </li> <li> <p>When a task is woken up after having gone to sleep.</p> </li> <li> <p>In response to any of the syscalls in the execv family. This is an   optimization, since it doesn't hurt the cache to migrate a process that's   about to call exec.</p> </li> <li> <p>And many more places...</p> </li> </ul> <p>You can check why <code>select_task_rq</code> was called by looking at <code>sd_flag</code>.</p> <p>For instance, <code>sd_flag == SD_BALANCE_FORK</code> whenever <code>select_task_rq()</code> is called to determine the CPU of a newly forked task. You can find all possible values of <code>sd_flag</code> here.</p> <p>Note that <code>select_task_rq()</code> should return a CPU that <code>p</code> is allowed to run on. Each <code>task_struct</code> has a member called <code>cpus_mask</code>, of type <code>cpumask_t</code>. This member represents the task's CPU affinity - i.e. which CPUs it can run on. It's possible to iterate over these CPUs with the macro <code>for_each_cpu()</code>, defined here.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#set_next_task","title":"<code>set_next_task()</code>","text":"<pre><code>/* Called when a task changes its scheduling class or changes its task group. */\nvoid set_next_task(struct rq *rq, struct task_struct *p, bool first);\n</code></pre> <p>This function is called in the following instances:</p> <ul> <li> <p>When the current task's CPU affinity changes.</p> </li> <li> <p>When the current task's priority, nice value, or scheduling policy changes.</p> </li> <li> <p>When the current task's task group changes.</p> </li> </ul> <p>This function was previously called <code>set_curr_task()</code>, but was changed to better match <code>put_prev_task()</code>. Several scheduling policies also call <code>set_next_task()</code> in their implementations of <code>pick_next_task()</code>. An old kernel commit claims that <code>pick_next_task()</code> implies <code>set_next_task()</code>, but <code>pick_next_task()</code> technically shouldn't modify any state. In practice, this means that <code>set_next_task()</code> ends up just updating some of the task's metadata.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#yield_task","title":"<code>yield_task()</code>","text":"<pre><code>/* Called when the current task yields the cpu */\nvoid yield_task(struct rq *rq);\n</code></pre> <p><code>yield_task()</code> is used when the current process voluntarily yields its remaining time on the CPU. Its implementation is usually very simple, as you can see in rt, which simply requeues the current task.</p> <p>This function is called when a process calls the <code>sched_yield()</code> syscall to relinquish the control of the processor voluntarily. <code>schedule()</code> is then called.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#check_preempt_curr","title":"<code>check_preempt_curr()</code>","text":"<pre><code>/* Preempt the current task with a newly woken task if needed */\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n</code></pre> <p>When a new task enters a runnable state, this function is called to check if that task should preempt the currently running task. For instance, when a new task is created, it is initially woken up with <code>wake_up_new_task()</code>, which (among other things) places the task on the runqueue, calls the generic <code>check_preempt_curr()</code>, and calls the <code>sched_class-&gt;task_woken()</code> function if it exists.</p> <p>The generic <code>check_preempt_curr()</code> function does the following:</p> <pre><code>void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n    if (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class)\n        rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);\n    else if (p-&gt;sched_class &gt; rq-&gt;curr-&gt;sched_class)\n        resched_curr(rq);\n\n    /* CODE OMITTED */\n}   \n</code></pre> <p>This handles both the case where the new task has a higher priority within a scheduling class (using the callback pointer) or a higher priority scheduling class.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#balance","title":"<code>balance()</code>","text":"<pre><code>int balance(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n</code></pre> <p><code>balance()</code> implements various scheduler load-balancing mechanisms, which are meant to distribute the load across processors more evenly using various heuristics. It returns <code>1</code> if there is a runnable task of that <code>sched_class</code>'s priority or higher after load balancing occurs, and <code>0</code> otherwise.</p> <p><code>balance()</code> is called in <code>put_prev_task_balance()</code> (which is called in <code>pick_next_task()</code>) as follows:</p> <pre><code>static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,\n                  struct rq_flags *rf)\n{\n#ifdef CONFIG_SMP\n    const struct sched_class *class;\n    /*\n     * We must do the balancing pass before put_prev_task(), such\n     * that when we release the rq-&gt;lock the task is in the same\n     * state as before we took rq-&gt;lock.\n     *\n     * We can terminate the balance pass as soon as we know there is\n     * a runnable task of @class priority or higher.\n     */\n    for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class) {\n        if (class-&gt;balance(rq, prev, rf))\n            break;\n    }\n#endif\n\n    put_prev_task(rq, prev);\n}\n</code></pre> <p>The main idea is to prevent any runqueue from becoming empty, as this is a waste of resources. This loop starts with the currently running task's <code>sched_class</code> and uses the <code>balance()</code> callbacks to check if there are runnable tasks of that <code>sched_class</code>'s priority or higher. Notably, <code>sched_class</code>'s implementation of <code>balance()</code> checks if <code>sched_class</code>s of higher priority also have runnable tasks.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#update_curr","title":"<code>update_curr()</code>","text":"<pre><code>/* Update the current task's runtime statistics. */\nvoid update_curr(struct rq *rq);\n</code></pre> <p>This function updates the current task's stats such as the total execution time. Implementing this function allows commands like <code>ps</code> and <code>htop</code> to display accurate statistics. The implementations of this function typically share a common segment across the different scheduling classes. This function is typically called in other <code>sched_class</code> functions to facilitate accurate reporting of statistics.</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#prio_changed","title":"<code>prio_changed()</code>","text":"<pre><code>/* Called when the task's priority has changed. */\nvoid prio_changed(struct rq *rq, struct task_struct *p, int oldprio)\n</code></pre> <p>This function is called whenever a task's priority changes, but the <code>sched_class</code> remains the same (you can verify this by checking where the function pointer is called). This can occur through various syscalls which modify the <code>nice</code> value, the priority, or other scheduler attributes.</p> <p>In a scheduler class with priorities, this function will typically check if the task whose priority changed needs to preempt the currently running task (or if it is the currently running task, if it should be preempted).</p>"},{"location":"resources/cs4118recitations/E-Freezer/freezer_sched_class/#switched_to","title":"<code>switched_to()</code>","text":"<pre><code>/* Called when a task gets switched to this scheduling class. */\nvoid switched_to(struct rq *rq, struct task_struct *p);\n</code></pre> <p><code>switched_to()</code> (and its optional counterpart, <code>switched_from()</code>) are called from <code>check_class_changed()</code>:</p> <pre><code>static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n                       const struct sched_class *prev_class,\n                       int oldprio)\n{\n    if (prev_class != p-&gt;sched_class) {\n        if (prev_class-&gt;switched_from)\n            prev_class-&gt;switched_from(rq, p);\n\n        p-&gt;sched_class-&gt;switched_to(rq, p);\n    } else if (oldprio != p-&gt;prio || dl_task(p))\n        p-&gt;sched_class-&gt;prio_changed(rq, p, oldprio);\n}\n</code></pre> <p><code>check_class_changed()</code> gets called from syscalls that modify scheduler parameters.</p> <p>For scheduler classes like rt and dl, the main consideration when a task's policy changes to their policy is that it could overload their runqueue. They then try to push some tasks to other runqueues.</p> <p>However, for lower priority scheduler classes, like CFS, where overloading is not an issue, <code>switched_to()</code> just ensures that the task gets to run, and preempts the current task (which may be of a lower-priority policy) if necessary.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/","title":"Understanding Page Tables in Linux","text":"<p>The goal of this recitation is to provide a high-level overview of x86/arm64 paging as well as the data structures and functions the Linux kernel uses to manipulate page tables.</p> <p>Before we dive into the details, here's a quick refresher on what a page table does and how it does it. Page tables allow the operating system to virtualize the entire address space for each process by providing a mapping between virtual addresses and physical addresses. What is a virtual address? Every address that application code references is a virtual address. For the most part this is true of kernel code as well, except for code that executes before paging is enabled (think bootloader). Once paging is enabled in the CPU it cannot be disabled. Every address referenced by an application is translated transparently by the hardware via the page table.</p> <p>A virtual address is usually different than the physical address it maps to, but it is also possible for virtual addresses to be \"identity\" mapped to their corresponding physical address or mapped to no address at all in cases where the kernel swapped out a page or never allocated one in the first place.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/#the-shape-of-a-page-table","title":"The shape of a page table","text":"<p>Recall that the structure of the page table is rigidly specified by the CPU architecture. This is necessary since the CPU hardware directly traverses the page table to transparently map virtual addresses to physical addresses. The hardware does this by using the virtual address as a set of indices into the page table.</p> <p>Source</p> <p>This diagram shows how the bits of a 64 bit virtual address specify the indices into a 4-level x86 page table (you can expect something similar in arm64). With 4-level paging only bits 0 through 47 are used. Bits 48 through 63 are sign extension bits that must match bit 47; this prevents clever developers from stuffing extra information into addresses that might interfere with future addressing schemes, like 5-level page tables.</p> <p>As you can see, there are 9 bits specifying the index into each page table and a 12 bit offset into the physical page frame. Since 2^9 = 512, each level of the page table has 512 64 bit entries, which fits perfectly in one 4096 byte frame. The last 12 bits allow the virtual address to specify a specific byte offset within the page frame.</p> <p>For clarity, we're using the naming scheme in the diagram (P4, P3,...), which differs slightly from the names used in Linux. Linux also implements 5-level paging, which we describe in the next section. For reference, here is how the names above mapped to Linux before it added 5-level paging:</p> <pre><code>Diagram: P4  -&gt; P3  -&gt; P2  -&gt; P1  -&gt; page frame\nLinux:   PGD -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n</code></pre> <p>Each entry in the P4 table is the address of a different P3 table such that each page table can have up to 512 different P3 tables. In turn, each entry in a P3 table points to a different P2 table such that there are 512 * 512 = 262,144 P2 tables. Since most of the virtual address space is unused for a given process, the kernel does not allocate frames for most of the intermediary tables comprising the page table.</p> <p>I've been using the word frame since each page table entry (in any table, P4, P3, etc) is the address of a physical 4096 byte memory frame (except for huge pages). These addresses cannot be virtual addresses since the hardware accesses them directly to translate virtual addresses to physical addresses. Furthermore, since frames are page aligned, the last 12 bits of a frame address are all zeros. The hardware takes advantage of this by using these bits to store information about the frame in its page table entry.</p> <p>Source</p> <p>This diagram shows the bit flags for a page table entry, which in our diagram above corresponds to an entry in the P1 table. A similar but slightly different set of flags exists for the intermediary entries as well.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/#working-with-page-tables-in-linux","title":"Working with page tables in Linux","text":"<p>In this section we'll take a look at the data structures and functions the Linux kernel defines to manage page tables.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/#the-fifth-level-of-dantes-page-table","title":"The fifth level of Dante's page table","text":"<p>We just finished discussing 4-level page tables, but Linux actually implements 5-level paging and exposes a 5-level paging interface, even when the kernel is built with 5-level paging disabled. Luckily 5-level paging is similar to the 4-level scheme we discussed, is simply adds another level of indirection and uses 9 previously unused bits of the 64 bit virtual address to index it.</p> <p>Here's what the page table hierarchy looks like in Linux:</p> <pre><code>4-Level Paging (circa 2016)\nDiagram Above\n    P4  -&gt; P3  -&gt; P2  -&gt; P1  -&gt; page frame\nLinux\n    PGD -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n\n5-Level Paging (current)\nLinux\n    PGD -&gt; P4D -&gt; PUD -&gt; PMD -&gt; PTE -&gt; page frame\n</code></pre> <p>What does this mean for us in light of the fact that our kernel config specifies 4 level paging?</p> <pre><code>CONFIG_PGTABLE_LEVELS=4\n</code></pre> <p>If we look at the output from an example program that reports the physical addresses of the process' page frame and of the intermediate page tables, it shows that the <code>p4d_paddr</code> and <code>pud_paddr</code> are identical.</p> <pre><code>[405] inspect_physical_address():\npaddr: 0x115a3c069\npf_paddr: 0x115a3c000\npte_paddr: 0x10d2c7000\npmd_paddr: 0x10d623000\npud_paddr: 0x10c215000\np4d_paddr: 0x10c215000\npgd_paddr: 0x10c90a000\ndirty: no\nrefcount: 57\n</code></pre> <p>Digging into <code>arch/x86/include/asm/pgtable_types.h</code>, we see the following:</p> <p><pre><code>#if CONFIG_PGTABLE_LEVELS &gt; 4\ntypedef struct { p4dval_t p4d; } p4d_t;\n\nstatic inline p4d_t native_make_p4d(pudval_t val)\n{\n    return (p4d_t) { val };\n}\n\nstatic inline p4dval_t native_p4d_val(p4d_t p4d)\n{\n    return p4d.p4d;\n}\n#else\n#include &lt;asm-generic/pgtable-nop4d.h&gt;\n\nstatic inline p4d_t native_make_p4d(pudval_t val)\n{\n    return (p4d_t) { .pgd = native_make_pgd((pgdval_t)val) };\n}\n\nstatic inline p4dval_t native_p4d_val(p4d_t p4d)\n{\n    return native_pgd_val(p4d.pgd);\n}\n#endif\n</code></pre> x86 Source</p> <p>Interesting. Looking at <code>pgtable-nop4d.h</code> we find that <code>p4d_t</code> is defined as <pre><code>typedef struct { pgd_t pgd; } p4d_t;\n</code></pre></p> <p>With 4-level paging the p4d folds into the pgd. p4d entries, which are represented by <code>p4d_t</code>, essentially become a type alias for <code>pgd_t</code>. The kernel does this so that it has a standard 5-level page table interface to program against regardless of how many levels of page tables actually exist.</p> <p>As of writing, arm64 (for linux 5.10.158) directly includes <code>pgtable-nop4d.h</code>.</p> <p>To summarize, with 4-level paging there are no \"real\" p4d tables. Instead, pgd entries contain the addresses of pud tables, and the kernel \"pretends\" the p4d exists by making it appear that the p4d is a mirror copy of the pgd.</p> <p>If you read on in <code>arch/x86/include/asm/pgtable_types.h</code> you'll see that the kernel uses the same scheme for 3 and 2 level page table configurations as well. arm64 follows a similar scheme in <code>arch/arm64/include/asm/pgtable-types.h</code></p> <p>NOTE that you cannot make use of this equivalence directly. Your Farfetch'd implementation must work correctly for any page table configuration and therefore must use the macros defined by the kernel.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/#data-structures-functions-and-macros","title":"Data structures, functions, and macros","text":"<p>In this section we'll take a step back and discuss the data structures and functions the kernel uses to manage page tables in more detail.</p> <p>To encapsulate memory management information for each task, <code>struct task_struct</code> contains a <code>struct mm_struct*</code>.</p> <pre><code>struct mm_struct                *mm;\nstruct mm_struct                *active_mm;\n</code></pre> <p>We won't go into the details of <code>active_mm</code>, which is used for kernel threads that do not have their own <code>struct_mm</code>. Check out <code>context_switch()</code> in core.c if you want to read more.</p> <p>Looking in <code>struct mm_struct</code>, we find the member <code>pgd_t *pgd;</code>. This is a pointer to the first entry in the pgd for this <code>mm_struct</code>. Do you think that this is a virtual address or a physical address? Remember that all memory references are translated from virtual addresses to physical addresses by the CPU, so any address the kernel code uses directly must be a virtual address.</p> <p>However, it's easy to recover the physical address since all kernel addresses are linearly mapped to physical addresses. <code>virt_to_phys</code> recovers the physical address using this linear mapping.</p> <p>Section 3.3 in Gordman's chapter on page table management provides a good overview of the functions / macros used to navigate the page table.</p> <p>A common source of confusion arises from a misunderstanding of what macros like <code>pud_offset</code> return. </p> <pre><code>/* Find an entry in the third-level page table.. */\n// From include/linux/pgtable.h. Note that this definition is shared between x86 and arm64.\nstatic inline pud_t *pud_offset(p4d_t *p4d, unsigned long address)\n{\n    return (pud_t *)p4d_page_vaddr(*p4d) + pud_index(address);\n}\n\n// x86: arch/x86/include/asm/pgtable_types.h\n// arm64: arch/arm64/include/asm/pgtable-types.h\ntypedef struct { pudval_t pud; } pud_t;\n\n// x86: arch/x86/include/asm/pgtable_64_types.h\ntypedef unsigned long   pudval_t;\n\n// arm64: arch/arm64/include/asm/pgtable-types.h\ntypedef u64 pudval_t;\n</code></pre> <p>We touched on this briefly above. A <code>pud_t</code> is just a struct containing an unsigned long, which means it compiles down to an unsigned long. Recall from our earlier discussion that each entry is the address of a physical page frame and that the last 12 bits are reserved for flags since each page frame is page aligned. The macros that Gordman discusses, like <code>pte_none()</code> and <code>pmd_present()</code>, check these flag bits to determine information about the entry.</p> <p>If you want to recover the actual value of the entry, the type casting macros Gordman discussed in section 3.2 are useful. Although the Gordman reading is x86-specific, arm64 defines similar, if not indentical, macros. Keep in mind that if you want the physical address the entry points to you'll need to bitwise-and the value with the correct mask.</p> <p>x86 and arm64 either define functions/macros for the mask so you can manually perform the bitwise-and or define function/macros that outright do the correct bitwise-and for you. Either way, recovering the physical address the entry points to is possible in both x86 and arm64, it just may look slightly different depending which architecture you're on and which function/macros you choose.</p>"},{"location":"resources/cs4118recitations/F-Farfetchd/#page-dirty-and-refcount","title":"Page dirty and refcount","text":"<p>Recall from before that a flag in the page table entry indicates whether the page frame is dirty or not. Do not read the flag directly; the kernel provides a macro for this purpose.</p> <p>You will find section 3.4 of Gordman useful for figuring out how to retrieve the refcount of a page frame. Hint: every physical frame has a <code>struct page</code> in the kernel, which is defined here. Be sure to use the correct kernel functions / macros to access any information in <code>struct page</code>.</p>"},{"location":"resources/modern-cpp-features/","title":"C++20/17/14/11","text":""},{"location":"resources/modern-cpp-features/#overview","title":"Overview","text":"<p>C++20 includes the following new language features: - coroutines - concepts - designated initializers - template syntax for lambdas - range-based for loop with initializer - [[likely]] and [[unlikely]] attributes - deprecate implicit capture of this - class types in non-type template parameters - constexpr virtual functions - explicit(bool) - immediate functions - using enum - lambda capture of parameter pack - char8_t - constinit</p> <p>C++20 includes the following new library features: - concepts library - synchronized buffered outputstream - std::span - bit operations - math constants - std::is_constant_evaluated - std::make_shared supports arrays - starts_with and ends_with on strings - check if associative container has element - std::bit_cast - std::midpoint - std::to_array</p> <p>C++17 includes the following new language features: - template argument deduction for class templates - declaring non-type template parameters with auto - folding expressions - new rules for auto deduction from braced-init-list - constexpr lambda - lambda capture this by value - inline variables - nested namespaces - structured bindings - selection statements with initializer - constexpr if - utf-8 character literals - direct-list-initialization of enums - [[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes - __has_include - class template argument deduction</p> <p>C++17 includes the following new library features: - std::variant - std::optional - std::any - std::string_view - std::invoke - std::apply - std::filesystem - std::byte - splicing for maps and sets - parallel algorithms - std::sample - std::clamp - std::reduce - prefix sum algorithms - gcd and lcm - std::not_fn - string conversion to/from numbers</p> <p>C++14 includes the following new language features: - binary literals - generic lambda expressions - lambda capture initializers - return type deduction - decltype(auto) - relaxing constraints on constexpr functions - variable templates - [[deprecated]] attribute</p> <p>C++14 includes the following new library features: - user-defined literals for standard library types - compile-time integer sequences - std::make_unique</p> <p>C++11 includes the following new language features: - move semantics - variadic templates - rvalue references - forwarding references - initializer lists - static assertions - auto - lambda expressions - decltype - type aliases - nullptr - strongly-typed enums - attributes - constexpr - delegating constructors - user-defined literals - explicit virtual overrides - final specifier - default functions - deleted functions - range-based for loops - special member functions for move semantics - converting constructors - explicit conversion functions - inline-namespaces - non-static data member initializers - right angle brackets - ref-qualified member functions - trailing return types - noexcept specifier - char32_t and char16_t - raw string literals</p> <p>C++11 includes the following new library features: - std::move - std::forward - std::thread - std::to_string - type traits - smart pointers - std::chrono - tuples - std::tie - std::array - unordered containers - std::make_shared - std::ref - memory model - std::async - std::begin/end</p>"},{"location":"resources/modern-cpp-features/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"resources/modern-cpp-features/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation: <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited: <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value: <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre></p> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"resources/modern-cpp-features/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form: <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety. <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> There are a variety of syntactic forms for enforcing concepts: <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression: <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <p><pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> * Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</p> <p><pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> * Compound requirements - an expression in braces followed by a trailing return type or type constraint.</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> * Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> See also: concepts library.</p>"},{"location":"resources/modern-cpp-features/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized. <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions. <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem. <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed. <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre></p> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed. <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre></p> <p>It can also be applied to the substatement (body) of an iteration statement. <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>. <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration. <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa. <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>. <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>. <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> After: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> Capture parameter packs by reference: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings. <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time. <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"resources/modern-cpp-features/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts: - <code>same_as</code> - specifies two types are the same. - <code>derived_from</code> - specifies that a type is derived from another type. - <code>convertible_to</code> - specifies that a type is implicitly convertible to another type. - <code>common_with</code> - specifies that two types share a common type. - <code>integral</code> - specifies that a type is an integral type. - <code>default_constructible</code> - specifies that an object of a type can be default-constructed.</p> <p>Comparison concepts: - <code>boolean</code> - specifies that a type can be used in Boolean contexts. - <code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</p> <p>Object concepts: - <code>movable</code> - specifies that an object of a type can be moved and swapped. - <code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped. - <code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed. - <code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</p> <p>Callable concepts: - <code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types. - <code>predicate</code> - specifies that a callable type is a Boolean predicate.</p> <p>See also: concepts.</p>"},{"location":"resources/modern-cpp-features/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output). <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers. <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre></p> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span. <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount. <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header. <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context. <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"resources/modern-cpp-features/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string. <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom. <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another. <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow). <pre><code>std::midpoint(1, 3); // == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>. <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"resources/modern-cpp-features/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors. <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments: <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> * - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"resources/modern-cpp-features/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator. * An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds. * An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both. <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>. <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>. <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference. <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre></p> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions. <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre></p> <p>The code above can be written like this: <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures. <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight. <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition. <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value. <pre><code>char x = u8'x';\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax. <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>. * <code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label. <pre><code>switch (n) {\n  case 1: \n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre></p> <ul> <li> <p><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded. <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre></p> </li> <li> <p><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended. <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre></p> </li> </ul>"},{"location":"resources/modern-cpp-features/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"resources/modern-cpp-features/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments. <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre></p> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable: <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"resources/modern-cpp-features/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless). <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type. <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function. <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments. <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space: <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations. <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"resources/modern-cpp-features/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another: <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre></p> <p>Inserting an entire set: <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre></p> <p>Inserting elements which outlive the container: <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre></p> <p>Changing the key of a map element: <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected. <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound. <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> Additionally you can specify transformations for reducers: <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM). <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function. <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>: <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer: <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"resources/modern-cpp-features/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>. <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas. <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked). <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>. <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> Using this reference-captures can have different names than the referenced variable. <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible. <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not. <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre></p> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"resources/modern-cpp-features/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc. <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"resources/modern-cpp-features/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings. <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"resources/modern-cpp-features/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals. <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top: * <code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>. * <code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</p> <p>Convert an array into a tuple: <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety: <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre></p> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"resources/modern-cpp-features/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing: * <code>T&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></p> <p><code>auto</code> type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre></p> <p>Template type parameter deduction with lvalues and rvalues: <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template. <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre></p> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments. <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function. <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time. <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer. <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre></p> <p>Extremely useful for readability, especially for complicated types: <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre></p> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so: <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"resources/modern-cpp-features/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists: * <code>[]</code> - captures nothing. * <code>[=]</code> - capture local objects (local variables, parameters) in scope by value. * <code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference. * <code>[this]</code> - capture <code>this</code> by reference. * <code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</p> <p><pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty). <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>: <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre></p> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"resources/modern-cpp-features/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates. <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>. <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution. <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc. <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression. <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time: <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre></p> <p>Constant expressions with classes: <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list. <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit: <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre></p> <p>String to integer conversion: <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error. <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from. <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre></p> <p>Class cannot be inherited from. <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor. <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre></p> <p>With inheritance: <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects. <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements. <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre></p> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>: <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves. <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments. <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre></p> <p>Note that the braced list syntax does not allow narrowing: <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre></p> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead: <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier. <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"resources/modern-cpp-features/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"resources/modern-cpp-features/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"resources/modern-cpp-features/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"resources/modern-cpp-features/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types. <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> This feature is especially useful when certain return types cannot be resolved: <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"resources/modern-cpp-features/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings. <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax: <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> where: * <code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces. * <code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</p> <p>Example: <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"resources/modern-cpp-features/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference): <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>Transferring <code>std::unique_ptr</code>s: <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>: <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor: <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre></p> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>. <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types. <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared. <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre></p> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe. <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code: <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>. <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead. <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting. <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers: * <code>unordered_set</code> * <code>unordered_multiset</code> * <code>unordered_map</code> * <code>unordered_multimap</code></p>"},{"location":"resources/modern-cpp-features/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * It provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety: <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> * Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</p> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"resources/modern-cpp-features/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"resources/modern-cpp-features/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be: 1. <code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation. 1. <code>std::launch::async</code> Run the callable object on a new thread. 1. <code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</p> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"resources/modern-cpp-features/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"resources/modern-cpp-features/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended series of books!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> </ul>"},{"location":"resources/modern-cpp-features/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/","title":"Contributing","text":"<p>Before I get started, thank you for contributing! :)</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#issues","title":"Issues","text":"<p>For any typos, errors, or new feature suggestions feel free to open a new issue.</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":"<p>I'm not very picky about how you should contribute, but I ask that the following are met: * Proper spelling and grammar. * If it's a language or library feature that you can write code with, please provide an example of its usage. An optimal submission would also include a short real-world use case for the feature. * Keep additions/deletions of content consistent with the cheatsheet's goals (see below).</p>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#instructions","title":"Instructions","text":"<ul> <li>Make sure the feature is in the correct C++ version file (i.e. CPP11.md, etc.).</li> <li>Make sure you've added the feature to the table of contents.</li> </ul>"},{"location":"resources/modern-cpp-features/CONTRIBUTING/#goals","title":"Goals","text":"<p>My goal for this cheatsheet is to prefer conciseness over absolute completeness. Examples of features should be minimal: if an example is overly complicated, large, or is more of an obscure usage of the feature then it will most likely be rejected in review. The reason for this goal is to teach users what the most popular uses of these features will be, and for a more thorough investigation, to learn about those from external C++ resources.</p>"},{"location":"resources/modern-cpp-features/CPP11/","title":"C++11","text":""},{"location":"resources/modern-cpp-features/CPP11/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++11 includes the following new language features: - move semantics - variadic templates - rvalue references - forwarding references - initializer lists - static assertions - auto - lambda expressions - decltype - type aliases - nullptr - strongly-typed enums - attributes - constexpr - delegating constructors - user-defined literals - explicit virtual overrides - final specifier - default functions - deleted functions - range-based for loops - special member functions for move semantics - converting constructors - explicit conversion functions - inline-namespaces - non-static data member initializers - right angle brackets - ref-qualified member functions - trailing return types - noexcept specifier - char32_t and char16_t - raw string literals</p> <p>C++11 includes the following new library features: - std::move - std::forward - std::thread - std::to_string - type traits - smart pointers - std::chrono - tuples - std::tie - std::array - unordered containers - std::make_shared - std::ref - memory model - std::async - std::begin/end</p>"},{"location":"resources/modern-cpp-features/CPP11/#c11-language-features","title":"C++11 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP11/#move-semantics","title":"Move semantics","text":"<p>Moving an object means to transfer ownership of some resource it manages to another object.</p> <p>The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it's a temporary or by explicitly calling <code>std::move</code>, a move is often a cheaper way to transfer resources. For example, moving a <code>std::vector</code> is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.</p> <p>Moves also make it possible for non-copyable types such as <code>std::unique_ptr</code>s (smart pointers) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.</p> <p>See the sections on: rvalue references, special member functions for move semantics, <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#rvalue-references","title":"Rvalue references","text":"<p>C++11 introduces a new reference termed the rvalue reference. An rvalue reference to <code>T</code>, which is a non-template type parameter (such as <code>int</code>, or a user-defined type), is created with the syntax <code>T&amp;&amp;</code>. Rvalue references only bind to rvalues.</p> <p>Type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nint&amp; xl = x; // `xl` is an lvalue of type `int&amp;`\nint&amp;&amp; xr = x; // compiler error -- `x` is an lvalue\nint&amp;&amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n\nvoid f(int&amp; x) {}\nvoid f(int&amp;&amp; x) {}\n\nf(x);  // calls f(int&amp;)\nf(xl); // calls f(int&amp;)\nf(3);  // calls f(int&amp;&amp;)\nf(std::move(x)); // calls f(int&amp;&amp;)\n\nf(xr2);           // calls f(int&amp;)\nf(std::move(xr2)); // calls f(int&amp;&amp; x)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>forwarding references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#forwarding-references","title":"Forwarding references","text":"<p>Also known (unofficially) as universal references. A forwarding reference is created with the syntax <code>T&amp;&amp;</code> where <code>T</code> is a template type parameter, or using <code>auto&amp;&amp;</code>. This enables perfect forwarding: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).</p> <p>Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of reference collapsing: * <code>T&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp; &amp;&amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;</code> becomes <code>T&amp;</code> * <code>T&amp;&amp; &amp;&amp;</code> becomes <code>T&amp;&amp;</code></p> <p><code>auto</code> type deduction with lvalues and rvalues: <pre><code>int x = 0; // `x` is an lvalue of type `int`\nauto&amp;&amp; al = x; // `al` is an lvalue of type `int&amp;` -- binds to the lvalue, `x`\nauto&amp;&amp; ar = 0; // `ar` is an lvalue of type `int&amp;&amp;` -- binds to the rvalue temporary, `0`\n</code></pre></p> <p>Template type parameter deduction with lvalues and rvalues: <pre><code>// Since C++14 or later:\nvoid f(auto&amp;&amp; t) {\n  // ...\n}\n\n// Since C++11 or later:\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; t) {\n  // ...\n}\n\nint x = 0;\nf(0); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\nf(x); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp; y = x;\nf(y); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\n\nint&amp;&amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;&amp;`.\nf(z); // T is int&amp;, deduces as f(int&amp; &amp;&amp;) =&gt; f(int&amp;)\nf(std::move(z)); // T is int, deduces as f(int &amp;&amp;) =&gt; f(int&amp;&amp;)\n</code></pre></p> <p>See also: <code>std::move</code>, <code>std::forward</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#variadic-templates","title":"Variadic templates","text":"<p>The <code>...</code> syntax creates a parameter pack or expands one. A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a variadic template. <pre><code>template &lt;typename... T&gt;\nstruct arity {\n  constexpr static int value = sizeof...(T);\n};\nstatic_assert(arity&lt;&gt;::value == 0);\nstatic_assert(arity&lt;char, short, int&gt;::value == 3);\n</code></pre></p> <p>An interesting use for this is creating an initializer list from a parameter pack in order to iterate over variadic function arguments. <pre><code>template &lt;typename First, typename... Args&gt;\nauto sum(const First first, const Args... args) -&gt; decltype(first) {\n  const auto values = {first, args...};\n  return std::accumulate(values.begin(), values.end(), First{0});\n}\n\nsum(1, 2, 3, 4, 5); // 15\nsum(1, 2, 3);       // 6\nsum(1.5, 2.0, 3.7); // 7.2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#initializer-lists","title":"Initializer lists","text":"<p>A lightweight array-like container of elements created using a \"braced list\" syntax. For example, <code>{ 1, 2, 3 }</code> creates a sequences of integers, that has type <code>std::initializer_list&lt;int&gt;</code>. Useful as a replacement to passing a vector of objects to a function. <pre><code>int sum(const std::initializer_list&lt;int&gt;&amp; list) {\n  int total = 0;\n  for (auto&amp; e : list) {\n    total += e;\n  }\n\n  return total;\n}\n\nauto list = {1, 2, 3};\nsum(list); // == 6\nsum({1, 2, 3}); // == 6\nsum({}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#static-assertions","title":"Static assertions","text":"<p>Assertions that are evaluated at compile-time. <pre><code>constexpr int x = 0;\nconstexpr int y = 1;\nstatic_assert(x == y, \"x != y\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#auto","title":"auto","text":"<p><code>auto</code>-typed variables are deduced by the compiler according to the type of their initializer. <pre><code>auto a = 3.14; // double\nauto b = 1; // int\nauto&amp; c = b; // int&amp;\nauto d = { 0 }; // std::initializer_list&lt;int&gt;\nauto&amp;&amp; e = 1; // int&amp;&amp;\nauto&amp;&amp; f = b; // int&amp;\nauto g = new auto(123); // int*\nconst auto h = 1; // const int\nauto i = 1, j = 2, k = 3; // int, int, int\nauto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool\nauto o; // error -- `o` requires initializer\n</code></pre></p> <p>Extremely useful for readability, especially for complicated types: <pre><code>std::vector&lt;int&gt; v = ...;\nstd::vector&lt;int&gt;::const_iterator cit = v.cbegin();\n// vs.\nauto cit = v.cbegin();\n</code></pre></p> <p>Functions can also deduce the return type using <code>auto</code>. In C++11, a return type must be specified either explicitly, or using <code>decltype</code> like so: <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2); // == 3\nadd(1, 2.0); // == 3.0\nadd(1.5, 1.5); // == 3.0\n</code></pre> The trailing return type in the above example is the declared type (see section on <code>decltype</code>) of the expression <code>x + y</code>. For example, if <code>x</code> is an integer and <code>y</code> is a double, <code>decltype(x + y)</code> is a double. Therefore, the above function will deduce the type depending on what type the expression <code>x + y</code> yields. Notice that the trailing return type has access to its parameters, and <code>this</code> when appropriate.</p>"},{"location":"resources/modern-cpp-features/CPP11/#lambda-expressions","title":"Lambda expressions","text":"<p>A <code>lambda</code> is an unnamed function object capable of capturing variables in scope. It features: a capture list; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists: * <code>[]</code> - captures nothing. * <code>[=]</code> - capture local objects (local variables, parameters) in scope by value. * <code>[&amp;]</code> - capture local objects (local variables, parameters) in scope by reference. * <code>[this]</code> - capture <code>this</code> by reference. * <code>[a, &amp;b]</code> - capture objects <code>a</code> by value, <code>b</code> by reference.</p> <p><pre><code>int x = 1;\n\nauto getX = [=] { return x; };\ngetX(); // == 1\n\nauto addX = [=](int y) { return x + y; };\naddX(1); // == 2\n\nauto getXRef = [&amp;]() -&gt; int&amp; { return x; };\ngetXRef(); // int&amp; to `x`\n</code></pre> By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as <code>const</code>. The <code>mutable</code> keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty). <pre><code>int x = 1;\n\nauto f1 = [&amp;x] { x = 2; }; // OK: x is a reference and modifies the original\n\nauto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value\n// vs.\nauto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#decltype","title":"decltype","text":"<p><code>decltype</code> is an operator which returns the declared type of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of <code>decltype</code>: <pre><code>int a = 1; // `a` is declared as type `int`\ndecltype(a) b = a; // `decltype(a)` is `int`\nconst int&amp; c = a; // `c` is declared as type `const int&amp;`\ndecltype(c) d = a; // `decltype(c)` is `const int&amp;`\ndecltype(123) e = 123; // `decltype(123)` is `int`\nint&amp;&amp; f = 1; // `f` is declared as type `int&amp;&amp;`\ndecltype(f) g = 1; // `decltype(f) is `int&amp;&amp;`\ndecltype((a)) h = g; // `decltype((a))` is int&amp;\n</code></pre> <pre><code>template &lt;typename X, typename Y&gt;\nauto add(X x, Y y) -&gt; decltype(x + y) {\n  return x + y;\n}\nadd(1, 2.0); // `decltype(x + y)` =&gt; `decltype(3.0)` =&gt; `double`\n</code></pre></p> <p>See also: <code>decltype(auto) (C++14)</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#type-aliases","title":"Type aliases","text":"<p>Semantically similar to using a <code>typedef</code> however, type aliases with <code>using</code> are easier to read and are compatible with templates. <pre><code>template &lt;typename T&gt;\nusing Vec = std::vector&lt;T&gt;;\nVec&lt;int&gt; v; // std::vector&lt;int&gt;\n\nusing String = std::string;\nString s {\"foo\"};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#nullptr","title":"nullptr","text":"<p>C++11 introduces a new null pointer type designed to replace C's <code>NULL</code> macro. <code>nullptr</code> itself is of type <code>std::nullptr_t</code> and can be implicitly converted into pointer types, and unlike <code>NULL</code>, not convertible to integral types except <code>bool</code>. <pre><code>void foo(int);\nvoid foo(char*);\nfoo(NULL); // error -- ambiguous\nfoo(nullptr); // calls foo(char*)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#strongly-typed-enums","title":"Strongly-typed enums","text":"<p>Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution. <pre><code>// Specifying underlying type as `unsigned int`\nenum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };\n// `Red`/`Green` in `Alert` don't conflict with `Color`\nenum class Alert : bool { Red, Green };\nColor c = Color::Red;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#attributes","title":"Attributes","text":"<p>Attributes provide a universal syntax over <code>__attribute__(...)</code>, <code>__declspec</code>, etc. <pre><code>// `noreturn` attribute indicates `f` doesn't return.\n[[ noreturn ]] void f() {\n  throw \"error\";\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#constexpr","title":"constexpr","text":"<p>Constant expressions are expressions that are possibly evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression (these rules are progressively relaxed in later versions). Use the <code>constexpr</code> specifier to indicate the variable, function, etc. is a constant expression. <pre><code>constexpr int square(int x) {\n  return x * x;\n}\n\nint square2(int x) {\n  return x * x;\n}\n\nint a = square(2);  // mov DWORD PTR [rbp-4], 4\n\nint b = square2(2); // mov edi, 2\n                    // call square2(int)\n                    // mov DWORD PTR [rbp-8], eax\n</code></pre> In the previous snippet, notice that the computation when calling <code>square</code> is carried out at compile-time, and then the result is embedded in the code generation, while <code>square2</code> is called at run-time.</p> <p><code>constexpr</code> values are those that the compiler can evaluate, but are not guaranteed to, at compile-time: <pre><code>const int x = 123;\nconstexpr const int&amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression\n</code></pre></p> <p>Constant expressions with classes: <pre><code>struct Complex {\n  constexpr Complex(double r, double i) : re{r}, im{i} { }\n  constexpr double real() { return re; }\n  constexpr double imag() { return im; }\n\nprivate:\n  double re;\n  double im;\n};\n\nconstexpr Complex I(0, 1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#delegating-constructors","title":"Delegating constructors","text":"<p>Constructors can now call other constructors in the same class using an initializer list. <pre><code>struct Foo {\n  int foo;\n  Foo(int foo) : foo{foo} {}\n  Foo() : Foo(0) {}\n};\n\nFoo foo;\nfoo.foo; // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#user-defined-literals","title":"User-defined literals","text":"<p>User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a <code>T operator \"\" X(...) { ... }</code> function that returns a type <code>T</code>, with a name <code>X</code>. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won't be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.</p> <p>Converting Celsius to Fahrenheit: <pre><code>// `unsigned long long` parameter required for integer literal.\nlong long operator \"\" _celsius(unsigned long long tempCelsius) {\n  return std::llround(tempCelsius * 1.8 + 32);\n}\n24_celsius; // == 75\n</code></pre></p> <p>String to integer conversion: <pre><code>// `const char*` and `std::size_t` required as parameters.\nint operator \"\" _int(const char* str, std::size_t) {\n  return std::stoi(str);\n}\n\n\"123\"_int; // == 123, with type `int`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#explicit-virtual-overrides","title":"Explicit virtual overrides","text":"<p>Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent's virtual function, throws a compiler error. <pre><code>struct A {\n  virtual void foo();\n  void bar();\n};\n\nstruct B : A {\n  void foo() override; // correct -- B::foo overrides A::foo\n  void bar() override; // error -- A::bar is not virtual\n  void baz() override; // error -- B::baz does not override A::baz\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#final-specifier","title":"Final specifier","text":"<p>Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from. <pre><code>struct A {\n  virtual void foo();\n};\n\nstruct B : A {\n  virtual void foo() final;\n};\n\nstruct C : B {\n  virtual void foo(); // error -- declaration of 'foo' overrides a 'final' function\n};\n</code></pre></p> <p>Class cannot be inherited from. <pre><code>struct A final {};\nstruct B : A {}; // error -- base 'A' is marked 'final'\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#default-functions","title":"Default functions","text":"<p>A more elegant, efficient way to provide a default implementation of a function, such as a constructor. <pre><code>struct A {\n  A() = default;\n  A(int x) : x{x} {}\n  int x {1};\n};\nA a; // a.x == 1\nA a2 {123}; // a.x == 123\n</code></pre></p> <p>With inheritance: <pre><code>struct B {\n  B() : x{1} {}\n  int x;\n};\n\nstruct C : B {\n  // Calls B::B\n  C() = default;\n};\n\nC c; // c.x == 1\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#deleted-functions","title":"Deleted functions","text":"<p>A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects. <pre><code>class A {\n  int x;\n\npublic:\n  A(int x) : x{x} {};\n  A(const A&amp;) = delete;\n  A&amp; operator=(const A&amp;) = delete;\n};\n\nA x {123};\nA y = x; // error -- call to deleted copy constructor\ny = x; // error -- operator= deleted\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#range-based-for-loops","title":"Range-based for loops","text":"<p>Syntactic sugar for iterating over a container's elements. <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int&amp; x : a) x *= 2;\n// a == { 2, 4, 6, 8, 10 }\n</code></pre></p> <p>Note the difference when using <code>int</code> as opposed to <code>int&amp;</code>: <pre><code>std::array&lt;int, 5&gt; a {1, 2, 3, 4, 5};\nfor (int x : a) x *= 2;\n// a == { 1, 2, 3, 4, 5 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#special-member-functions-for-move-semantics","title":"Special member functions for move semantics","text":"<p>The copy constructor and copy assignment operator are called when copies are made, and with C++11's introduction of move semantics, there is now a move constructor and move assignment operator for moves. <pre><code>struct A {\n  std::string s;\n  A() : s{\"test\"} {}\n  A(const A&amp; o) : s{o.s} {}\n  A(A&amp;&amp; o) : s{std::move(o.s)} {}\n  A&amp; operator=(A&amp;&amp; o) {\n   s = std::move(o.s);\n   return *this;\n  }\n};\n\nA f(A a) {\n  return a;\n}\n\nA a1 = f(A{}); // move-constructed from rvalue temporary\nA a2 = std::move(a1); // move-constructed using std::move\nA a3 = A{};\na2 = std::move(a3); // move-assignment using std::move\na1 = f(A{}); // move-assignment from rvalue temporary\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#converting-constructors","title":"Converting constructors","text":"<p>Converting constructors will convert values of braced list syntax into constructor arguments. <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n};\n\nA a {0, 0}; // calls A::A(int, int)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(int, int)\nA d {0, 0, 0}; // calls A::A(int, int, int)\n</code></pre></p> <p>Note that the braced list syntax does not allow narrowing: <pre><code>struct A {\n  A(int) {}\n};\n\nA a(1.1); // OK\nA b {1.1}; // Error narrowing conversion from double to int\n</code></pre></p> <p>Note that if a constructor accepts a <code>std::initializer_list</code>, it will be called instead: <pre><code>struct A {\n  A(int) {}\n  A(int, int) {}\n  A(int, int, int) {}\n  A(std::initializer_list&lt;int&gt;) {}\n};\n\nA a {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA b(0, 0); // calls A::A(int, int)\nA c = {0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\nA d {0, 0, 0}; // calls A::A(std::initializer_list&lt;int&gt;)\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#explicit-conversion-functions","title":"Explicit conversion functions","text":"<p>Conversion functions can now be made explicit using the <code>explicit</code> specifier. <pre><code>struct A {\n  operator bool() const { return true; }\n};\n\nstruct B {\n  explicit operator bool() const { return true; }\n};\n\nA a;\nif (a); // OK calls A::operator bool()\nbool ba = a; // OK copy-initialization selects A::operator bool()\n\nB b;\nif (b); // OK calls B::operator bool()\nbool bb = b; // error copy-initialization does not consider B::operator bool()\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#inline-namespaces","title":"Inline namespaces","text":"<p>All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C's members can be used as if they were on A.</p> <pre><code>namespace Program {\n  namespace Version1 {\n    int getVersion() { return 1; }\n    bool isFirstVersion() { return true; }\n  }\n  inline namespace Version2 {\n    int getVersion() { return 2; }\n  }\n}\n\nint version {Program::getVersion()};              // Uses getVersion() from Version2\nint oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1\nbool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#non-static-data-member-initializers","title":"Non-static data member initializers","text":"<p>Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.</p> <pre><code>// Default initialization prior to C++11\nclass Human {\n    Human() : age{0} {}\n  private:\n    unsigned age;\n};\n// Default initialization on C++11\nclass Human {\n  private:\n    unsigned age {0};\n};\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#right-angle-brackets","title":"Right angle brackets","text":"<p>C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.</p> <pre><code>typedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt; &gt; &gt; cpp98LongTypedef;\ntypedef std::map&lt;int, std::map &lt;int, std::map &lt;int, int&gt;&gt;&gt;   cpp11LongTypedef;\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#ref-qualified-member-functions","title":"Ref-qualified member functions","text":"<p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p> <pre><code>struct Bar {\n  // ...\n};\n\nstruct Foo {\n  Bar getBar() &amp; { return bar; }\n  Bar getBar() const&amp; { return bar; }\n  Bar getBar() &amp;&amp; { return std::move(bar); }\nprivate:\n  Bar bar;\n};\n\nFoo foo{};\nBar bar = foo.getBar(); // calls `Bar getBar() &amp;`\n\nconst Foo foo2{};\nBar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;`\n\nFoo{}.getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\nstd::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;&amp;`\n\nstd::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;&amp;`\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#trailing-return-types","title":"Trailing return types","text":"<p>C++11 allows functions and lambdas an alternative syntax for specifying their return types. <pre><code>int f() {\n  return 123;\n}\n// vs.\nauto f() -&gt; int {\n  return 123;\n}\n</code></pre> <pre><code>auto g = []() -&gt; int {\n  return 123;\n};\n</code></pre> This feature is especially useful when certain return types cannot be resolved: <pre><code>// NOTE: This does not compile!\ntemplate &lt;typename T, typename U&gt;\ndecltype(a + b) add(T a, U b) {\n    return a + b;\n}\n\n// Trailing return types allows this:\ntemplate &lt;typename T, typename U&gt;\nauto add(T a, U b) -&gt; decltype(a + b) {\n    return a + b;\n}\n</code></pre> In C++14, <code>decltype(auto) (C++14)</code> can be used instead.</p>"},{"location":"resources/modern-cpp-features/CPP11/#noexcept-specifier","title":"Noexcept specifier","text":"<p>The <code>noexcept</code> specifier specifies whether a function could throw exceptions. It is an improved version of <code>throw()</code>.</p> <pre><code>void func1() noexcept;        // does not throw\nvoid func2() noexcept(true);  // does not throw\nvoid func3() throw();         // does not throw\n\nvoid func4() noexcept(false); // may throw\n</code></pre> <p>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.</p> <pre><code>extern void f();  // potentially-throwing\nvoid g() noexcept {\n    f();          // valid, even if f throws\n    throw 42;     // valid, effectively a call to std::terminate\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#char32_t-and-char16_t","title":"char32_t and char16_t","text":"<p>Provides standard types for representing UTF-8 strings. <pre><code>char32_t utf8_str[] = U\"\\u0123\";\nchar16_t utf8_str[] = u\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#raw-string-literals","title":"Raw string literals","text":"<p>C++11 introduces a new way to declare string literals as \"raw string literals\". Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.</p> <p>A raw string literal is declared using the following syntax: <pre><code>R\"delimiter(raw_characters)delimiter\"\n</code></pre> where: * <code>delimiter</code> is an optional sequence of characters made of any source character except parentheses, backslashes and spaces. * <code>raw_characters</code> is any raw character sequence; must not contain the closing sequence <code>\")delimiter\"</code>.</p> <p>Example: <pre><code>// msg1 and msg2 are equivalent.\nconst char* msg1 = \"\\nHello,\\n\\tworld!\\n\";\nconst char* msg2 = R\"(\nHello,\n    world!\n)\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#c11-library-features","title":"C++11 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP11/#stdmove","title":"std::move","text":"<p><code>std::move</code> indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: What can I do with a moved-from object?).</p> <p>A definition of <code>std::move</code> (performing a move is nothing more than casting to an rvalue reference): <pre><code>template &lt;typename T&gt;\ntypename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; arg) {\n  return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>Transferring <code>std::unique_ptr</code>s: <pre><code>std::unique_ptr&lt;int&gt; p1 {new int{0}};  // in practice, use std::make_unique\nstd::unique_ptr&lt;int&gt; p2 = p1; // error -- cannot copy unique pointers\nstd::unique_ptr&lt;int&gt; p3 = std::move(p1); // move `p1` into `p3`\n                                         // now unsafe to dereference object held by `p1`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdforward","title":"std::forward","text":"<p>Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with <code>forwarding references</code>.</p> <p>A definition of <code>std::forward</code>: <pre><code>template &lt;typename T&gt;\nT&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; arg) {\n  return static_cast&lt;T&amp;&amp;&gt;(arg);\n}\n</code></pre></p> <p>An example of a function <code>wrapper</code> which just forwards other <code>A</code> objects to a new <code>A</code> object's copy or move constructor: <pre><code>struct A {\n  A() = default;\n  A(const A&amp; o) { std::cout &lt;&lt; \"copied\" &lt;&lt; std::endl; }\n  A(A&amp;&amp; o) { std::cout &lt;&lt; \"moved\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nA wrapper(T&amp;&amp; arg) {\n  return A{std::forward&lt;T&gt;(arg)};\n}\n\nwrapper(A{}); // moved\nA a;\nwrapper(a); // copied\nwrapper(std::move(a)); // moved\n</code></pre></p> <p>See also: <code>forwarding references</code>, <code>rvalue references</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdthread","title":"std::thread","text":"<p>The <code>std::thread</code> library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.</p> <pre><code>void foo(bool clause) { /* do something... */ }\n\nstd::vector&lt;std::thread&gt; threadsVector;\nthreadsVector.emplace_back([]() {\n  // Lambda function that will be invoked\n});\nthreadsVector.emplace_back(foo, true);  // thread will run foo(true)\nfor (auto&amp; thread : threadsVector) {\n  thread.join(); // Wait for threads to finish\n}\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#stdto_string","title":"std::to_string","text":"<p>Converts a numeric argument to a <code>std::string</code>. <pre><code>std::to_string(1.2); // == \"1.2\"\nstd::to_string(123); // == \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#type-traits","title":"Type traits","text":"<p>Type traits defines a compile-time template-based interface to query or modify the properties of types. <pre><code>static_assert(std::is_integral&lt;int&gt;::value);\nstatic_assert(std::is_same&lt;int, int&gt;::value);\nstatic_assert(std::is_same&lt;std::conditional&lt;true, int, double&gt;::type, int&gt;::value);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#smart-pointers","title":"Smart pointers","text":"<p>C++11 introduces new smart pointers: <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>. <code>std::auto_ptr</code> now becomes deprecated and then eventually removed in C++17.</p> <p><code>std::unique_ptr</code> is a non-copyable, movable pointer that manages its own heap-allocated memory. Note: Prefer using the <code>std::make_X</code> helper functions as opposed to using constructors. See the sections for std::make_unique and std::make_shared. <pre><code>std::unique_ptr&lt;Foo&gt; p1 { new Foo{} };  // `p1` owns `Foo`\nif (p1) {\n  p1-&gt;bar();\n}\n\n{\n  std::unique_ptr&lt;Foo&gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`\n  f(*p2);\n\n  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed\n}\n\nif (p1) {\n  p1-&gt;bar();\n}\n// `Foo` instance is destroyed when `p1` goes out of scope\n</code></pre></p> <p>A <code>std::shared_ptr</code> is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a control block which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe. <pre><code>void foo(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid bar(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nvoid baz(std::shared_ptr&lt;T&gt; t) {\n  // Do something with `t`...\n}\n\nstd::shared_ptr&lt;T&gt; p1 {new T{}};\n// Perhaps these take place in another threads?\nfoo(p1);\nbar(p1);\nbaz(p1);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdchrono","title":"std::chrono","text":"<p>The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points. One use case of this library is benchmarking code: <pre><code>std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;\nstart = std::chrono::steady_clock::now();\n// Some computations...\nend = std::chrono::steady_clock::now();\n\nstd::chrono::duration&lt;double&gt; elapsed_seconds = end - start;\ndouble t = elapsed_seconds.count(); // t number of seconds, represented as a `double`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#tuples","title":"Tuples","text":"<p>Tuples are a fixed-size collection of heterogeneous values. Access the elements of a <code>std::tuple</code> by unpacking using <code>std::tie</code>, or using <code>std::get</code>. <pre><code>// `playerProfile` has type `std::tuple&lt;int, const char*, const char*&gt;`.\nauto playerProfile = std::make_tuple(51, \"Frans Nielsen\", \"NYI\");\nstd::get&lt;0&gt;(playerProfile); // 51\nstd::get&lt;1&gt;(playerProfile); // \"Frans Nielsen\"\nstd::get&lt;2&gt;(playerProfile); // \"NYI\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdtie","title":"std::tie","text":"<p>Creates a tuple of lvalue references. Useful for unpacking <code>std::pair</code> and <code>std::tuple</code> objects. Use <code>std::ignore</code> as a placeholder for ignored values. In C++17, structured bindings should be used instead. <pre><code>// With tuples...\nstd::string playerName;\nstd::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, \"John Tavares\", \"NYI\");\n\n// With pairs...\nstd::string yes, no;\nstd::tie(yes, no) = std::make_pair(\"yes\", \"no\");\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdarray","title":"std::array","text":"<p><code>std::array</code> is a container built on top of a C-style array. Supports common container operations such as sorting. <pre><code>std::array&lt;int, 3&gt; a = {2, 1, 3};\nstd::sort(a.begin(), a.end()); // a == { 1, 2, 3 }\nfor (int&amp; x : a) x *= 2; // a == { 2, 4, 6 }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP11/#unordered-containers","title":"Unordered containers","text":"<p>These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers: * <code>unordered_set</code> * <code>unordered_multiset</code> * <code>unordered_map</code> * <code>unordered_multimap</code></p>"},{"location":"resources/modern-cpp-features/CPP11/#stdmake_shared","title":"std::make_shared","text":"<p><code>std::make_shared</code> is the recommended way to create instances of <code>std::shared_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * It provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::shared_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::shared_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_shared</code>, we are given exception-safety: <pre><code>foo(std::make_shared&lt;T&gt;(), function_that_throws(), std::make_shared&lt;T&gt;());\n</code></pre> * Prevents having to do two allocations. When calling <code>std::shared_ptr{ new T{} }</code>, we have to allocate memory for <code>T</code>, then in the shared pointer we have to allocate memory for the control block within the pointer.</p> <p>See the section on smart pointers for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdref","title":"std::ref","text":"<p><code>std::ref(val)</code> is used to create object of type <code>std::reference_wrapper</code> that holds reference of val. Used in cases when usual reference passing using <code>&amp;</code> does not compile or <code>&amp;</code> is dropped due to type deduction. <code>std::cref</code> is similar but created reference wrapper holds a const reference to val.</p> <pre><code>// create a container to store reference of objects.\nauto val = 99;\nauto _ref = std::ref(val);\n_ref++;\nauto _cref = std::cref(val);\n//_cref++; does not compile\nstd::vector&lt;std::reference_wrapper&lt;int&gt;&gt;vec; // vector&lt;int&amp;&gt;vec does not compile\nvec.push_back(_ref); // vec.push_back(&amp;i) does not compile\ncout &lt;&lt; val &lt;&lt; endl; // prints 100\ncout &lt;&lt; vec[0] &lt;&lt; endl; // prints 100\ncout &lt;&lt; _cref; // prints 100\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#memory-model","title":"Memory model","text":"<p>C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren't limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.</p> <p>See the sections on: std::thread</p>"},{"location":"resources/modern-cpp-features/CPP11/#stdasync","title":"std::async","text":"<p><code>std::async</code> runs the given function either asynchronously or lazily-evaluated, then returns a <code>std::future</code> which holds the result of that function call.</p> <p>The first parameter is the policy which can be: 1. <code>std::launch::async | std::launch::deferred</code> It is up to the implementation whether to perform asynchronous execution or lazy evaluation. 1. <code>std::launch::async</code> Run the callable object on a new thread. 1. <code>std::launch::deferred</code> Perform lazy evaluation on the current thread.</p> <pre><code>int foo() {\n  /* Do something here, then return the result. */\n  return 1000;\n}\n\nauto handle = std::async(std::launch::async, foo);  // create an async task\nauto result = handle.get();  // wait for the result\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#stdbeginend","title":"std::begin/end","text":"<p><code>std::begin</code> and <code>std::end</code> free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have <code>begin</code> and <code>end</code> member functions.</p> <pre><code>template &lt;typename T&gt;\nint CountTwos(const T&amp; container) {\n  return std::count_if(std::begin(container), std::end(container), [](int item) {\n    return item == 2;\n  });\n}\n\nstd::vector&lt;int&gt; vec = {2, 2, 43, 435, 4543, 534};\nint arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};\nauto a = CountTwos(vec); // 2\nauto b = CountTwos(arr);  // 1\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP11/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP11/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP11/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP11/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP14/","title":"C++14","text":""},{"location":"resources/modern-cpp-features/CPP14/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++14 includes the following new language features: - binary literals - generic lambda expressions - lambda capture initializers - return type deduction - decltype(auto) - relaxing constraints on constexpr functions - variable templates - [[deprecated]] attribute</p> <p>C++14 includes the following new library features: - user-defined literals for standard library types - compile-time integer sequences - std::make_unique</p>"},{"location":"resources/modern-cpp-features/CPP14/#c14-language-features","title":"C++14 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP14/#binary-literals","title":"Binary literals","text":"<p>Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with <code>'</code>. <pre><code>0b110 // == 6\n0b1111'1111 // == 255\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#generic-lambda-expressions","title":"Generic lambda expressions","text":"<p>C++14 now allows the <code>auto</code> type-specifier in the parameter list, enabling polymorphic lambdas. <pre><code>auto identity = [](auto x) { return x; };\nint three = identity(3); // == 3\nstd::string foo = identity(\"foo\"); // == \"foo\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#lambda-capture-initializers","title":"Lambda capture initializers","text":"<p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked). <pre><code>int factory(int i) { return i * 10; }\nauto f = [x = factory(2)] { return x; }; // returns 20\n\nauto generator = [x = 0] () mutable {\n  // this would not compile without 'mutable' as we are modifying x on each call\n  return x++;\n};\nauto a = generator(); // == 0\nauto b = generator(); // == 1\nauto c = generator(); // == 2\n</code></pre> Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <code>p</code> in the capture-list of <code>task2</code> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <code>p</code>. <pre><code>auto p = std::make_unique&lt;int&gt;(1);\n\nauto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied\n// vs.\nauto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object\n// the original p is empty after task2 is created\n</code></pre> Using this reference-captures can have different names than the referenced variable. <pre><code>auto x = 1;\nauto f = [&amp;r = x, x = x * 10] {\n  ++r;\n  return r + x;\n};\nf(); // sets x to 2 and returns 12\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#return-type-deduction","title":"Return type deduction","text":"<p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible. <pre><code>// Deduce return type as `int`.\nauto f(int i) {\n return i;\n}\n</code></pre> <pre><code>template &lt;typename T&gt;\nauto&amp; f(T&amp; t) {\n  return t;\n}\n\n// Returns a reference to a deduced type.\nauto g = [](auto&amp; x) -&gt; auto&amp; { return f(x); };\nint y = 123;\nint&amp; z = g(y); // reference to `y`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#decltypeauto","title":"decltype(auto)","text":"<p>The <code>decltype(auto)</code> type-specifier also deduces a type like <code>auto</code> does. However, it deduces return types while keeping their references and cv-qualifiers, while <code>auto</code> will not. <pre><code>const int x = 0;\nauto x1 = x; // int\ndecltype(auto) x2 = x; // const int\nint y = 0;\nint&amp; y1 = y;\nauto y2 = y1; // int\ndecltype(auto) y3 = y1; // int&amp;\nint&amp;&amp; z = 0;\nauto z1 = std::move(z); // int\ndecltype(auto) z2 = std::move(z); // int&amp;&amp;\n</code></pre> <pre><code>// Note: Especially useful for generic code!\n\n// Return type is `int`.\nauto f(const int&amp; i) {\n return i;\n}\n\n// Return type is `const int&amp;`.\ndecltype(auto) g(const int&amp; i) {\n return i;\n}\n\nint x = 123;\nstatic_assert(std::is_same&lt;const int&amp;, decltype(f(x))&gt;::value == 0);\nstatic_assert(std::is_same&lt;int, decltype(f(x))&gt;::value == 1);\nstatic_assert(std::is_same&lt;const int&amp;, decltype(g(x))&gt;::value == 1);\n</code></pre></p> <p>See also: <code>decltype (C++11)</code>.</p>"},{"location":"resources/modern-cpp-features/CPP14/#relaxing-constraints-on-constexpr-functions","title":"Relaxing constraints on constexpr functions","text":"<p>In C++11, <code>constexpr</code> function bodies could only contain a very limited set of syntaxes, including (but not limited to): <code>typedef</code>s, <code>using</code>s, and a single <code>return</code> statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as <code>if</code> statements, multiple <code>return</code>s, loops, etc. <pre><code>constexpr int factorial(int n) {\n  if (n &lt;= 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\nfactorial(5); // == 120\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#variable-templates","title":"Variable templates","text":"<p>C++14 allows variables to be templated:</p> <pre><code>template&lt;class T&gt;\nconstexpr T pi = T(3.1415926535897932385);\ntemplate&lt;class T&gt;\nconstexpr T e  = T(2.7182818284590452353);\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP14/#deprecated-attribute","title":"[[deprecated]] attribute","text":"<p>C++14 introduces the <code>[[deprecated]]</code> attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings. <pre><code>[[deprecated]]\nvoid old_method();\n[[deprecated(\"Use new_method instead\")]]\nvoid legacy_method();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#c14-library-features","title":"C++14 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP14/#user-defined-literals-for-standard-library-types","title":"User-defined literals for standard library types","text":"<p>New user-defined literals for standard library types, including new built-in literals for <code>chrono</code> and <code>basic_string</code>. These can be <code>constexpr</code> meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals. <pre><code>using namespace std::chrono_literals;\nauto day = 24h;\nday.count(); // == 24\nstd::chrono::duration_cast&lt;std::chrono::minutes&gt;(day).count(); // == 1440\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#compile-time-integer-sequences","title":"Compile-time integer sequences","text":"<p>The class template <code>std::integer_sequence</code> represents a compile-time sequence of integers. There are a few helpers built on top: * <code>std::make_integer_sequence&lt;T, N&gt;</code> - creates a sequence of <code>0, ..., N - 1</code> with type <code>T</code>. * <code>std::index_sequence_for&lt;T...&gt;</code> - converts a template parameter pack into an integer sequence.</p> <p>Convert an array into a tuple: <pre><code>template&lt;typename Array, std::size_t... I&gt;\ndecltype(auto) a2t_impl(const Array&amp; a, std::integer_sequence&lt;std::size_t, I...&gt;) {\n  return std::make_tuple(a[I]...);\n}\n\ntemplate&lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&lt;N&gt;&gt;\ndecltype(auto) a2t(const std::array&lt;T, N&gt;&amp; a) {\n  return a2t_impl(a, Indices());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP14/#stdmake_unique","title":"std::make_unique","text":"<p><code>std::make_unique</code> is the recommended way to create instances of <code>std::unique_ptr</code>s due to the following reasons: * Avoid having to use the <code>new</code> operator. * Prevents code repetition when specifying the underlying type the pointer shall hold. * Most importantly, it provides exception-safety. Suppose we were calling a function <code>foo</code> like so: <pre><code>foo(std::unique_ptr&lt;T&gt;{new T{}}, function_that_throws(), std::unique_ptr&lt;T&gt;{new T{}});\n</code></pre> The compiler is free to call <code>new T{}</code>, then <code>function_that_throws()</code>, and so on... Since we have allocated data on the heap in the first construction of a <code>T</code>, we have introduced a leak here. With <code>std::make_unique</code>, we are given exception-safety: <pre><code>foo(std::make_unique&lt;T&gt;(), function_that_throws(), std::make_unique&lt;T&gt;());\n</code></pre></p> <p>See the section on smart pointers (C++11) for more information on <code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</p>"},{"location":"resources/modern-cpp-features/CPP14/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP14/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP14/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP14/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP17/","title":"C++17","text":""},{"location":"resources/modern-cpp-features/CPP17/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++17 includes the following new language features: - template argument deduction for class templates - declaring non-type template parameters with auto - folding expressions - new rules for auto deduction from braced-init-list - constexpr lambda - lambda capture this by value - inline variables - nested namespaces - structured bindings - selection statements with initializer - constexpr if - utf-8 character literals - direct-list-initialization of enums - [[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes - __has_include - class template argument deduction</p> <p>C++17 includes the following new library features: - std::variant - std::optional - std::any - std::string_view - std::invoke - std::apply - std::filesystem - std::byte - splicing for maps and sets - parallel algorithms - std::sample - std::clamp - std::reduce - prefix sum algorithms - gcd and lcm - std::not_fn - string conversion to/from numbers</p>"},{"location":"resources/modern-cpp-features/CPP17/#c17-language-features","title":"C++17 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP17/#template-argument-deduction-for-class-templates","title":"Template argument deduction for class templates","text":"<p>Automatic template argument deduction much like how it's done for functions, but now including class constructors. <pre><code>template &lt;typename T = float&gt;\nstruct MyContainer {\n  T val;\n  MyContainer() : val{} {}\n  MyContainer(T val) : val{val} {}\n  // ...\n};\nMyContainer c1 {1}; // OK MyContainer&lt;int&gt;\nMyContainer c2; // OK MyContainer&lt;float&gt;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#declaring-non-type-template-parameters-with-auto","title":"Declaring non-type template parameters with auto","text":"<p>Following the deduction rules of <code>auto</code>, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments: <pre><code>template &lt;auto... seq&gt;\nstruct my_integer_sequence {\n  // Implementation here ...\n};\n\n// Explicitly pass type `int` as template argument.\nauto seq = std::integer_sequence&lt;int, 0, 1, 2&gt;();\n// Type is deduced to be `int`.\nauto seq2 = my_integer_sequence&lt;0, 1, 2&gt;();\n</code></pre> * - For example, you cannot use a <code>double</code> as a template parameter type, which also makes this an invalid deduction using <code>auto</code>.</p>"},{"location":"resources/modern-cpp-features/CPP17/#folding-expressions","title":"Folding expressions","text":"<p>A fold expression performs a fold of a template parameter pack over a binary operator. * An expression of the form <code>(... op e)</code> or <code>(e op ...)</code>, where <code>op</code> is a fold-operator and <code>e</code> is an unexpanded parameter pack, are called unary folds. * An expression of the form <code>(e1 op ... op e2)</code>, where <code>op</code> are fold-operators, is called a binary fold. Either <code>e1</code> or <code>e2</code> is an unexpanded parameter pack, but not both. <pre><code>template &lt;typename... Args&gt;\nbool logicalAnd(Args... args) {\n    // Binary folding.\n    return (true &amp;&amp; ... &amp;&amp; args);\n}\nbool b = true;\nbool&amp; b2 = b;\nlogicalAnd(b, b2, true); // == true\n</code></pre> <pre><code>template &lt;typename... Args&gt;\nauto sum(Args... args) {\n    // Unary folding.\n    return (... + args);\n}\nsum(1.0, 2.0f, 3); // == 6.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#new-rules-for-auto-deduction-from-braced-init-list","title":"New rules for auto deduction from braced-init-list","text":"<p>Changes to <code>auto</code> deduction when used with the uniform initialization syntax. Previously, <code>auto x {3};</code> deduces a <code>std::initializer_list&lt;int&gt;</code>, which now deduces to <code>int</code>. <pre><code>auto x1 {1, 2, 3}; // error: not a single element\nauto x2 = {1, 2, 3}; // x2 is std::initializer_list&lt;int&gt;\nauto x3 {3}; // x3 is int\nauto x4 {3.0}; // x4 is double\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#constexpr-lambda","title":"constexpr lambda","text":"<p>Compile-time lambdas using <code>constexpr</code>. <pre><code>auto identity = [](int n) constexpr { return n; };\nstatic_assert(identity(123) == 123);\n</code></pre> <pre><code>constexpr auto add = [](int x, int y) {\n  auto L = [=] { return x; };\n  auto R = [=] { return y; };\n  return [=] { return L() + R(); };\n};\n\nstatic_assert(add(1, 2)() == 3);\n</code></pre> <pre><code>constexpr int addOne(int n) {\n  return [n] { return n + 1; }();\n}\n\nstatic_assert(addOne(1) == 2);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#lambda-capture-this-by-value","title":"Lambda capture <code>this</code> by value","text":"<p>Capturing <code>this</code> in a lambda's environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. <code>*this</code> (C++17) will now make a copy of the current object, while <code>this</code> (C++11) continues to capture by reference. <pre><code>struct MyObj {\n  int value {123};\n  auto getValueCopy() {\n    return [*this] { return value; };\n  }\n  auto getValueRef() {\n    return [this] { return value; };\n  }\n};\nMyObj mo;\nauto valueCopy = mo.getValueCopy();\nauto valueRef = mo.getValueRef();\nmo.value = 321;\nvalueCopy(); // 123\nvalueRef(); // 321\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#inline-variables","title":"Inline variables","text":"<p>The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline. <pre><code>// Disassembly example using compiler explorer.\nstruct S { int x; };\ninline S x1 = S{321}; // mov esi, dword ptr [x1]\n                      // x1: .long 321\n\nS x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]\n                      // mov dword ptr [rbp - 8], eax\n                      // .L_ZZ4mainE2x2: .long 123\n</code></pre></p> <p>It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file. <pre><code>struct S {\n  S() : id{count++} {}\n  ~S() { count--; }\n  int id;\n  static inline int count{0}; // declare and initialize count to 0 within the class\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#nested-namespaces","title":"Nested namespaces","text":"<p>Using the namespace resolution operator to create nested namespace definitions. <pre><code>namespace A {\n  namespace B {\n    namespace C {\n      int i;\n    }\n  }\n}\n</code></pre></p> <p>The code above can be written like this: <pre><code>namespace A::B::C {\n  int i;\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#structured-bindings","title":"Structured bindings","text":"<p>A proposal for de-structuring initialization, that would allow writing <code>auto [ x, y, z ] = expr;</code> where the type of <code>expr</code> was a tuple-like object, whose elements would be bound to the variables <code>x</code>, <code>y</code>, and <code>z</code> (which this construct declares). Tuple-like objects include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and aggregate structures. <pre><code>using Coordinate = std::pair&lt;int, int&gt;;\nCoordinate origin() {\n  return Coordinate{0, 0};\n}\n\nconst auto [ x, y ] = origin();\nx; // == 0\ny; // == 0\n</code></pre> <pre><code>std::unordered_map&lt;std::string, int&gt; mapping {\n  {\"a\", 1},\n  {\"b\", 2},\n  {\"c\", 3}\n};\n\n// Destructure by reference.\nfor (const auto&amp; [key, value] : mapping) {\n  // Do something with key and value\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#selection-statements-with-initializer","title":"Selection statements with initializer","text":"<p>New versions of the <code>if</code> and <code>switch</code> statements which simplify common code patterns and help users keep scopes tight. <pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lk(mx);\n  if (v.empty()) v.push_back(val);\n}\n// vs.\nif (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {\n  v.push_back(val);\n}\n</code></pre> <pre><code>Foo gadget(args);\nswitch (auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n// vs.\nswitch (Foo gadget(args); auto s = gadget.status()) {\n  case OK: gadget.zip(); break;\n  case Bad: throw BadFoo(s.message());\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#constexpr-if","title":"constexpr if","text":"<p>Write code that is instantiated depending on a compile-time condition. <pre><code>template &lt;typename T&gt;\nconstexpr bool isIntegral() {\n  if constexpr (std::is_integral&lt;T&gt;::value) {\n    return true;\n  } else {\n    return false;\n  }\n}\nstatic_assert(isIntegral&lt;int&gt;() == true);\nstatic_assert(isIntegral&lt;char&gt;() == true);\nstatic_assert(isIntegral&lt;double&gt;() == false);\nstruct S {};\nstatic_assert(isIntegral&lt;S&gt;() == false);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#utf-8-character-literals","title":"UTF-8 character literals","text":"<p>A character literal that begins with <code>u8</code> is a character literal of type <code>char</code>. The value of a UTF-8 character literal is equal to its ISO 10646 code point value. <pre><code>char x = u8'x';\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#direct-list-initialization-of-enums","title":"Direct list initialization of enums","text":"<p>Enums can now be initialized using braced syntax. <pre><code>enum byte : unsigned char {};\nbyte b {0}; // OK\nbyte c {-1}; // ERROR\nbyte d = byte{1}; // OK\nbyte e = byte{256}; // ERROR\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#fallthrough-nodiscard-maybe_unused-attributes","title":"[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes","text":"<p>C++17 introduces three new attributes: <code>[[fallthrough]]</code>, <code>[[nodiscard]]</code> and <code>[[maybe_unused]]</code>. * <code>[[fallthrough]]</code> indicates to the compiler that falling through in a switch statement is intended behavior. This attribute may only be used in a switch statement, and must be placed before the next case/default label. <pre><code>switch (n) {\n  case 1: \n    // ...\n    [[fallthrough]];\n  case 2:\n    // ...\n    break;\n  case 3:\n    // ...\n    [[fallthrough]];\n  default:\n    // ...\n}\n</code></pre></p> <ul> <li> <p><code>[[nodiscard]]</code> issues a warning when either a function or class has this attribute and its return value is discarded. <pre><code>[[nodiscard]] bool do_something() {\n  return is_success; // true for success, false for failure\n}\n\ndo_something(); // warning: ignoring return value of 'bool do_something()',\n                // declared with attribute 'nodiscard'\n</code></pre> <pre><code>// Only issues a warning when `error_info` is returned by value.\nstruct [[nodiscard]] error_info {\n  // ...\n};\n\nerror_info do_something() {\n  error_info ei;\n  // ...\n  return ei;\n}\n\ndo_something(); // warning: ignoring returned value of type 'error_info',\n                // declared with attribute 'nodiscard'\n</code></pre></p> </li> <li> <p><code>[[maybe_unused]]</code> indicates to the compiler that a variable or parameter might be unused and is intended. <pre><code>void my_callback(std::string msg, [[maybe_unused]] bool error) {\n  // Don't care if `msg` is an error message, just log it.\n  log(msg);\n}\n</code></pre></p> </li> </ul>"},{"location":"resources/modern-cpp-features/CPP17/#__has_include","title":"__has_include","text":"<p><code>__has_include (operand)</code> operator may be used in <code>#if</code> and <code>#elif</code> expressions to check whether a header or source file (<code>operand</code>) is available for inclusion or not.</p> <p>One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;optional&gt;)\n#    include &lt;optional&gt;\n#    define have_optional 1\n#  elif __has_include(&lt;experimental/optional&gt;)\n#    include &lt;experimental/optional&gt;\n#    define have_optional 1\n#    define experimental_optional\n#  else\n#    define have_optional 0\n#  endif\n#endif\n</code></pre> <p>It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in <code>OpenGL\\</code> directory on macOS and <code>GL\\</code> on other platforms.</p> <pre><code>#ifdef __has_include\n#  if __has_include(&lt;OpenGL/gl.h&gt;)\n#    include &lt;OpenGL/gl.h&gt;\n#    include &lt;OpenGL/glu.h&gt;\n#  elif __has_include(&lt;GL/gl.h&gt;)\n#    include &lt;GL/gl.h&gt;\n#    include &lt;GL/glu.h&gt;\n#  else\n#    error No suitable OpenGL headers found.\n# endif\n#endif\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP17/#class-template-argument-deduction","title":"Class template argument deduction","text":"<p>Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments. <pre><code>std::vector v{ 1, 2, 3 }; // deduces std::vector&lt;int&gt;\n\nstd::mutex mtx;\nauto lck = std::lock_guard{ mtx }; // deduces to std::lock_guard&lt;std::mutex&gt;\n\nauto p = new std::pair{ 1.0, 2.0 }; // deduces to std::pair&lt;double, double&gt;\n</code></pre></p> <p>For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable: <pre><code>template &lt;typename T&gt;\nstruct container {\n  container(T t) {}\n\n  template &lt;typename Iter&gt;\n  container(Iter beg, Iter end);\n};\n\n// deduction guide\ntemplate &lt;typename Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\ncontainer a{ 7 }; // OK: deduces container&lt;int&gt;\n\nstd::vector&lt;double&gt; v{ 1.0, 2.0, 3.0 };\nauto b = container{ v.begin(), v.end() }; // OK: deduces container&lt;double&gt;\n\ncontainer c{ 5, 6 }; // ERROR: std::iterator_traits&lt;int&gt;::value_type is not a type\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#c17-library-features","title":"C++17 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP17/#stdvariant","title":"std::variant","text":"<p>The class template <code>std::variant</code> represents a type-safe <code>union</code>. An instance of <code>std::variant</code> at any given time holds a value of one of its alternative types (it's also possible for it to be valueless). <pre><code>std::variant&lt;int, double&gt; v{ 12 };\nstd::get&lt;int&gt;(v); // == 12\nstd::get&lt;0&gt;(v); // == 12\nv = 12.0;\nstd::get&lt;double&gt;(v); // == 12.0\nstd::get&lt;1&gt;(v); // == 12.0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdoptional","title":"std::optional","text":"<p>The class template <code>std::optional</code> manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail. <pre><code>std::optional&lt;std::string&gt; create(bool b) {\n  if (b) {\n    return \"Godzilla\";\n  } else {\n    return {};\n  }\n}\n\ncreate(false).value_or(\"empty\"); // == \"empty\"\ncreate(true).value(); // == \"Godzilla\"\n// optional-returning factory functions are usable as conditions of while and if\nif (auto str = create(true)) {\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdany","title":"std::any","text":"<p>A type-safe container for single values of any type. <pre><code>std::any x {5};\nx.has_value() // == true\nstd::any_cast&lt;int&gt;(x) // == 5\nstd::any_cast&lt;int&amp;&gt;(x) = 10;\nstd::any_cast&lt;int&gt;(x) // == 10\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdstring_view","title":"std::string_view","text":"<p>A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing). <pre><code>// Regular strings.\nstd::string_view cppstr {\"foo\"};\n// Wide strings.\nstd::wstring_view wcstr_v {L\"baz\"};\n// Character arrays.\nchar array[3] = {'b', 'a', 'r'};\nstd::string_view array_v(array, std::size(array));\n</code></pre> <pre><code>std::string str {\"   trim me\"};\nstd::string_view v {str};\nv.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\nstr; //  == \"   trim me\"\nv; // == \"trim me\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdinvoke","title":"std::invoke","text":"<p>Invoke a <code>Callable</code> object with parameters. Examples of callable objects are <code>std::function</code> or lambdas; objects that can be called similarly to a regular function. <pre><code>template &lt;typename Callable&gt;\nclass Proxy {\n  Callable c_;\n\npublic:\n  Proxy(Callable c) : c_{ std::move(c) } {}\n\n  template &lt;typename... Args&gt;\n  decltype(auto) operator()(Args&amp;&amp;... args) {\n    // ...\n    return std::invoke(c_, std::forward&lt;Args&gt;(args)...);\n  }\n};\n\nconst auto add = [](int x, int y) { return x + y; };\nProxy p{ add };\np(1, 2); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdapply","title":"std::apply","text":"<p>Invoke a <code>Callable</code> object with a tuple of arguments. <pre><code>auto add = [](int x, int y) {\n  return x + y;\n};\nstd::apply(add, std::make_tuple(1, 2)); // == 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdfilesystem","title":"std::filesystem","text":"<p>The new <code>std::filesystem</code> library provides a standard way to manipulate files, directories, and paths in a filesystem.</p> <p>Here, a big file is copied to a temporary path if there is available space: <pre><code>const auto bigFilePath {\"bigFileToCopy\"};\nif (std::filesystem::exists(bigFilePath)) {\n  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};\n  std::filesystem::path tmpPath {\"/tmp\"};\n  if (std::filesystem::space(tmpPath).available &gt; bigFileSize) {\n    std::filesystem::create_directory(tmpPath.append(\"example\"));\n    std::filesystem::copy_file(bigFilePath, tmpPath.append(\"newFile\"));\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdbyte","title":"std::byte","text":"<p>The new <code>std::byte</code> type provides a standard way of representing data as a byte. Benefits of using <code>std::byte</code> over <code>char</code> or <code>unsigned char</code> is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations. <pre><code>std::byte a {0};\nstd::byte b {0xFF};\nint i = std::to_integer&lt;int&gt;(b); // 0xFF\nstd::byte c = a &amp; b;\nint j = std::to_integer&lt;int&gt;(c); // 0\n</code></pre> Note that <code>std::byte</code> is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.</p>"},{"location":"resources/modern-cpp-features/CPP17/#splicing-for-maps-and-sets","title":"Splicing for maps and sets","text":"<p>Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.</p> <p>Moving elements from one map to another: <pre><code>std::map&lt;int, string&gt; src {{1, \"one\"}, {2, \"two\"}, {3, \"buckle my shoe\"}};\nstd::map&lt;int, string&gt; dst {{3, \"three\"}};\ndst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, \"one\" } from `src` to `dst`.\ndst.insert(src.extract(2)); // Cheap remove and insert of { 2, \"two\" } from `src` to `dst`.\n// dst == { { 1, \"one\" }, { 2, \"two\" }, { 3, \"three\" } };\n</code></pre></p> <p>Inserting an entire set: <pre><code>std::set&lt;int&gt; src {1, 3, 5};\nstd::set&lt;int&gt; dst {2, 4, 5};\ndst.merge(src);\n// src == { 5 }\n// dst == { 1, 2, 3, 4, 5 }\n</code></pre></p> <p>Inserting elements which outlive the container: <pre><code>auto elementFactory() {\n  std::set&lt;...&gt; s;\n  s.emplace(...);\n  return s.extract(s.begin());\n}\ns2.insert(elementFactory());\n</code></pre></p> <p>Changing the key of a map element: <pre><code>std::map&lt;int, string&gt; m {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\nauto e = m.extract(2);\ne.key() = 4;\nm.insert(std::move(e));\n// m == { { 1, \"one\" }, { 3, \"three\" }, { 4, \"two\" } }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#parallel-algorithms","title":"Parallel algorithms","text":"<p>Many of the STL algorithms, such as the <code>copy</code>, <code>find</code> and <code>sort</code> methods, started to support the parallel execution policies: <code>seq</code>, <code>par</code> and <code>par_unseq</code> which translate to \"sequentially\", \"parallel\" and \"parallel unsequenced\".</p> <pre><code>std::vector&lt;int&gt; longVector;\n// Find element using parallel execution policy\nauto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);\n// Sort elements using sequential execution policy\nauto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP17/#stdsample","title":"std::sample","text":"<p>Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected. <pre><code>const std::string ALLOWED_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nstd::string guid;\n// Sample 5 characters from ALLOWED_CHARS.\nstd::sample(ALLOWED_CHARS.begin(), ALLOWED_CHARS.end(), std::back_inserter(guid),\n  5, std::mt19937{ std::random_device{}() });\n\nstd::cout &lt;&lt; guid; // e.g. G1fW2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdclamp","title":"std::clamp","text":"<p>Clamp given value between a lower and upper bound. <pre><code>std::clamp(42, -1, 1); // == 1\nstd::clamp(-42, -1, 1); // == -1\nstd::clamp(0, -1, 1); // == 0\n\n// `std::clamp` also accepts a custom comparator:\nstd::clamp(0, -1, 1, std::less&lt;&gt;{}); // == 0\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdreduce","title":"std::reduce","text":"<p>Fold over a given range of elements. Conceptually similar to <code>std::accumulate</code>, but <code>std::reduce</code> will perform the fold in parallel. Due to the fold being done in parallel, if you specify a binary operation, it is required to be associative and commutative. A given binary operation also should not change any element or invalidate any iterators within the given range.</p> <p>The default binary operation is std::plus with an initial value of 0. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\nstd::reduce(std::cbegin(a), std::cend(a)); // == 6\n// Using a custom binary op:\nstd::reduce(std::cbegin(a), std::cend(a), 1, std::multiplies&lt;&gt;{}); // == 6\n</code></pre> Additionally you can specify transformations for reducers: <pre><code>std::transform_reduce(std::cbegin(a), std::cend(a), 0, std::plus&lt;&gt;{}, times_ten); // == 60\n\nconst std::array&lt;int, 3&gt; b{ 1, 2, 3 };\nconst auto product_times_ten = [](const auto a, const auto b) { return a * b * 10; };\n\nstd::transform_reduce(std::cbegin(a), std::cend(a), std::cbegin(b), 0, std::plus&lt;&gt;{}, product_times_ten); // == 140\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#prefix-sum-algorithms","title":"Prefix sum algorithms","text":"<p>Support for prefix sums (both inclusive and exclusive scans) along with transformations. <pre><code>const std::array&lt;int, 3&gt; a{ 1, 2, 3 };\n\nstd::inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}); // 1 3 6\n\nstd::exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}); // 0 1 3\n\nconst auto times_ten = [](const auto n) { return n * 10; };\n\nstd::transform_inclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, std::plus&lt;&gt;{}, times_ten); // 10 30 60\n\nstd::transform_exclusive_scan(std::cbegin(a), std::cend(a),\n    std::ostream_iterator&lt;int&gt;{ std::cout, \" \" }, 0, std::plus&lt;&gt;{}, times_ten); // 0 10 30\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#gcd-and-lcm","title":"GCD and LCM","text":"<p>Greatest common divisor (GCD) and least common multiple (LCM). <pre><code>const int p = 9;\nconst int q = 3;\nstd::gcd(p, q); // == 3\nstd::lcm(p, q); // == 9\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#stdnot_fn","title":"std::not_fn","text":"<p>Utility function that returns the negation of the result of the given function. <pre><code>const std::ostream_iterator&lt;int&gt; ostream_it{ std::cout, \" \" };\nconst auto is_even = [](const auto n) { return n % 2 == 0; };\nstd::vector&lt;int&gt; v{ 0, 1, 2, 3, 4 };\n\n// Print all even numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, is_even); // 0 2 4\n// Print all odd (not even) numbers.\nstd::copy_if(std::cbegin(v), std::cend(v), ostream_it, std::not_fn(is_even)); // 1 3\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#string-conversion-tofrom-numbers","title":"String conversion to/from numbers","text":"<p>Convert integrals and floats to a string or vice-versa. Conversions are non-throwing, do not allocate, and are more secure than the equivalents from the C standard library.</p> <p>Users are responsible for allocating enough storage required for <code>std::to_chars</code>, or the function will fail by setting the error code object in its return value.</p> <p>These functions allow you to optionally pass a base (defaults to base-10) or a format specifier for floating type input.</p> <ul> <li><code>std::to_chars</code> returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer, and an error code object.</li> <li><code>std::from_chars</code> returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.</li> </ul> <p>Both error code objects returned from these functions are equal to the default-initialized error code object on success.</p> <p>Convert the number <code>123</code> to a <code>std::string</code>: <pre><code>const int n = 123;\n\n// Can use any container, string, array, etc.\nstd::string str;\nstr.resize(3); // hold enough storage for each digit of `n`\n\nconst auto [ ptr, ec ] = std::to_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; str &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p> <p>Convert from a <code>std::string</code> with value <code>\"123\"</code> to an integer: <pre><code>const std::string str{ \"123\" };\nint n;\n\nconst auto [ ptr, ec ] = std::from_chars(str.data(), str.data() + str.size(), n);\n\nif (ec == std::errc{}) { std::cout &lt;&lt; n &lt;&lt; std::endl; } // 123\nelse { /* handle failure */ }\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP17/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP17/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP17/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP17/#license","title":"License","text":"<p>MIT</p>"},{"location":"resources/modern-cpp-features/CPP20/","title":"C++20","text":""},{"location":"resources/modern-cpp-features/CPP20/#overview","title":"Overview","text":"<p>Many of these descriptions and examples are taken from various resources (see Acknowledgements section) and summarized in my own words.</p> <p>C++20 includes the following new language features: - coroutines - concepts - designated initializers - template syntax for lambdas - range-based for loop with initializer - [[likely]] and [[unlikely]] attributes - deprecate implicit capture of this - class types in non-type template parameters - constexpr virtual functions - explicit(bool) - immediate functions - using enum - lambda capture of parameter pack - char8_t - constinit</p> <p>C++20 includes the following new library features: - concepts library - synchronized buffered outputstream - std::span - bit operations - math constants - std::is_constant_evaluated - std::make_shared supports arrays - starts_with and ends_with on strings - check if associative container has element - std::bit_cast - std::midpoint - std::to_array</p>"},{"location":"resources/modern-cpp-features/CPP20/#c20-language-features","title":"C++20 Language Features","text":""},{"location":"resources/modern-cpp-features/CPP20/#coroutines","title":"Coroutines","text":"<p>Coroutines are special functions that can have their execution suspended and resumed. To define a coroutine, the <code>co_return</code>, <code>co_await</code>, or <code>co_yield</code> keywords must be present in the function's body. C++20's coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.</p> <p>An example of a coroutine is a generator function, which yields (i.e. generates) a value at each invocation: <pre><code>generator&lt;int&gt; range(int start, int end) {\n  while (start &lt; end) {\n    co_yield start;\n    start++;\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n\nfor (int n : range(0, 10)) {\n  std::cout &lt;&lt; n &lt;&lt; std::endl;\n}\n</code></pre> The above <code>range</code> generator function generates values starting at <code>start</code> until <code>end</code> (exclusive), with each iteration step yielding the current value stored in <code>start</code>. The generator maintains its state across each invocation of <code>range</code> (in this case, the invocation is for each iteration in the for loop). <code>co_yield</code> takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the <code>co_yield</code>.</p> <p>Another example of a coroutine is a task, which is an asynchronous computation that is executed when the task is awaited: <pre><code>task&lt;void&gt; echo(socket s) {\n  for (;;) {\n    auto data = co_await s.async_read();\n    co_await async_write(s, data);\n  }\n\n  // Implicit co_return at the end of this function:\n  // co_return;\n}\n</code></pre> In this example, the <code>co_await</code> keyword is introduced. This keyword takes an expression and suspends execution if the thing you're awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, <code>co_yield</code> uses <code>co_await</code>.)</p> <p>Using a task to lazily evaluate a value: <pre><code>task&lt;int&gt; calculate_meaning_of_life() {\n  co_return 42;\n}\n\nauto meaning_of_life = calculate_meaning_of_life();\n// ...\nco_await meaning_of_life; // == 42\n</code></pre></p> <p>Note: While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20's coroutines. Since the <code>generator</code> and <code>task</code> classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.</p>"},{"location":"resources/modern-cpp-features/CPP20/#concepts","title":"Concepts","text":"<p>Concepts are named compile-time predicates which constrain types. They take the following form: <pre><code>template &lt; template-parameter-list &gt;\nconcept concept-name = constraint-expression;\n</code></pre> where <code>constraint-expression</code> evaluates to a constexpr Boolean. Constraints should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it's bound by (i.e. <code>constraint-expression</code> returns <code>false</code>). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety. <pre><code>// `T` is not limited by any constraints.\ntemplate &lt;typename T&gt;\nconcept always_satisfied = true;\n// Limit `T` to integrals.\ntemplate &lt;typename T&gt;\nconcept integral = std::is_integral_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and signedness.\ntemplate &lt;typename T&gt;\nconcept signed_integral = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.\ntemplate &lt;typename T&gt;\nconcept unsigned_integral = integral&lt;T&gt; &amp;&amp; !signed_integral&lt;T&gt;;\n</code></pre> There are a variety of syntactic forms for enforcing concepts: <pre><code>// Forms for function parameters:\n// `T` is a constrained type template parameter.\ntemplate &lt;my_concept T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\n  requires my_concept&lt;T&gt;\nvoid f(T v);\n\n// `T` is a constrained type template parameter.\ntemplate &lt;typename T&gt;\nvoid f(T v) requires my_concept&lt;T&gt;;\n\n// `v` is a constrained deduced parameter.\nvoid f(my_concept auto v);\n\n// `v` is a constrained non-type template parameter.\ntemplate &lt;my_concept auto v&gt;\nvoid g();\n\n// Forms for auto-deduced variables:\n// `foo` is a constrained auto-deduced value.\nmy_concept auto foo = ...;\n\n// Forms for lambdas:\n// `T` is a constrained type template parameter.\nauto f = []&lt;my_concept T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; requires my_concept&lt;T&gt; (T v) {\n  // ...\n};\n// `T` is a constrained type template parameter.\nauto f = []&lt;typename T&gt; (T v) requires my_concept&lt;T&gt; {\n  // ...\n};\n// `v` is a constrained deduced parameter.\nauto f = [](my_concept auto v) {\n  // ...\n};\n// `v` is a constrained non-type template parameter.\nauto g = []&lt;my_concept auto v&gt; () {\n  // ...\n};\n</code></pre> The <code>requires</code> keyword is used either to start a <code>requires</code> clause or a <code>requires</code> expression: <pre><code>template &lt;typename T&gt;\n  requires my_concept&lt;T&gt; // `requires` clause.\nvoid f(T);\n\ntemplate &lt;typename T&gt;\nconcept callable = requires (T f) { f(); }; // `requires` expression.\n\ntemplate &lt;typename T&gt;\n  requires requires (T x) { x + x; } // `requires` clause and expression on same line.\nT add(T a, T b) {\n  return a + b;\n}\n</code></pre> Note that the parameter list in a <code>requires</code> expression is optional. Each requirement in a <code>requires</code> expression are one of the following:</p> <ul> <li>Simple requirements - asserts that the given expression is valid.</li> </ul> <p><pre><code>template &lt;typename T&gt;\nconcept callable = requires (T f) { f(); };\n</code></pre> * Type requirements - denoted by the <code>typename</code> keyword followed by a type name, asserts that the given type name is valid.</p> <p><pre><code>struct foo {\n  int foo;\n};\n\nstruct bar {\n  using value = int;\n  value data;\n};\n\nstruct baz {\n  using value = int;\n  value data;\n};\n\n// Using SFINAE, enable if `T` is a `baz`.\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, baz&gt;&gt;&gt;\nstruct S {};\n\ntemplate &lt;typename T&gt;\nusing Ref = T&amp;;\n\ntemplate &lt;typename T&gt;\nconcept C = requires {\n                     // Requirements on type `T`:\n  typename T::value; // A) has an inner member named `value`\n  typename S&lt;T&gt;;     // B) must have a valid class template specialization for `S`\n  typename Ref&lt;T&gt;;   // C) must be a valid alias template substitution\n};\n\ntemplate &lt;C T&gt;\nvoid g(T a);\n\ng(foo{}); // ERROR: Fails requirement A.\ng(bar{}); // ERROR: Fails requirement B.\ng(baz{}); // PASS.\n</code></pre> * Compound requirements - an expression in braces followed by a trailing return type or type constraint.</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;; // the type of the expression `*x` is convertible to `T::inner`\n  {x + 1} -&gt; std::same_as&lt;int&gt;; // the expression `x + 1` satisfies `std::same_as&lt;decltype((x + 1))&gt;`\n  {x * 1} -&gt; std::convertible_to&lt;T&gt;; // the type of the expression `x * 1` is convertible to `T`\n};\n</code></pre> * Nested requirements - denoted by the <code>requires</code> keyword, specify additional constraints (such as those on local parameter arguments).</p> <p><pre><code>template &lt;typename T&gt;\nconcept C = requires(T x) {\n  requires std::same_as&lt;sizeof(x), size_t&gt;;\n};\n</code></pre> See also: concepts library.</p>"},{"location":"resources/modern-cpp-features/CPP20/#designated-initializers","title":"Designated initializers","text":"<p>C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized. <pre><code>struct A {\n  int x;\n  int y;\n  int z = 123;\n};\n\nA a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#template-syntax-for-lambdas","title":"Template syntax for lambdas","text":"<p>Use familiar template syntax in lambda expressions. <pre><code>auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; v) {\n  // ...\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#range-based-for-loop-with-initializer","title":"Range-based for loop with initializer","text":"<p>This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem. <pre><code>for (auto v = std::vector{1, 2, 3}; auto&amp; e : v) {\n  std::cout &lt;&lt; e;\n}\n// prints \"123\"\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#likely-and-unlikely-attributes","title":"[[likely]] and [[unlikely]] attributes","text":"<p>Provides a hint to the optimizer that the labelled statement has a high probability of being executed. <pre><code>switch (n) {\ncase 1:\n  // ...\n  break;\n\n[[likely]] case 2:  // n == 2 is considered to be arbitrarily more\n  // ...            // likely than any other value of n\n  break;\n}\n</code></pre></p> <p>If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed. <pre><code>int random = get_random_number_between_x_and_y(0, 3);\nif (random &gt; 0) [[likely]] {\n  // body of if statement\n  // ...\n}\n</code></pre></p> <p>It can also be applied to the substatement (body) of an iteration statement. <pre><code>while (unlikely_truthy_condition) [[unlikely]] {\n  // body of while statement\n  // ...\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#deprecate-implicit-capture-of-this","title":"Deprecate implicit capture of this","text":"<p>Implicitly capturing <code>this</code> in a lambda capture using <code>[=]</code> is now deprecated; prefer capturing explicitly using <code>[=, this]</code> or <code>[=, *this]</code>. <pre><code>struct int_value {\n  int n = 0;\n  auto getter_fn() {\n    // BAD:\n    // return [=]() { return n; };\n\n    // GOOD:\n    return [=, *this]() { return n; };\n  }\n};\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#class-types-in-non-type-template-parameters","title":"Class types in non-type template parameters","text":"<p>Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type <code>const T</code>, where <code>T</code> is the type of the object, and has static storage duration. <pre><code>struct foo {\n  foo() = default;\n  constexpr foo(int) {}\n};\n\ntemplate &lt;foo f&gt;\nauto get_foo() {\n  return f;\n}\n\nget_foo(); // uses implicit constructor\nget_foo&lt;foo{123}&gt;();\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#constexpr-virtual-functions","title":"constexpr virtual functions","text":"<p>Virtual functions can now be <code>constexpr</code> and evaluated at compile-time. <code>constexpr</code> virtual functions can override non-<code>constexpr</code> virtual functions and vice-versa. <pre><code>struct X1 {\n  virtual int f() const = 0;\n};\n\nstruct X2: public X1 {\n  constexpr virtual int f() const { return 2; }\n};\n\nstruct X3: public X2 {\n  virtual int f() const { return 3; }\n};\n\nstruct X4: public X3 {\n  constexpr virtual int f() const { return 4; }\n};\n\nconstexpr X4 x4;\nx4.f(); // == 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#explicitbool","title":"explicit(bool)","text":"<p>Conditionally select at compile-time whether a constructor is made explicit or not. <code>explicit(true)</code> is the same as specifying <code>explicit</code>. <pre><code>struct foo {\n  // Specify non-integral types (strings, floats, etc.) require explicit construction.\n  template &lt;typename T&gt;\n  explicit(!std::is_integral_v&lt;T&gt;) foo(T) {}\n};\n\nfoo a = 123; // OK\nfoo b = \"123\"; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)\nfoo c {\"123\"}; // OK\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#immediate-functions","title":"Immediate functions","text":"<p>Similar to <code>constexpr</code> functions, but functions with a <code>consteval</code> specifier must produce a constant. These are called <code>immediate functions</code>. <pre><code>consteval int sqr(int n) {\n  return n * n;\n}\n\nconstexpr int r = sqr(100); // OK\nint x = 100;\nint r2 = sqr(x); // ERROR: the value of 'x' is not usable in a constant expression\n                 // OK if `sqr` were a `constexpr` function\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#using-enum","title":"using enum","text":"<p>Bring an enum's members into scope to improve readability. Before: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel channel) {\n  switch (channel) {\n    case rgba_color_channel::red:   return \"red\";\n    case rgba_color_channel::green: return \"green\";\n    case rgba_color_channel::blue:  return \"blue\";\n    case rgba_color_channel::alpha: return \"alpha\";\n  }\n}\n</code></pre> After: <pre><code>enum class rgba_color_channel { red, green, blue, alpha };\n\nstd::string_view to_string(rgba_color_channel my_channel) {\n  switch (my_channel) {\n    using enum rgba_color_channel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#lambda-capture-of-parameter-pack","title":"Lambda capture of parameter pack","text":"<p>Capture parameter packs by value: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY VALUE:\n    return [...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre> Capture parameter packs by reference: <pre><code>template &lt;typename... Args&gt;\nauto f(Args&amp;&amp;... args){\n    // BY REFERENCE:\n    return [&amp;...args = std::forward&lt;Args&gt;(args)] {\n        // ...\n    };\n}\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#char8_t","title":"char8_t","text":"<p>Provides a standard type for representing UTF-8 strings. <pre><code>char8_t utf8_str[] = u8\"\\u0123\";\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#constinit","title":"constinit","text":"<p>The <code>constinit</code> specifier requires that a variable must be initialized at compile-time. <pre><code>const char* g() { return \"dynamic initialization\"; }\nconstexpr const char* f(bool p) { return p ? \"constant initializer\" : g(); }\n\nconstinit const char* c = f(true); // OK\nconstinit const char* d = g(false); // ERROR: `g` is not constexpr, so `d` cannot be evaluated at compile-time.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#c20-library-features","title":"C++20 Library Features","text":""},{"location":"resources/modern-cpp-features/CPP20/#concepts-library","title":"Concepts library","text":"<p>Concepts are also provided by the standard library for building more complicated concepts. Some of these include:</p> <p>Core language concepts: - <code>same_as</code> - specifies two types are the same. - <code>derived_from</code> - specifies that a type is derived from another type. - <code>convertible_to</code> - specifies that a type is implicitly convertible to another type. - <code>common_with</code> - specifies that two types share a common type. - <code>integral</code> - specifies that a type is an integral type. - <code>default_constructible</code> - specifies that an object of a type can be default-constructed.</p> <p>Comparison concepts: - <code>boolean</code> - specifies that a type can be used in Boolean contexts. - <code>equality_comparable</code> - specifies that <code>operator==</code> is an equivalence relation.</p> <p>Object concepts: - <code>movable</code> - specifies that an object of a type can be moved and swapped. - <code>copyable</code> - specifies that an object of a type can be copied, moved, and swapped. - <code>semiregular</code> - specifies that an object of a type can be copied, moved, swapped, and default constructed. - <code>regular</code> - specifies that a type is regular, that is, it is both <code>semiregular</code> and <code>equality_comparable</code>.</p> <p>Callable concepts: - <code>invocable</code> - specifies that a callable type can be invoked with a given set of argument types. - <code>predicate</code> - specifies that a callable type is a Boolean predicate.</p> <p>See also: concepts.</p>"},{"location":"resources/modern-cpp-features/CPP20/#synchronized-buffered-outputstream","title":"Synchronized buffered outputstream","text":"<p>Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output). <pre><code>std::osyncstream{std::cout} &lt;&lt; \"The value of x is:\" &lt;&lt; x &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdspan","title":"std::span","text":"<p>A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object.</p> <p>Spans can be dynamically-sized or fixed-sized (known as their extent). Fixed-sized spans benefit from bounds-checking.</p> <p>Span doesn't propogate const so to construct a read-only span use <code>std::span&lt;const T&gt;</code>.</p> <p>Example: using a dynamically-sized span to print integers from various containers. <pre><code>void print_ints(std::span&lt;const int&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_ints(std::vector{ 1, 2, 3 });\nprint_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 });\n\nint a[10] = { 0 };\nprint_ints(a);\n// etc.\n</code></pre></p> <p>Example: a statically-sized span will fail to compile for containers that don't match the extent of the span. <pre><code>void print_three_ints(std::span&lt;const int, 3&gt; ints) {\n    for (const auto n : ints) {\n        std::cout &lt;&lt; n &lt;&lt; std::endl;\n    }\n}\n\nprint_three_ints(std::vector{ 1, 2, 3 }); // ERROR\nprint_three_ints(std::array&lt;int, 5&gt;{ 1, 2, 3, 4, 5 }); // ERROR\nint a[10] = { 0 };\nprint_three_ints(a); // ERROR\n\nstd::array&lt;int, 3&gt; b = { 1, 2, 3 };\nprint_three_ints(b); // OK\n\n// You can construct a span manually if required:\nstd::vector c{ 1, 2, 3 };\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.data(), 3 }); // OK: set pointer and length field.\nprint_three_ints(std::span&lt;const int, 3&gt;{ c.cbegin(), c.cend() }); // OK: use iterator pairs.\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#bit-operations","title":"Bit operations","text":"<p>C++20 provides a new <code>&lt;bit&gt;</code> header which provides some bit operations including popcount. <pre><code>std::popcount(0u); // 0\nstd::popcount(1u); // 1\nstd::popcount(0b1111'0000u); // 4\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#math-constants","title":"Math constants","text":"<p>Mathematical constants including PI, Euler's number, etc. defined in the <code>&lt;numbers&gt;</code> header. <pre><code>std::numbers::pi; // 3.14159...\nstd::numbers::e; // 2.71828...\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdis_constant_evaluated","title":"std::is_constant_evaluated","text":"<p>Predicate function which is truthy when it is called in a compile-time context. <pre><code>constexpr bool is_compile_time() {\n    return std::is_constant_evaluated();\n}\n\nconstexpr bool a = is_compile_time(); // true\nbool b = is_compile_time(); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdmake_shared-supports-arrays","title":"std::make_shared supports arrays","text":"<pre><code>auto p = std::make_shared&lt;int[]&gt;(5); // pointer to `int[5]`\n// OR\nauto p = std::make_shared&lt;int[5]&gt;(); // pointer to `int[5]`\n</code></pre>"},{"location":"resources/modern-cpp-features/CPP20/#starts_with-and-ends_with-on-strings","title":"starts_with and ends_with on strings","text":"<p>Strings (and string views) now have the <code>starts_with</code> and <code>ends_with</code> member functions to check if a string starts or ends with the given string. <pre><code>std::string str = \"foobar\";\nstr.starts_with(\"foo\"); // true\nstr.ends_with(\"baz\"); // false\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#check-if-associative-container-has-element","title":"Check if associative container has element","text":"<p>Associative containers such as sets and maps have a <code>contains</code> member function, which can be used instead of the \"find and check end of iterator\" idiom. <pre><code>std::map&lt;int, char&gt; map {{1, 'a'}, {2, 'b'}};\nmap.contains(2); // true\nmap.contains(123); // false\n\nstd::set&lt;int&gt; set {1, 2, 3};\nset.contains(2); // true\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdbit_cast","title":"std::bit_cast","text":"<p>A safer way to reinterpret an object from one type to another. <pre><code>float f = 123.0;\nint i = std::bit_cast&lt;int&gt;(f);\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdmidpoint","title":"std::midpoint","text":"<p>Calculate the midpoint of two integers safely (without overflow). <pre><code>std::midpoint(1, 3); // == 2\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#stdto_array","title":"std::to_array","text":"<p>Converts the given array/\"array-like\" object to a <code>std::array</code>. <pre><code>std::to_array(\"foo\"); // returns `std::array&lt;char, 4&gt;`\nstd::to_array&lt;int&gt;({1, 2, 3}); // returns `std::array&lt;int, 3&gt;`\n\nint a[] = {1, 2, 3};\nstd::to_array(a); // returns `std::array&lt;int, 3&gt;`\n</code></pre></p>"},{"location":"resources/modern-cpp-features/CPP20/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>cppreference - especially useful for finding examples and documentation of new library features.</li> <li>C++ Rvalue References Explained - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.</li> <li>clang and gcc's standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it's meant to fix, and some examples.</li> <li>Compiler explorer</li> <li>Scott Meyers' Effective Modern C++ - highly recommended book!</li> <li>Jason Turner's C++ Weekly - nice collection of C++-related videos.</li> <li>What can I do with a moved-from object?</li> <li>What are some uses of decltype(auto)?</li> <li>And many more SO posts I'm forgetting...</li> </ul>"},{"location":"resources/modern-cpp-features/CPP20/#author","title":"Author","text":"<p>Anthony Calandra</p>"},{"location":"resources/modern-cpp-features/CPP20/#content-contributors","title":"Content Contributors","text":"<p>See: https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors</p>"},{"location":"resources/modern-cpp-features/CPP20/#license","title":"License","text":"<p>MIT</p>"}]}