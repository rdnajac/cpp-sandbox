{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Tour of C++","text":"<p>During my time at Columbia University, I had the privilege of taking Bjarne Stroustrup's course, \"Design using C++\". Now that I have graduated, I've decided to compile all of my notes into a comprehensive guide. This document serves as an easy reference to accompany the repository of code snippets and examples I have been developing.</p>"},{"location":"#attribution","title":"Attribution","text":"<p>The material in this document is based on concepts and information from: Stroustrup, B. (2022). A Tour of C++ (C++ In-Depth Series) (3rd ed.). Addison-Wesley Professional.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>The Basics</li> <li>User-Defined Types</li> <li>Modularity</li> <li>Error Handling</li> <li>Classes</li> <li>Essential Operations</li> <li>Templates</li> <li>Concepts and Generic Programming</li> <li>Standard-Library</li> <li>Strings and Regular Expressions</li> <li>Input and Output</li> <li>Containers</li> <li>Algorithms</li> <li>Ranges</li> <li>Pointers and Containers</li> <li>Utilities</li> <li>Numerics</li> <li>Concurrency</li> </ol>"},{"location":"#the-basics","title":"The Basics","text":"<pre><code>using namespace std;    // make names from std visible without std::\n</code></pre>"},{"location":"#variables","title":"Variables","text":"<p>Use <code>auto</code> to let the compiler deduce the type of a variable unless there is a specific reason to specify the type.</p> <pre><code>auto i = 7;     // i is an int\nauto d = 1.2;   // d is a double\nauto qq {true}; // qq is a bool\n</code></pre>"},{"location":"#constants","title":"Constants","text":"<p>Use <code>const</code> to define a constant. Use <code>constexpr</code> for a constant expression. For example:</p> <pre><code>constexpr double square(double x) { return x*x; }\n</code></pre>"},{"location":"#loops","title":"Loops","text":"<p>A \"range-<code>for</code>-statement\" traverses a sequence in the simplest way:</p> <pre><code>int v[] = {0, 1, 2, 3, 4, 5};\n\nfor (auto x : v) cout &lt;&lt; x &lt;&lt; '\\n';\n</code></pre> <p>Another example:</p> <pre><code>for (auto&amp; x : v) x *= 2;\n</code></pre>"},{"location":"#user-defined-types","title":"User-Defined Types","text":"<ul> <li>Use 'class' to hide representation and provide an interface.</li> <li>Use 'struct' to group related data without hiding.</li> <li>Prefer 'enum class' over plain enums.</li> <li>Consider std::variant as a type-safe alternative to unions.</li> <li>Use user-defined literals for expressive value specification.</li> </ul>"},{"location":"#structures","title":"Structures","text":"<p>Structures group related data elements:</p> <pre><code>struct DNASequence {\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    std::string source;\n};\n</code></pre>"},{"location":"#classes","title":"Classes","text":"<p>Classes extend structures by adding member functions:</p> <pre><code>class DNA {\npublic:\n    DNA(std::vector&lt;Nucleotide&gt; seq) : sequence{std::move(seq)} {}\n    void addNucleotide(Nucleotide n) { sequence.push_back(n); }\n    size_t length() const { return sequence.size(); }\nprivate:\n    std::vector&lt;Nucleotide&gt; sequence;\n};\n</code></pre> <p>Usage:</p> <pre><code>DNA dna({Nucleotide::A, Nucleotide::T, Nucleotide::G});\ndna.addNucleotide(Nucleotide::C);\nstd::cout &lt;&lt; \"DNA length: \" &lt;&lt; dna.length() &lt;&lt; '\\n';\n</code></pre> <p>Jump ahead to Classes for more information.</p>"},{"location":"#enumerations","title":"Enumerations","text":"<p>Use strongly typed enumerations:</p> <pre><code>enum class Nucleotide {\n    A, // Adenine\n    T, // Thymine\n    G, // Guanine\n    C  // Cytosine\n};\n</code></pre> <p>Nucleotide base = Nucleotide::A;</p>"},{"location":"#unions","title":"Unions","text":"<p>Modern C++ prefers std::variant over unions:</p> <pre><code>#include &lt;variant&gt;\n\nstd::variant&lt;DNA, std::string&gt; genetic_info;\ngenetic_info = DNA({Nucleotide::A, Nucleotide::T});\ngenetic_info = \"ATGC\";  // Now contains a string\n</code></pre>"},{"location":"#user-defined-literals","title":"User-Defined Literals:/","text":"<p>Define custom literals:</p> <pre><code>DNA operator\"\"_dna(const char* seq, size_t len)\n{\n    std::vector&lt;Nucleotide&gt; nucleotides;\n    for (size_t i = 0; i &lt; len; ++i) {\n        switch(seq[i]) {\n            case 'A': nucleotides.push_back(Nucleotide::A); break;\n            case 'T': nucleotides.push_back(Nucleotide::T); break;\n            case 'G': nucleotides.push_back(Nucleotide::G); break;\n            case 'C': nucleotides.push_back(Nucleotide::C); break;\n            default: throw std::invalid_argument(\"Invalid nucleotide\");\n        }\n    }\n    return DNA(nucleotides);\n}\n\nauto my_dna = \"ATGC\"_dna;\n</code></pre>"},{"location":"#type-aliases","title":"Type Aliases","text":"<p>Use 'using' for type aliases:</p> <p>using DNAStrand = std::vector; <p>[!NOTE] I don't like using these in C because they obscure the type of the variable. However, I don't have enough experience with C++ to know if if this is best practice.</p>"},{"location":"#modularity","title":"Modularity","text":"<p>Declarations (interfaces, .h, .hpp) and definitions (implementations, .c, .cpp) should be separate. Where modules are supported (C++20), use them!</p> <p>[!TIP] Header files should emphasize logical structure.</p>"},{"location":"#namespaces","title":"namespaces","text":""},{"location":"#modules","title":"modules","text":""},{"location":"#error-handling","title":"Error Handling","text":""},{"location":"#exceptions","title":"Exceptions","text":"<p>You can throw custon exceptions after defining a class derived from std::exception. For example:</p> <pre><code>class BadLengthException : public std::exception {\nprivate:\n    int length;\n    std::string message;\n\npublic:\n    BadLengthException(int len) : length(len) {\n        message = std::to_string(length);\n    }\n\n    const char* what() const noexcept override {\n        return message.c_str();\n    }\n};\n</code></pre> <ul> <li>invariants</li> <li>error-handling alternatives</li> <li>assertions</li> </ul>"},{"location":"#classes_1","title":"Classes","text":"<p>Three important kinds of C++ classes are:</p> <ul> <li>concrete types</li> <li>abstract types</li> <li>virtual functions</li> </ul>"},{"location":"#concrete-types","title":"Concrete Types","text":"<p>They behave \"just like built-in types.\"!</p>"},{"location":"#classical-user-defined-arithmetic-type","title":"Classical user-defined arithmetic type","text":"<pre><code>class complex {\n    double re, im; // representation: two doubles\npublic:\n    complex(double r, double i) :re{r}, im{i} {}    // construct complex from two scalars\n    complex(double r) :re{r}, im{0} {}              // construct complex from one scalar\n    complex() :re{0}, im{0} {}                      // default complex: {0,0}\n    complex(complex z) :re{z.re}, im{z.im} {}       // copy constructor\n\n    double real() const { return re; }\n    void real(double d) { re=d; }\n    double imag() const { return im; }\n    void imag(double d) { im=d; }\n\n    complex&amp; operator+=(complex z)\n    {\n        re+=z.re;       // add to re and im\n        im+=z.im;\n        return *this;   // return the result\n    }\n\n    complex&amp; operator-=(complex z)\n    {\n        re-=z.re;\n        im-=z.im;\n        return *this;\n    }\n\n    complex&amp; operator*=(complex); // defined out-of-class somewhere\n    complex&amp; operator/=(complex); // defined out-of-class somewhere\n};\n</code></pre>"},{"location":"#abstract-types","title":"Abstract Types","text":"<p>Insulates the user from implementation details by decoupling the interface from the representation.</p> <p>Since we don\u2019t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store and access them through references or pointers.</p> <pre><code>class Container {\npublic:\n    virtual double&amp; operator[](int) = 0;    // pure virtual function\n    virtual int size() const = 0;           // const member function\n    virtual  \u0303Container() {}                 // destructor\n\n    // const member function  // destructor (\u00a75.2.2)\n};\n</code></pre>"},{"location":"#heirarchies","title":"Heirarchies","text":""},{"location":"#essential-operations","title":"Essential Operations","text":"<ul> <li>copy and move</li> <li>resource management</li> <li>operator overloading</li> <li>conventional operations</li> <li>user-defined literals</li> </ul>"},{"location":"#templates","title":"Templates","text":"<ul> <li>parameterized types</li> <li>parameterized operations</li> <li>template mechanisms</li> </ul>"},{"location":"#concepts-and-generic-programming","title":"Concepts and Generic Programming","text":"<ul> <li>concepts</li> <li>generic programming</li> <li>variadic templates</li> <li>template compilation model</li> </ul>"},{"location":"#standard-library","title":"Standard-Library","text":"<ul> <li>components</li> <li>organization</li> </ul>"},{"location":"#strings-and-regular-expressions","title":"Strings and Regular Expressions","text":"<ul> <li>strings</li> <li>string views</li> <li>regular expressions</li> </ul>"},{"location":"#input-and-output","title":"Input and Output","text":"<ul> <li>state</li> <li>user-defined types</li> <li>formatting</li> <li>streams</li> <li>c-style</li> <li>file system</li> </ul>"},{"location":"#containers","title":"Containers","text":""},{"location":"#vector","title":"vector","text":""},{"location":"#insert","title":"insert","text":"<p>Insert expects an iterator and a value to insert:</p> <pre><code>v.insert(v.begin() + 2, 5); // insert 5 at position 2\n</code></pre> <p>Use <code>v.begin()</code> to get an iterator to the beginning of the vector, then add an offset to get the desired position.</p>"},{"location":"#append-to-end","title":"append to end","text":"<p>Use <code>push_back</code> to append to the end of a vector:</p> <pre><code>v.push_back(7);\n</code></pre>"},{"location":"#find-and-insert-after","title":"find and insert after","text":"<p>Use <code>std::find</code> to find a value in a vector:</p> <pre><code>auto it = std::find(v.begin(), v.end(), 5);\nif (it != v.end()) {\n    v.insert(it + 1, 6);\n}\n</code></pre> <ul> <li><code>list</code></li> <li><code>forward_list</code></li> <li><code>map</code></li> <li><code>unordered_map</code></li> <li>allocators</li> <li>container overview</li> </ul>"},{"location":"#algorithms","title":"Algorithms","text":"<ul> <li>iterators</li> <li>use of predicates</li> <li>algorithm overview</li> <li>parallel algorithms</li> </ul>"},{"location":"#ranges","title":"Ranges","text":"<ul> <li>views</li> <li>generators</li> <li>pipelines</li> <li>concepts overview</li> </ul>"},{"location":"#pointers-and-containers","title":"Pointers and Containers","text":"<ul> <li>pointers</li> <li>containers</li> <li>alternatives</li> </ul>"},{"location":"#utilities","title":"Utilities","text":"<ul> <li>time</li> <li>function adaption</li> <li>type functions</li> <li><code>source_location</code></li> <li><code>move()</code> and <code>forward()</code></li> <li>bit manipulation</li> </ul>"},{"location":"#numerics","title":"Numerics","text":"<ul> <li>mathematical functions</li> <li>numerical algorithms</li> <li>complex numbers</li> <li>random numbers</li> <li>vector arithmetic</li> <li>numeric limits</li> <li>mathematical constants</li> </ul>"},{"location":"#concurrency","title":"Concurrency","text":"<ul> <li>tasks and <code>thread</code>s</li> <li>sharing data</li> <li>waiting for events</li> <li>communicating tasks</li> <li>coroutines</li> </ul>"},{"location":"qsort/","title":"Quicksort","text":"<p>The <code>qsort()</code> function is a modified partition-exchange sort, or quicksort.</p> <pre><code>#include &lt;stdlib.h&gt;\n\nvoid\nqsort(void *base, size_t nel, size_t width,\n    int (*compar)(const void *, const void *));\n</code></pre>"},{"location":"qsort/#compar-function","title":"<code>compar</code> function","text":"<p>The <code>compar</code> function is a user-supplied function that returns an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.</p> <pre><code>int compar(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n</code></pre> <p>Here, the <code>compar</code> function compares dereferenced pointers-to-integers and returns the difference between the two values. If the difference is negative, the first argument is considered less than the second. If the difference is zero, the two arguments are considered equal.</p>"},{"location":"qsort/#time-complexity","title":"Time complexity","text":"<p>The time complexity of quicksort is O(n log n) on average, but O(n^2) in the worst case.</p> <p>The space complexity is O(log n) on average, but O(n) in the worst case.</p>"},{"location":"tcp/","title":"TCP Echo Server and Client","text":"<p>This project implements a simple TCP echo server and client in C++. The server listens for incoming connections and echoes back any data it receives. The client connects to the server, sends a message, and prints the response.</p>"},{"location":"tcp/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++17 compatible compiler (e.g., GCC 7+ or Clang 5+)</li> <li>Make build system</li> <li>POSIX-compatible operating system (Linux, macOS, etc.)</li> </ul>"},{"location":"tcp/#project-structure","title":"Project Structure","text":"<p>The project consists of the following files:</p> <ul> <li><code>server.cpp</code>: Implementation of the TCP echo server</li> <li><code>client.cpp</code>: Implementation of the TCP echo client</li> <li><code>utils.h</code>: Header file for utility functions</li> <li><code>utils.cpp</code>: Implementation of utility functions</li> <li><code>Makefile</code>: Build script for compiling the project</li> </ul>"},{"location":"tcp/#building-the-project","title":"Building the Project","text":"<p>To build the project, follow these steps:</p> <ol> <li>Open a terminal and navigate to the project directory.</li> <li>Run the following command:</li> </ol> <pre><code>make\n</code></pre> <p>This will compile both the server and client executables.</p>"},{"location":"tcp/#running-the-server","title":"Running the Server","text":"<p>To start the echo server, use the following command:</p> <pre><code>./server &lt;port&gt;\n</code></pre> <p>Replace <code>&lt;port&gt;</code> with the port number you want the server to listen on (e.g., 8080).</p> <p>Example: <pre><code>./server 8080\n</code></pre></p> <p>The server will start and listen for incoming connections on the specified port.</p>"},{"location":"tcp/#running-the-client","title":"Running the Client","text":"<p>To run the client and send a message to the server, use the following command:</p> <pre><code>./client &lt;message&gt; &lt;server-ip&gt; &lt;server-port&gt;\n</code></pre> <ul> <li>Replace <code>&lt;message&gt;</code> with the text you want to send to the server.</li> <li>Replace <code>&lt;server-ip&gt;</code> with the IP address of the server (use 127.0.0.1 for localhost).</li> <li>Replace <code>&lt;server-port&gt;</code> with the port number the server is listening on.</li> </ul> <p>Example: <pre><code>./client \"Hello, Server!\" 127.0.0.1 8080\n</code></pre></p> <p>The client will connect to the server, send the message, receive the echo response, and display it.</p>"},{"location":"tcp/#cleaning-up","title":"Cleaning Up","text":"<p>To remove all compiled files and start fresh, run:</p> <pre><code>make clean\n</code></pre> <p>This will remove the server and client executables, as well as any object files.</p>"},{"location":"tcp/#note","title":"Note","text":"<p>This project is designed for educational purposes and may not be suitable for production environments without further enhancements.</p>"},{"location":"time-complexity/","title":"Time Complexity","text":"<p>Time complexity is a measure of the amount of time an algorithm takes to complete as a function of the size of the input. It is often expressed using big-O notation, which describes the upper bound of the time taken by an algorithm as a function of the size of the input.</p>"},{"location":"time-complexity/#big-o-notation","title":"Big-O notation","text":"<p>Big-O notation describes the upper bound of the time taken by an algorithm as a function of the size of the input. It is used to describe the worst-case performance of an algorithm. For example, an algorithm with a time complexity of O(n) will take at most n steps to complete, where n is the size of the input.</p> <pre><code>int sum(int n)\n{\n    int total = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        total += i;\n    }\n    return total;\n}\n</code></pre> <p>The <code>sum</code> function has a time complexity of O(n) because it takes at most n steps to complete, where n is the input to the function.</p>"},{"location":"time-complexity/#common-time-complexities","title":"Common time complexities","text":"Notation Name Example O(1) Constant time Accessing an element in an array by index (index arithmetic) O(log n) Logarithmic time Binary search (if the input is sorted) O(n) Linear time Finding the maximum element in an array (one-pass) O(n log n) Linearithmic time Quicksort, mergesort (average case) O(n^2) Quadratic time Bubble sort, selection sort (use of nested loops) O(2^n) Exponential time Recursive Fibonacci calculation O(n!) Factorial time Generating all permutations of a set"},{"location":"time-complexity/#comparing-time-complexities","title":"Comparing time complexities","text":"<p>The following table shows how the time complexity of different algorithms compares as the size of the input grows.</p> Input size O(log n) O(n) O(n log n) O(n^2) O(2^n) O(n!) 10 3 10 30 100 1024 3628800 100 7 100 664 10000 1.27e+30 9.33e+157 1000 10 1000 9965 1000000 1.07e+301 4.02e+2567 <p>You get the idea.</p>"}]}