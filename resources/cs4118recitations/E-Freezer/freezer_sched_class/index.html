
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A collection of C++ code snippets and examples.">
      
      
        <meta name="author" content="Ryan D. Najac">
      
      
      
      
      
      <link rel="icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.38">
    
    
      
        <title>Freezer sched_class - C++ Sandbox</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.8c3ca2c6.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"JetBrains Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#freezer-sched_class" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="C++ Sandbox" class="md-header__button md-logo" aria-label="C++ Sandbox" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            C++ Sandbox
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Freezer sched_class
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/rdnajac/cpp-sandbox" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="C++ Sandbox" class="md-nav__button md-logo" aria-label="C++ Sandbox" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    C++ Sandbox
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/rdnajac/cpp-sandbox" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ sandbox
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../advprog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Advanced Programming
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../cuda/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CUDA
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../pimpl/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Pointer to Implementation (PImpl)
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../qsort/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quicksort
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../tcp/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TCP Echo Server and Client
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../tour/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A Tour of C++
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-top-down-approach" class="md-nav__link">
    <span class="md-ellipsis">
      A Top Down Approach
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disclaimer" class="md-nav__link">
    <span class="md-ellipsis">
      Disclaimer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#what-is-the-linux-scheduler" class="md-nav__link">
    <span class="md-ellipsis">
      What is the Linux Scheduler?
    </span>
  </a>
  
    <nav class="md-nav" aria-label="What is the Linux Scheduler?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#where-does-the-scheduler-fit" class="md-nav__link">
    <span class="md-ellipsis">
      Where Does the Scheduler Fit?
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#responsibility-i-switching-to-the-next-process" class="md-nav__link">
    <span class="md-ellipsis">
      Responsibility I: Switching to the Next Process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-runqueue" class="md-nav__link">
    <span class="md-ellipsis">
      The Runqueue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#preemption-vs-yielding" class="md-nav__link">
    <span class="md-ellipsis">
      Preemption vs Yielding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schedule" class="md-nav__link">
    <span class="md-ellipsis">
      schedule()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#responsibility-ii-when-should-the-next-process-run" class="md-nav__link">
    <span class="md-ellipsis">
      Responsibility II: When Should the Next Process Run?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#understanding-sched_class" class="md-nav__link">
    <span class="md-ellipsis">
      Understanding sched_class
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Understanding sched_class">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#enqueue_task-and-dequeue_task" class="md-nav__link">
    <span class="md-ellipsis">
      enqueue_task() and dequeue_task()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pick_next_task" class="md-nav__link">
    <span class="md-ellipsis">
      pick_next_task()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#put_prev_task" class="md-nav__link">
    <span class="md-ellipsis">
      put_prev_task()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task_tick" class="md-nav__link">
    <span class="md-ellipsis">
      task_tick()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_task_rq" class="md-nav__link">
    <span class="md-ellipsis">
      select_task_rq()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_next_task" class="md-nav__link">
    <span class="md-ellipsis">
      set_next_task()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#yield_task" class="md-nav__link">
    <span class="md-ellipsis">
      yield_task()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#check_preempt_curr" class="md-nav__link">
    <span class="md-ellipsis">
      check_preempt_curr()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#balance" class="md-nav__link">
    <span class="md-ellipsis">
      balance()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update_curr" class="md-nav__link">
    <span class="md-ellipsis">
      update_curr()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prio_changed" class="md-nav__link">
    <span class="md-ellipsis">
      prio_changed()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#switched_to" class="md-nav__link">
    <span class="md-ellipsis">
      switched_to()
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="freezer-sched_class">Freezer sched_class</h1>
<blockquote>
<p>This guide is adapted from a blog series written by Mitchell Gouzenko, a
former OS TA. The original posts can be found
<a href="https://mgouzenko.github.io/jekyll/update/2016/11/04/the-linux-process-scheduler.html">here</a>.</p>
<p>The code snippets and links in this post correspond to Linux v5.10.205 for 2024 Spring.</p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>I'm writing this series after TA-ing an operating systems class for two
semesters. Each year, tears begin to flow by the time we get to the infamous
Scheduler Assignment - where students are asked to implement a round-robin
scheduler in the Linux kernel. The assignment is known to leave relatively
competent programmers in shambles. I don't blame them; the seemingly simple task
of writing a round robin scheduler is complicated by two confounding factors:</p>
<ul>
<li>The Linux scheduler is cryptic as hell and on top of that, very poorly
  documented.</li>
<li>Bugs in scheduler code will often trigger a kernel panic, freezing the system
  without providing any logs or meaningful error messages.</li>
</ul>
<p>I hope to ease students' suffering by addressing the first bullet point. In this
series, I will explain how the scheduler's infrastructure is set up, emphasizing
how one may leverage its modularity to plug in their own scheduler.</p>
<p>We'll begin by examining the basic role of the core scheduler and how the rest
of the kernel interfaces with it. Then, we'll look at <code>sched_class</code>, the modular
data structure that permits various scheduling algorithms to live and operate
side-by-side in the kernel.</p>
<h3 id="a-top-down-approach">A Top Down Approach</h3>
<p>Initially, I'll treat the scheduler as a black box. I will make gross
over-simplifications but note very clearly when I do so. Little by little, we
will delve into the scheduler's internals, unfolding the truth behind these
simplifications. By the end of this series, you should be able to start tackling
the problem of writing your own working scheduler.</p>
<h3 id="disclaimer">Disclaimer</h3>
<p>I'm not an expert kernel hacker. I'm just a student who has spent a modest
number of hours reading, screaming at, and sobbing over kernel code. If I make a
mistake, please point it out in the comments section, and I'll do my best to
correct it.</p>
<h2 id="what-is-the-linux-scheduler">What is the Linux Scheduler?</h2>
<p>Linux is a multi-tasking system. At any instant, there are many processes active
at once, but a single CPU can only perform work on behalf of one process at a
time. At a high level, Linux context switches from process to process, letting
the CPU perform work on behalf of each one in turn. This switching occurs
quickly enough to create the illusion that all processes are running
simultaneously. <strong>The scheduler is in charge of coordinating all of this
switching.</strong></p>
<h3 id="where-does-the-scheduler-fit">Where Does the Scheduler Fit?</h3>
<p>You can find most scheduler-related code under <code>kernel/sched</code>. Now, the
scheduler has a distinct and non-trivial job. The rest of the kernel doesn't
know or care how the scheduler performs its magic, as long as it can be called
upon to schedule tasks. So, to hide the complexity of the scheduler, it is
invoked with a simple and well-defined API. The scheduler - from the perspective
of the rest of the kernel - has two main responsibilities:</p>
<ul>
<li>
<p><strong>Responsibility I</strong>: Provide an interface to halt the currently running
process and switch to a new one. To do so, the scheduler must pick the next
process to run, which is a nontrivial problem.</p>
</li>
<li>
<p><strong>Responsibility II</strong>: Indicate to the rest of the OS when a new process
should be run.</p>
</li>
</ul>
<h3 id="responsibility-i-switching-to-the-next-process">Responsibility I: Switching to the Next Process</h3>
<p>To fulfill its first responsibility, the scheduler must somehow keep track of
all the running processes.</p>
<h3 id="the-runqueue">The Runqueue</h3>
<p>Here's the first over-simplification: you can think of the scheduler as a system
that maintains a simple queue of processes in the form of a linked list. The
process at the head of the queue is allowed to run for some "time slice" - say,
10 milliseconds. After this time slice expires, the process is moved to the back
of the queue, and the next process gets to run on the CPU for the same time
slice. When a running process is forcibly stopped and taken off the CPU in this
way, we say that it has been <strong>preempted</strong>. The linked list of processes waiting
to have a go on the CPU is called the runqueue. Each CPU has its own runqueue,
and a given process may appear on only one CPU's runqueue at a time. Processes
CAN migrate between various CPUs' runqueues, but we'll save this discussion for
later.</p>
<div align='center'>
    <img src='./final_simple_runqueue.png'/><br/>
    Figure 1: An over-simplification of the runqueue
</div>

<p>The scheduler is not really this simple; the runqueue is defined in the kernel
as <code>struct rq</code>, and you can take a peek at its definition
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/sched.h#L897">here</a>.
Spoiler alert: it's not a linked list! To be fair, the explanation that I gave
above more or less describes the very first Linux runqueue. But over the years,
the scheduler evolved to incorporate multiple scheduling algorithms. These
include:</p>
<ul>
<li>Completely Fair Scheduler (CFS)</li>
<li>Real-Time Scheduler</li>
<li>Deadline Scheduler</li>
</ul>
<p>The modern-day runqueue is no longer a linked list but actually a collection of
algorithm-specific runqueues corresponding to the list above. Indeed,
<code>struct rq</code> has the following members:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="n">cfs</span><span class="p">;</span><span class="w">  </span><span class="c1">// CFS scheduler runqueue</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">rt_rq</span><span class="w"> </span><span class="n">rt</span><span class="p">;</span><span class="w">    </span><span class="c1">// Real-time scheduler runqueue</span>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="k">struct</span><span class="w"> </span><span class="nc">dl_rq</span><span class="w"> </span><span class="n">dl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Deadline scheduler runqueue</span>
</span></code></pre></div>
<p>For example, CFS, which is the default scheduler in modern Linux kernels, uses a
red-black tree data structure to keep track of processes, with each process
assigned a "virtual runtime" that determines its priority in the scheduling
queue. The scheduler then selects the process with the lowest virtual runtime to
run next, ensuring that each process gets a fair share of CPU time over the long
term.</p>
<p>Keep these details in the back of your mind so that you don't get bogged down.
Remember: the goal here is to understand how the scheduler interoperates with
the rest of the kernel. The main takeaway is that a process is allowed to run
for some time, and when that time expires, it gets preempted so that the next
process can run.</p>
<h3 id="preemption-vs-yielding">Preemption vs Yielding</h3>
<p>Preemption is not always the reason a process is taken off the CPU. For example,
a process might voluntarily go to sleep, waiting for an IO event or lock. To do
this, the process puts itself on a "wait queue" and takes itself off the
runqueue. In this case, the process has <strong>yielded</strong> the CPU. In summary:</p>
<ul>
<li>
<p>"preemption" is when a process is forcibly kicked off the CPU.</p>
</li>
<li>
<p>"yielding" is when a process voluntarily gives up the CPU.</p>
</li>
</ul>
<p>In addition to an expired timeslice, there are several other reasons that
preemption may occur. For example, when an interrupt occurs, the CPU may be
preempted to handle the interrupt. Additionally, a real-time process may have a
higher priority than some other process and may preempt lower-priority processes
to ensure that it meets its deadline.</p>
<h3 id="schedule"><code>schedule()</code></h3>
<p>With a conceptual understanding of the runqueue, we now have the background to
understand how Responsibility I is carried out by the scheduler. The
<code>schedule()</code> function is the crux of Responsibility I: it halts the currently
running process and runs the next one on the CPU. This function is referred to
by many texts as "the entrypoint into the scheduler". <code>schedule()</code> invokes
<code>__schedule()</code> to do most of the real work. Here is the portion relevant to us:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__sched</span><span class="w"> </span><span class="n">notrace</span><span class="w"> </span><span class="n">__schedule</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">preempt</span><span class="p">)</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="p">{</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">;</span>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="w">    </span><span class="cm">/* CODE OMITTED */</span>
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="w">    </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="w">    </span><span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="w">    </span><span class="n">clear_preempt_need_resched</span><span class="p">();</span>
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a>
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">next</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-14"><a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a><span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-1-15"><a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a><span class="w">        </span><span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">);</span>
</span><span id="__span-1-16"><a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a><span class="w">        </span><span class="o">++*</span><span class="n">switch_count</span><span class="p">;</span>
</span><span id="__span-1-17"><a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a>
</span><span id="__span-1-18"><a id="__codelineno-1-18" name="__codelineno-1-18" href="#__codelineno-1-18"></a><span class="w">        </span><span class="n">psi_sched_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">prev</span><span class="p">));</span>
</span><span id="__span-1-19"><a id="__codelineno-1-19" name="__codelineno-1-19" href="#__codelineno-1-19"></a><span class="w">        </span><span class="n">trace_sched_switch</span><span class="p">(</span><span class="n">preempt</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">);</span>
</span><span id="__span-1-20"><a id="__codelineno-1-20" name="__codelineno-1-20" href="#__codelineno-1-20"></a><span class="w">        </span><span class="n">rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
</span><span id="__span-1-21"><a id="__codelineno-1-21" name="__codelineno-1-21" href="#__codelineno-1-21"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-1-22"><a id="__codelineno-1-22" name="__codelineno-1-22" href="#__codelineno-1-22"></a>
</span><span id="__span-1-23"><a id="__codelineno-1-23" name="__codelineno-1-23" href="#__codelineno-1-23"></a><span class="w">    </span><span class="cm">/* CODE OMITTED */</span>
</span><span id="__span-1-24"><a id="__codelineno-1-24" name="__codelineno-1-24" href="#__codelineno-1-24"></a><span class="p">}</span>
</span></code></pre></div>
<p><code>pick_next_task()</code> looks at the runqueue <code>rq</code> and returns the <code>task_struct</code>
associated with the process that should be run next. If we consider t=10 in
Figure 1, <code>pick_next_task()</code> would return the <code>task_struct</code> for Process 2. Then,
<code>context_switch()</code> switches the CPU's state to that of the returned
<code>task_struct</code>. This fullfills Responsibility I.</p>
<h2 id="responsibility-ii-when-should-the-next-process-run">Responsibility II: When Should the Next Process Run?</h2>
<p>Great, so we've seen that <code>schedule()</code> is used to context switch to the next
task. But when does this <em>actually</em> happen?</p>
<p>As mentioned previously, a user-space program might voluntarily go to sleep
waiting for an IO event or a lock. In this case, the kernel will call
<code>schedule()</code> on behalf of the process that needs to sleep. But what if the
user-space program never sleeps? Here's one such program:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="p">{</span>
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="p">}</span>
</span></code></pre></div>
<p>If <code>schedule()</code> were only called when a user-space program voluntarily sleeps,
then programs like the one above would use up the processor indefinitely. Thus,
we need a mechanism to preempt processes that have exhausted their time slice!</p>
<p>This preemption is accomplished via the timer interrupt. The timer interrupt
fires periodically, allowing control to jump to the timer interrupt handler in
the kernel. This handler calls the function <code>update_process_times()</code>, shown
below.</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="cm">/*</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="cm"> * Called from the timer interrupt handler to charge one tick to the current</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="cm"> * process.  user_tick is 1 if the tick is user time, 0 for system.</span>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="cm"> */</span>
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">update_process_times</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">user_tick</span><span class="p">)</span>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="p">{</span>
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a>
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a><span class="w">    </span><span class="n">PRANDOM_ADD_NOISE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span><span class="w"> </span><span class="n">user_tick</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</span><span id="__span-3-10"><a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a>
</span><span id="__span-3-11"><a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a><span class="w">    </span><span class="cm">/* Note: this timer irq context must be accounted for as well. */</span>
</span><span id="__span-3-12"><a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a><span class="w">    </span><span class="n">account_process_tick</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">user_tick</span><span class="p">);</span>
</span><span id="__span-3-13"><a id="__codelineno-3-13" name="__codelineno-3-13" href="#__codelineno-3-13"></a><span class="w">    </span><span class="n">run_local_timers</span><span class="p">();</span>
</span><span id="__span-3-14"><a id="__codelineno-3-14" name="__codelineno-3-14" href="#__codelineno-3-14"></a><span class="w">    </span><span class="n">rcu_sched_clock_irq</span><span class="p">(</span><span class="n">user_tick</span><span class="p">);</span>
</span><span id="__span-3-15"><a id="__codelineno-3-15" name="__codelineno-3-15" href="#__codelineno-3-15"></a><span class="cp">#ifdef CONFIG_IRQ_WORK</span>
</span><span id="__span-3-16"><a id="__codelineno-3-16" name="__codelineno-3-16" href="#__codelineno-3-16"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in_irq</span><span class="p">())</span>
</span><span id="__span-3-17"><a id="__codelineno-3-17" name="__codelineno-3-17" href="#__codelineno-3-17"></a><span class="w">        </span><span class="n">irq_work_tick</span><span class="p">();</span>
</span><span id="__span-3-18"><a id="__codelineno-3-18" name="__codelineno-3-18" href="#__codelineno-3-18"></a><span class="cp">#endif</span>
</span><span id="__span-3-19"><a id="__codelineno-3-19" name="__codelineno-3-19" href="#__codelineno-3-19"></a><span class="w">    </span><span class="n">scheduler_tick</span><span class="p">();</span>
</span><span id="__span-3-20"><a id="__codelineno-3-20" name="__codelineno-3-20" href="#__codelineno-3-20"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_POSIX_TIMERS</span><span class="p">))</span>
</span><span id="__span-3-21"><a id="__codelineno-3-21" name="__codelineno-3-21" href="#__codelineno-3-21"></a><span class="w">        </span><span class="n">run_posix_cpu_timers</span><span class="p">();</span>
</span><span id="__span-3-22"><a id="__codelineno-3-22" name="__codelineno-3-22" href="#__codelineno-3-22"></a><span class="p">}</span>
</span></code></pre></div>
<p>Notice how <code>update_process_times()</code> invokes <code>scheduler_tick()</code>. In
<code>scheduler_tick()</code>, the scheduler checks to see if the running process's time
has expired. If so, it sets a (over-simplification alert) per-CPU flag called
<code>need_resched</code>. This indicates to the rest of the kernel that <code>schedule()</code>
should be called. In our simplified example, <code>scheduler_tick()</code> would set this
flag when the current process has been running for 10 milliseconds or more.</p>
<p>But wait, why the heck can't <code>scheduler_tick()</code> just call <code>schedule()</code> by
itself, from within the timer interrupt? After all, if the scheduler knows that
a process's time has expired, shouldn't it just context switch right away?</p>
<p>As it turns out, it is not always safe to call <code>schedule()</code>. In particular, if
the currently running process is holding a spinlock in the kernel, it cannot be
put to sleep from the interrupt handler. (Let me repeat that one more time
because people always forget: <strong>you cannot sleep with a spinlock.</strong> Sleeping
with a spinlock may cause the kernel to deadlock, and will bring you anguish
for many hours when you can't figure out why your system has hung.)</p>
<p>When the scheduler sets the <code>need_resched</code> flag, it's really saying, "please
dearest kernel, invoke <code>schedule()</code> at your earliest convenience." The kernel
keeps a count of how many spinlocks the currently running process has acquired.
When that count goes down to 0, the kernel knows that it's okay to put the
process to sleep. The kernel checks the <code>need_resched</code> flag in two main places:</p>
<ul>
<li>
<p>when returning from an interrupt handler</p>
</li>
<li>
<p>when returning to user-space from a system call</p>
</li>
</ul>
<p>If <code>need_resched</code> is <code>True</code> and the spinlock count is 0, then the kernel calls
<code>schedule()</code>. With our simple linked-list runqueue, this delayed invocation of
<code>schedule()</code> implies that a process can possibly run for a bit longer than its
timeslice. We're cool with that because it's always safe to call <code>schedule()</code>
when the kernel is about to return to user-space. That's because user-space
programs are allowed to sleep. So, by the time the kernel is about to return to
user-space, it cannot be holding any spinlocks. This means that there won't be a
large delay between when <code>need_resched</code> is set, and when <code>schedule()</code> gets
called.</p>
<h2 id="understanding-sched_class">Understanding <code>sched_class</code></h2>
<p>In this section, I will analyze <code>struct sched_class</code> and talk briefly about what
most of the functions do. I've reproduced <code>struct sched_class</code> below.</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">sched_class</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span class="cp">#ifdef CONFIG_UCLAMP_TASK</span>
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">uclamp_enabled</span><span class="p">;</span>
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="cp">#endif</span>
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">enqueue_task</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">dequeue_task</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">yield_task</span><span class="p">)</span><span class="w">   </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">yield_to_task</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">check_preempt_curr</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">pick_next_task</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-4-15"><a id="__codelineno-4-15" name="__codelineno-4-15" href="#__codelineno-4-15"></a>
</span><span id="__span-4-16"><a id="__codelineno-4-16" name="__codelineno-4-16" href="#__codelineno-4-16"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">put_prev_task</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-4-17"><a id="__codelineno-4-17" name="__codelineno-4-17" href="#__codelineno-4-17"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_next_task</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">first</span><span class="p">);</span>
</span><span id="__span-4-18"><a id="__codelineno-4-18" name="__codelineno-4-18" href="#__codelineno-4-18"></a>
</span><span id="__span-4-19"><a id="__codelineno-4-19" name="__codelineno-4-19" href="#__codelineno-4-19"></a><span class="cp">#ifdef CONFIG_SMP</span>
</span><span id="__span-4-20"><a id="__codelineno-4-20" name="__codelineno-4-20" href="#__codelineno-4-20"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">balance</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq_flags</span><span class="w"> </span><span class="o">*</span><span class="n">rf</span><span class="p">);</span>
</span><span id="__span-4-21"><a id="__codelineno-4-21" name="__codelineno-4-21" href="#__codelineno-4-21"></a><span class="w">    </span><span class="kt">int</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">select_task_rq</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">task_cpu</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sd_flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-4-22"><a id="__codelineno-4-22" name="__codelineno-4-22" href="#__codelineno-4-22"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">migrate_task_rq</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_cpu</span><span class="p">);</span>
</span><span id="__span-4-23"><a id="__codelineno-4-23" name="__codelineno-4-23" href="#__codelineno-4-23"></a>
</span><span id="__span-4-24"><a id="__codelineno-4-24" name="__codelineno-4-24" href="#__codelineno-4-24"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task_woken</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">this_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">);</span>
</span><span id="__span-4-25"><a id="__codelineno-4-25" name="__codelineno-4-25" href="#__codelineno-4-25"></a>
</span><span id="__span-4-26"><a id="__codelineno-4-26" name="__codelineno-4-26" href="#__codelineno-4-26"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_cpus_allowed</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
</span><span id="__span-4-27"><a id="__codelineno-4-27" name="__codelineno-4-27" href="#__codelineno-4-27"></a><span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">newmask</span><span class="p">);</span>
</span><span id="__span-4-28"><a id="__codelineno-4-28" name="__codelineno-4-28" href="#__codelineno-4-28"></a>
</span><span id="__span-4-29"><a id="__codelineno-4-29" name="__codelineno-4-29" href="#__codelineno-4-29"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rq_online</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-4-30"><a id="__codelineno-4-30" name="__codelineno-4-30" href="#__codelineno-4-30"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rq_offline</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-4-31"><a id="__codelineno-4-31" name="__codelineno-4-31" href="#__codelineno-4-31"></a><span class="cp">#endif</span>
</span><span id="__span-4-32"><a id="__codelineno-4-32" name="__codelineno-4-32" href="#__codelineno-4-32"></a>
</span><span id="__span-4-33"><a id="__codelineno-4-33" name="__codelineno-4-33" href="#__codelineno-4-33"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task_tick</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">queued</span><span class="p">);</span>
</span><span id="__span-4-34"><a id="__codelineno-4-34" name="__codelineno-4-34" href="#__codelineno-4-34"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task_fork</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-4-35"><a id="__codelineno-4-35" name="__codelineno-4-35" href="#__codelineno-4-35"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task_dead</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-4-36"><a id="__codelineno-4-36" name="__codelineno-4-36" href="#__codelineno-4-36"></a>
</span><span id="__span-4-37"><a id="__codelineno-4-37" name="__codelineno-4-37" href="#__codelineno-4-37"></a><span class="w">    </span><span class="cm">/*</span>
</span><span id="__span-4-38"><a id="__codelineno-4-38" name="__codelineno-4-38" href="#__codelineno-4-38"></a><span class="cm">     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span>
</span><span id="__span-4-39"><a id="__codelineno-4-39" name="__codelineno-4-39" href="#__codelineno-4-39"></a><span class="cm">     * cannot assume the switched_from/switched_to pair is serliazed by</span>
</span><span id="__span-4-40"><a id="__codelineno-4-40" name="__codelineno-4-40" href="#__codelineno-4-40"></a><span class="cm">     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span>
</span><span id="__span-4-41"><a id="__codelineno-4-41" name="__codelineno-4-41" href="#__codelineno-4-41"></a><span class="cm">     */</span>
</span><span id="__span-4-42"><a id="__codelineno-4-42" name="__codelineno-4-42" href="#__codelineno-4-42"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">switched_from</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">this_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">);</span>
</span><span id="__span-4-43"><a id="__codelineno-4-43" name="__codelineno-4-43" href="#__codelineno-4-43"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">switched_to</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">this_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">);</span>
</span><span id="__span-4-44"><a id="__codelineno-4-44" name="__codelineno-4-44" href="#__codelineno-4-44"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">prio_changed</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">this_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">,</span>
</span><span id="__span-4-45"><a id="__codelineno-4-45" name="__codelineno-4-45" href="#__codelineno-4-45"></a><span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">oldprio</span><span class="p">);</span>
</span><span id="__span-4-46"><a id="__codelineno-4-46" name="__codelineno-4-46" href="#__codelineno-4-46"></a>
</span><span id="__span-4-47"><a id="__codelineno-4-47" name="__codelineno-4-47" href="#__codelineno-4-47"></a><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_rr_interval</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span>
</span><span id="__span-4-48"><a id="__codelineno-4-48" name="__codelineno-4-48" href="#__codelineno-4-48"></a><span class="w">                    </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">task</span><span class="p">);</span>
</span><span id="__span-4-49"><a id="__codelineno-4-49" name="__codelineno-4-49" href="#__codelineno-4-49"></a>
</span><span id="__span-4-50"><a id="__codelineno-4-50" name="__codelineno-4-50" href="#__codelineno-4-50"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">update_curr</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-4-51"><a id="__codelineno-4-51" name="__codelineno-4-51" href="#__codelineno-4-51"></a>
</span><span id="__span-4-52"><a id="__codelineno-4-52" name="__codelineno-4-52" href="#__codelineno-4-52"></a><span class="cp">#define TASK_SET_GROUP      0</span>
</span><span id="__span-4-53"><a id="__codelineno-4-53" name="__codelineno-4-53" href="#__codelineno-4-53"></a><span class="cp">#define TASK_MOVE_GROUP     1</span>
</span><span id="__span-4-54"><a id="__codelineno-4-54" name="__codelineno-4-54" href="#__codelineno-4-54"></a>
</span><span id="__span-4-55"><a id="__codelineno-4-55" name="__codelineno-4-55" href="#__codelineno-4-55"></a><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
</span><span id="__span-4-56"><a id="__codelineno-4-56" name="__codelineno-4-56" href="#__codelineno-4-56"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">task_change_group</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>
</span><span id="__span-4-57"><a id="__codelineno-4-57" name="__codelineno-4-57" href="#__codelineno-4-57"></a><span class="cp">#endif</span>
</span><span id="__span-4-58"><a id="__codelineno-4-58" name="__codelineno-4-58" href="#__codelineno-4-58"></a><span class="p">}</span><span class="w"> </span><span class="n">__aligned</span><span class="p">(</span><span class="n">STRUCT_ALIGNMENT</span><span class="p">);</span><span class="w"> </span><span class="cm">/* STRUCT_ALIGN(), vmlinux.lds.h */</span>
</span></code></pre></div>
<h3 id="enqueue_task-and-dequeue_task"><code>enqueue_task()</code> and <code>dequeue_task()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="cm">/* Called to enqueue task_struct p on runqueue rq. */</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">enqueue_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="cm">/* Called to dequeue task_struct p from runqueue rq. */</span>
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">dequeue_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span></code></pre></div>
<p><code>enqueue_task()</code> and <code>dequeue_task()</code> are used to put a task on the runqueue and
remove a task from the runqueue, respectively.</p>
<p>These functions are called for a variety of reasons:</p>
<ul>
<li>
<p>When a child process is first forked, <code>enqueue_task()</code> is called to put it on
  a runqueue. When a process exits, <code>dequeue_task()</code> takes it off the runqueue.</p>
</li>
<li>
<p>When a process goes to sleep, <code>dequeue_task()</code> takes it off the runqueue. For
  example, this happens when the process needs to wait for a lock or IO event.
  When the IO event occurs, or the lock becomes available, the process wakes up.
  It must then be re-enqueued with <code>enqueue_task()</code>.</p>
</li>
<li>
<p>Process migration - if a process must be migrated from one CPU's runqueue to
  another, it's dequeued from its old runqueue and enqueued on a different one
  using this function.</p>
</li>
<li>
<p>When <code>set_cpus_allowed()</code> is called to change the task's processor affinity,
  it may need to be enqueued on a different CPU's runqueue.</p>
</li>
<li>
<p>When the priority of a process is boosted to avoid priority inversion. In this
  case, the task used to have a low-priority <code>sched_class</code>, but is being
  promoted to a <code>sched_class</code> with high priority. This action occurs in
  <code>rt_mutex_setprio()</code>.</p>
</li>
<li>
<p>From <code>__sched_setscheduler</code>. If a task's <code>sched_class</code> has changed, it's
  dequeued using its old <code>sched_class</code> and enqueued with the new one.</p>
</li>
</ul>
<p>Each of these functions are passed the task to be enqueued/dequeued, as well as
the runqueue it should be added to/removed from. In addition, these functions
are given a bit vector of flags that describe <em>why</em> enqueue or dequeue is being
called. Here are the various flags, which are described in
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/sched.h#L1744">sched.h</a>:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="cm">/*</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="cm"> * {de,en}queue flags:</span>
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="cm"> *</span>
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="cm"> * DEQUEUE_SLEEP  - task is no longer runnable</span>
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a><span class="cm"> * ENQUEUE_WAKEUP - task just became runnable</span>
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a><span class="cm"> *</span>
</span><span id="__span-6-7"><a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a><span class="cm"> * SAVE/RESTORE - an otherwise spurious dequeue/enqueue, done to ensure tasks</span>
</span><span id="__span-6-8"><a id="__codelineno-6-8" name="__codelineno-6-8" href="#__codelineno-6-8"></a><span class="cm"> *                are in a known state which allows modification. Such pairs</span>
</span><span id="__span-6-9"><a id="__codelineno-6-9" name="__codelineno-6-9" href="#__codelineno-6-9"></a><span class="cm"> *                should preserve as much state as possible.</span>
</span><span id="__span-6-10"><a id="__codelineno-6-10" name="__codelineno-6-10" href="#__codelineno-6-10"></a><span class="cm"> *</span>
</span><span id="__span-6-11"><a id="__codelineno-6-11" name="__codelineno-6-11" href="#__codelineno-6-11"></a><span class="cm"> * MOVE - paired with SAVE/RESTORE, explicitly does not preserve the location</span>
</span><span id="__span-6-12"><a id="__codelineno-6-12" name="__codelineno-6-12" href="#__codelineno-6-12"></a><span class="cm"> *        in the runqueue.</span>
</span><span id="__span-6-13"><a id="__codelineno-6-13" name="__codelineno-6-13" href="#__codelineno-6-13"></a><span class="cm"> *</span>
</span><span id="__span-6-14"><a id="__codelineno-6-14" name="__codelineno-6-14" href="#__codelineno-6-14"></a><span class="cm"> * ENQUEUE_HEAD      - place at front of runqueue (tail if not specified)</span>
</span><span id="__span-6-15"><a id="__codelineno-6-15" name="__codelineno-6-15" href="#__codelineno-6-15"></a><span class="cm"> * ENQUEUE_REPLENISH - CBS (replenish runtime and postpone deadline)</span>
</span><span id="__span-6-16"><a id="__codelineno-6-16" name="__codelineno-6-16" href="#__codelineno-6-16"></a><span class="cm"> * ENQUEUE_MIGRATED  - the task was migrated during wakeup</span>
</span><span id="__span-6-17"><a id="__codelineno-6-17" name="__codelineno-6-17" href="#__codelineno-6-17"></a><span class="cm"> *</span>
</span><span id="__span-6-18"><a id="__codelineno-6-18" name="__codelineno-6-18" href="#__codelineno-6-18"></a><span class="cm"> */</span>
</span></code></pre></div>
<p>The <code>flags</code> argument can be tested using the bitwise <code>&amp;</code> operation. For example,
if the task was just migrated from another CPU, <code>flags &amp; ENQUEUE_MIGRATED</code>
evaluates to 1.</p>
<h3 id="pick_next_task"><code>pick_next_task()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="cm">/* Pick the task that should be currently running. */</span>
</span><span id="__span-7-2"><a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">pick_next_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span></code></pre></div>
<p><code>pick_next_task()</code> is called by the core scheduler to determine which of <code>rq</code>'s
tasks should be running. The name is a bit misleading: This function is not
supposed to return the task that should run <em>after</em> the currently running task;
instead, it's supposed to return the <code>task_struct</code> that should be running now,
<strong>in this instant.</strong></p>
<p>The kernel will context switch from the currently running task to the task
returned by <code>pick_next_task()</code>.</p>
<h3 id="put_prev_task"><code>put_prev_task()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="cm">/* Called right before p is going to be taken off the CPU. */</span>
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">put_prev_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></div>
<p><code>put_prev_task()</code> is called whenever a task is to be taken off the CPU. The
behavior of this function is up to the specific <code>sched_class</code>. Some schedulers
do very little in this function. For example, the realtime scheduler uses this
function as an opportunity to perform simple bookkeeping. On the other hand,
CFS's <code>put_prev_task_fair()</code> needs to do a bit more work. As an optimization,
CFS keeps the currently running task out of its RB tree. It uses the
<code>put_prev_task</code> hook as an opportunity to put the currently running task (that
is, the task specified by <code>p</code>) back in the RB tree.</p>
<p>The sched_class's <code>put_prev_task</code> is called by the function <code>put_prev_task()</code>,
which is
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/sched.h#L1842">defined</a>
in <code>sched.h</code>. <code>put_prev_task()</code> gets called in the core scheduler's
<code>pick_next_task()</code>, after the policy-specific <code>pick_next_task()</code> implementation
is called, but before any context switch is performed. This gives us an
opportunity to perform any operations we need to do to move on from the
previously running task in our scheduler implementations.</p>
<p>Note that this was not the case in older kernels: The <code>sched_class</code>'s
<code>pick_next_task()</code> is expected to call <code>put_prev_task()</code> by itself! This is
documented in the following
<a href="https://elixir.bootlin.com/linux/v4.9.330/source/kernel/sched/sched.h#L1241">comment</a>
in an earlier Linux version (4.9). Before that (3.11), <code>put_prev_task</code> actually
<a href="https://elixir.bootlin.com/linux/v3.11/source/kernel/sched/core.c#L2445">used to be called</a>
by the core scheduler before it called <code>pick_next_task</code>.</p>
<h3 id="task_tick"><code>task_tick()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="cm">/* Called from the timer interrupt handler. p is the currently running task</span>
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="cm"> * and rq is the runqueue that it&#39;s on.</span>
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a><span class="cm"> */</span>
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">task_tick</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">queued</span><span class="p">);</span>
</span></code></pre></div>
<p>This is one of the most important scheduler functions. It is called whenever a
timer interrupt happens, and its job is to perform bookeeping and set the
<code>need_resched</code> flag if the currently-running process needs to be preempted:</p>
<p>The <code>need_resched</code> flag can be set by the function <code>resched_curr()</code>,
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/core.c#L608">found</a>
in core.c:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a><span class="cm">/* Mark rq&#39;s currently-running task &#39;to be rescheduled now&#39;. */</span>
</span><span id="__span-10-2"><a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">resched_curr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">)</span>
</span></code></pre></div>
<p>With SMP, there's a <code>need_resched</code> flag for every CPU. Thus, <code>resched_curr()</code>
might involve sending an APIC inter-processor interrupt to another processor
(you don't want to go here). The takeway is that you should just use
<code>resched_curr()</code> to set <code>need_resched</code>, and don't try to do this yourself.</p>
<p>Note: in prior kernel versions, <code>resched_curr()</code> used to be called
<code>resched_task()</code>.</p>
<h3 id="select_task_rq"><code>select_task_rq()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="cm">/* Returns an integer corresponding to the CPU that this task should run on */</span>
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a><span class="kt">int</span><span class="w"> </span><span class="nf">select_task_rq</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">task_cpu</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sd_flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span></code></pre></div>
<p>The core scheduler invokes this function to figure out which CPU to assign a
task to. This is used for distributing processes accross multiple CPUs; the core
scheduler will call <code>enqueue_task()</code>, passing the runqueue corresponding to the
CPU that is returned by this function. CPU assignment obviously occurs when a
process is first forked, but CPU reassignment can happen for a large variety of
reasons. Here are some instances where <code>select_task_rq()</code> is called:</p>
<ul>
<li>
<p>When a process is first forked.</p>
</li>
<li>
<p>When a task is woken up after having gone to sleep.</p>
</li>
<li>
<p>In response to any of the syscalls in the execv family. This is an
  optimization, since it doesn't hurt the cache to migrate a process that's
  about to call exec.</p>
</li>
<li>
<p>And many more places...</p>
</li>
</ul>
<p>You can check <em>why</em> <code>select_task_rq</code> was called by looking at <code>sd_flag</code>.</p>
<p>For instance, <code>sd_flag == SD_BALANCE_FORK</code> whenever <code>select_task_rq()</code> is called
to determine the CPU of a newly forked task. You can find all possible values of
<code>sd_flag</code>
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/include/linux/sched/sd_flags.h">here</a>.</p>
<p>Note that <code>select_task_rq()</code> should return a CPU that <code>p</code> is allowed to run on.
Each <code>task_struct</code> has a
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/include/linux/sched.h#L728">member</a>
called <code>cpus_mask</code>, of type <code>cpumask_t</code>. This member represents the task's CPU
affinity - i.e. which CPUs it can run on. It's possible to iterate over these
CPUs with the macro <code>for_each_cpu()</code>, defined
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/include/linux/cpumask.h#L263">here</a>.</p>
<h3 id="set_next_task"><code>set_next_task()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a><span class="cm">/* Called when a task changes its scheduling class or changes its task group. */</span>
</span><span id="__span-12-2"><a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">set_next_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">first</span><span class="p">);</span>
</span></code></pre></div>
<p>This function is called in the following instances:</p>
<ul>
<li>
<p>When the current task's CPU affinity changes.</p>
</li>
<li>
<p>When the current task's priority, nice value, or scheduling policy changes.</p>
</li>
<li>
<p>When the current task's task group changes.</p>
</li>
</ul>
<p>This function was previously called <code>set_curr_task()</code>, but was changed to better
match <code>put_prev_task()</code>. Several scheduling policies also call <code>set_next_task()</code>
in their implementations of <code>pick_next_task()</code>. An <a href="https://lore.kernel.org/all/a96d1bcdd716db4a4c5da2fece647a1456c0ed78.1559129225.git.vpillai@digitalocean.com/T/#m2632708495575d24c1a5c54f7295836a907d3d53">old kernel
commit</a>
claims that <code>pick_next_task()</code> implies <code>set_next_task()</code>, but <code>pick_next_task()</code>
technically shouldn't modify any state. In practice, this means that
<code>set_next_task()</code> ends up just updating some of the task's metadata.</p>
<h3 id="yield_task"><code>yield_task()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="cm">/* Called when the current task yields the cpu */</span>
</span><span id="__span-13-2"><a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">yield_task</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span></code></pre></div>
<p><code>yield_task()</code> is used when the current process voluntarily yields its remaining
time on the CPU. Its implementation is usually very simple, as you can see in
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/rt.c#L1434">rt</a>,
which simply requeues the current task.</p>
<p>This function is called when a process calls the <code>sched_yield()</code> syscall to
relinquish the control of the processor voluntarily. <code>schedule()</code> is then
called.</p>
<h3 id="check_preempt_curr"><code>check_preempt_curr()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a><span class="cm">/* Preempt the current task with a newly woken task if needed */</span>
</span><span id="__span-14-2"><a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">check_preempt_curr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</span></code></pre></div>
<p>When a new task enters a runnable state, this function is called to check if
that task should preempt the currently running task. For instance, when a new
task is created, it is initially woken up with <code>wake_up_new_task()</code>, which
(among other things) places the task on the runqueue, calls the generic
<code>check_preempt_curr()</code>, and calls the <code>sched_class-&gt;task_woken()</code> function if it
exists.</p>
<p>The generic <code>check_preempt_curr()</code> function does the following:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">check_preempt_curr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</span><span id="__span-15-2"><a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a><span class="p">{</span>
</span><span id="__span-15-3"><a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
</span><span id="__span-15-4"><a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a><span class="w">        </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
</span><span id="__span-15-5"><a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
</span><span id="__span-15-6"><a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a><span class="w">        </span><span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
</span><span id="__span-15-7"><a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a>
</span><span id="__span-15-8"><a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a><span class="w">    </span><span class="cm">/* CODE OMITTED */</span>
</span><span id="__span-15-9"><a id="__codelineno-15-9" name="__codelineno-15-9" href="#__codelineno-15-9"></a><span class="p">}</span><span class="w">   </span>
</span></code></pre></div>
<p>This handles both the case where the new task has a higher priority within a
scheduling class (using the callback pointer) or a higher priority scheduling
class.</p>
<h3 id="balance"><code>balance()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">balance</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq_flags</span><span class="w"> </span><span class="o">*</span><span class="n">rf</span><span class="p">);</span>
</span></code></pre></div>
<p><code>balance()</code> implements various scheduler load-balancing mechanisms, which are
meant to distribute the load across processors more evenly using various
heuristics. It returns <code>1</code> if there is a runnable task of that <code>sched_class</code>'s
priority or higher after load balancing occurs, and <code>0</code> otherwise.</p>
<p><code>balance()</code> is called in <code>put_prev_task_balance()</code> (which is called in
<code>pick_next_task()</code>) as follows:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">put_prev_task_balance</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span>
</span><span id="__span-17-2"><a id="__codelineno-17-2" name="__codelineno-17-2" href="#__codelineno-17-2"></a><span class="w">                  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq_flags</span><span class="w"> </span><span class="o">*</span><span class="n">rf</span><span class="p">)</span>
</span><span id="__span-17-3"><a id="__codelineno-17-3" name="__codelineno-17-3" href="#__codelineno-17-3"></a><span class="p">{</span>
</span><span id="__span-17-4"><a id="__codelineno-17-4" name="__codelineno-17-4" href="#__codelineno-17-4"></a><span class="cp">#ifdef CONFIG_SMP</span>
</span><span id="__span-17-5"><a id="__codelineno-17-5" name="__codelineno-17-5" href="#__codelineno-17-5"></a><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_class</span><span class="w"> </span><span class="o">*</span><span class="n">class</span><span class="p">;</span>
</span><span id="__span-17-6"><a id="__codelineno-17-6" name="__codelineno-17-6" href="#__codelineno-17-6"></a><span class="w">    </span><span class="cm">/*</span>
</span><span id="__span-17-7"><a id="__codelineno-17-7" name="__codelineno-17-7" href="#__codelineno-17-7"></a><span class="cm">     * We must do the balancing pass before put_prev_task(), such</span>
</span><span id="__span-17-8"><a id="__codelineno-17-8" name="__codelineno-17-8" href="#__codelineno-17-8"></a><span class="cm">     * that when we release the rq-&gt;lock the task is in the same</span>
</span><span id="__span-17-9"><a id="__codelineno-17-9" name="__codelineno-17-9" href="#__codelineno-17-9"></a><span class="cm">     * state as before we took rq-&gt;lock.</span>
</span><span id="__span-17-10"><a id="__codelineno-17-10" name="__codelineno-17-10" href="#__codelineno-17-10"></a><span class="cm">     *</span>
</span><span id="__span-17-11"><a id="__codelineno-17-11" name="__codelineno-17-11" href="#__codelineno-17-11"></a><span class="cm">     * We can terminate the balance pass as soon as we know there is</span>
</span><span id="__span-17-12"><a id="__codelineno-17-12" name="__codelineno-17-12" href="#__codelineno-17-12"></a><span class="cm">     * a runnable task of @class priority or higher.</span>
</span><span id="__span-17-13"><a id="__codelineno-17-13" name="__codelineno-17-13" href="#__codelineno-17-13"></a><span class="cm">     */</span>
</span><span id="__span-17-14"><a id="__codelineno-17-14" name="__codelineno-17-14" href="#__codelineno-17-14"></a><span class="w">    </span><span class="n">for_class_range</span><span class="p">(</span><span class="n">class</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-17-15"><a id="__codelineno-17-15" name="__codelineno-17-15" href="#__codelineno-17-15"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="n">rf</span><span class="p">))</span>
</span><span id="__span-17-16"><a id="__codelineno-17-16" name="__codelineno-17-16" href="#__codelineno-17-16"></a><span class="w">            </span><span class="k">break</span><span class="p">;</span>
</span><span id="__span-17-17"><a id="__codelineno-17-17" name="__codelineno-17-17" href="#__codelineno-17-17"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-17-18"><a id="__codelineno-17-18" name="__codelineno-17-18" href="#__codelineno-17-18"></a><span class="cp">#endif</span>
</span><span id="__span-17-19"><a id="__codelineno-17-19" name="__codelineno-17-19" href="#__codelineno-17-19"></a>
</span><span id="__span-17-20"><a id="__codelineno-17-20" name="__codelineno-17-20" href="#__codelineno-17-20"></a><span class="w">    </span><span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">prev</span><span class="p">);</span>
</span><span id="__span-17-21"><a id="__codelineno-17-21" name="__codelineno-17-21" href="#__codelineno-17-21"></a><span class="p">}</span>
</span></code></pre></div>
<p>The main idea is to prevent any runqueue from becoming empty, as this is a waste
of resources. This loop starts with the currently running task's <code>sched_class</code>
and uses the <code>balance()</code> callbacks to check if there are runnable tasks of that
<code>sched_class</code>'s priority <em>or higher</em>. Notably, <code>sched_class</code>'s implementation of
<code>balance()</code> checks if <code>sched_class</code>s of higher priority also have runnable tasks.</p>
<h3 id="update_curr"><code>update_curr()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-18-1"><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a><span class="cm">/* Update the current task&#39;s runtime statistics. */</span>
</span><span id="__span-18-2"><a id="__codelineno-18-2" name="__codelineno-18-2" href="#__codelineno-18-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">update_curr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">);</span>
</span></code></pre></div>
<p>This function updates the current task's stats such as the total execution time.
Implementing this function allows commands like <code>ps</code> and <code>htop</code> to display
accurate statistics. The implementations of this function typically share a
common segment across the different scheduling classes. This function is
typically called in other <code>sched_class</code> functions to facilitate accurate
reporting of statistics.</p>
<h3 id="prio_changed"><code>prio_changed()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-19-1"><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a><span class="cm">/* Called when the task&#39;s priority has changed. */</span>
</span><span id="__span-19-2"><a id="__codelineno-19-2" name="__codelineno-19-2" href="#__codelineno-19-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">prio_changed</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">oldprio</span><span class="p">)</span>
</span></code></pre></div>
<p>This function is called whenever a task's priority changes, but the
<code>sched_class</code> remains the same (you can verify this by checking where the
function pointer is called). This can occur through various syscalls which
modify the <code>nice</code> value, the priority, or other scheduler attributes.</p>
<p>In a scheduler class with priorities, this function will typically check if the
task whose priority changed needs to preempt the currently running task (or if
it is the currently running task, if it should be preempted).</p>
<h3 id="switched_to"><code>switched_to()</code></h3>
<div class="language-c highlight"><pre><span></span><code><span id="__span-20-1"><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a><span class="cm">/* Called when a task gets switched to this scheduling class. */</span>
</span><span id="__span-20-2"><a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">switched_to</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></div>
<p><code>switched_to()</code> (and its optional counterpart, <code>switched_from()</code>) are called
from <code>check_class_changed()</code>:</p>
<div class="language-c highlight"><pre><span></span><code><span id="__span-21-1"><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_class_changed</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span>
</span><span id="__span-21-2"><a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a><span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_class</span><span class="w"> </span><span class="o">*</span><span class="n">prev_class</span><span class="p">,</span>
</span><span id="__span-21-3"><a id="__codelineno-21-3" name="__codelineno-21-3" href="#__codelineno-21-3"></a><span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">oldprio</span><span class="p">)</span>
</span><span id="__span-21-4"><a id="__codelineno-21-4" name="__codelineno-21-4" href="#__codelineno-21-4"></a><span class="p">{</span>
</span><span id="__span-21-5"><a id="__codelineno-21-5" name="__codelineno-21-5" href="#__codelineno-21-5"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_class</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-21-6"><a id="__codelineno-21-6" name="__codelineno-21-6" href="#__codelineno-21-6"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">)</span>
</span><span id="__span-21-7"><a id="__codelineno-21-7" name="__codelineno-21-7" href="#__codelineno-21-7"></a><span class="w">            </span><span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-21-8"><a id="__codelineno-21-8" name="__codelineno-21-8" href="#__codelineno-21-8"></a>
</span><span id="__span-21-9"><a id="__codelineno-21-9" name="__codelineno-21-9" href="#__codelineno-21-9"></a><span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">switched_to</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-21-10"><a id="__codelineno-21-10" name="__codelineno-21-10" href="#__codelineno-21-10"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oldprio</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dl_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</span><span id="__span-21-11"><a id="__codelineno-21-11" name="__codelineno-21-11" href="#__codelineno-21-11"></a><span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">prio_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">oldprio</span><span class="p">);</span>
</span><span id="__span-21-12"><a id="__codelineno-21-12" name="__codelineno-21-12" href="#__codelineno-21-12"></a><span class="p">}</span>
</span></code></pre></div>
<p><code>check_class_changed()</code> gets called from syscalls that modify scheduler
parameters.</p>
<p>For scheduler classes like
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/rt.c#L2305">rt</a>
and
<a href="https://elixir.bootlin.com/linux/v5.10.205/source/kernel/sched/deadline.c#L2462">dl</a>,
the main consideration when a task's policy changes to their policy is that it
could overload their runqueue. They then try to push some tasks to other
runqueues.</p>
<p>However, for lower priority scheduler classes, like CFS, where overloading is
not an issue, <code>switched_to()</code> just ensures that the task gets to run, and
preempts the current task (which may be of a lower-priority policy) if
necessary.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023&ndash;2024 <a href="https://rdnajac.tech">Ryan D. Najac</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": ["content.code.copy"], "search": "../../../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
    
  </body>
</html>